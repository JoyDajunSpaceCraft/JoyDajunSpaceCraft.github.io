<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joy Blog</title>
    <description>季月侣的Blog || About Joy </description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 06 Jan 2021 10:33:46 +0800</pubDate>
    <lastBuildDate>Wed, 06 Jan 2021 10:33:46 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title> ReinforcementLearning  </title>
        <description>&lt;h1 id=&quot;一些数学概念&quot;&gt;一些数学概念&lt;/h1&gt;

&lt;h2 id=&quot;行列式公式&quot;&gt;行列式公式&lt;/h2&gt;

&lt;p&gt;c&lt;sub&gt;i,j&lt;/sub&gt; = (-1)&lt;sup&gt;i+j&lt;/sup&gt;det(A)&lt;sub&gt;i,j&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;det(A) = a11·c11 + a12·c12···+a1n·c1n&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/rl/math_pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;行列式的值&quot;&gt;行列式的值&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实行列式的值是高维空间中的体积&lt;/li&gt;
  &lt;li&gt;如果两个row的值相同说明这个矩阵的行列式是0&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;概念解析&quot;&gt;概念解析&lt;/h1&gt;
&lt;p&gt;首先根据2020年李宏毅机器学习中的概念将reinforcement learning 作为一种 非 supervice learning的形式作出对比&lt;/p&gt;
&lt;h2 id=&quot;以alphago为例&quot;&gt;以AlphaGo为例&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;supervice learning 表示从一个老师那里学习&lt;/li&gt;
  &lt;li&gt;reinforcement learning 是根据过去的经验来学习&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;以电玩为例&quot;&gt;以电玩为例&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;比如一款星球大战游戏，玩家需要操纵机器往左还是往右，射击还是移动，每次做出动作都会有一个reward作为结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用领域&quot;&gt;应用领域&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Chatbot作用于 如果人也不知道怎么做，但是用reinforcement learning 可以更快的会的结果。&lt;/li&gt;
  &lt;li&gt;最常用的Application是
    &lt;h2 id=&quot;难点&quot;&gt;难点&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;reward有滞后性，短期牺牲会有好结果&lt;/li&gt;
  &lt;li&gt;agent要会探索世界&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a3c-新概念&quot;&gt;A3C 新概念？&lt;/h2&gt;
&lt;h3 id=&quot;policy-based-vs-value-based&quot;&gt;policy based v.s. value based&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;policy based -&amp;gt; learning an actor： 找一个function
&lt;img src=&quot;/img/rl/policy_actor.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;value based -&amp;gt; learning a critic：找一个评价指标&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以最强的是将policy 和 value结合的一种方法 Asynchronous Advatage Actor-Crtic(A3C) Alpha Go 是以上两种方法的结合&lt;/p&gt;

&lt;h3 id=&quot;policy-based---learning-an-actor&quot;&gt;policy based -&amp;gt; learning an actor&lt;/h3&gt;

&lt;h4 id=&quot;步骤&quot;&gt;步骤&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/rl/policySteps.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;nn-as-actor-第一步&quot;&gt;NN as Actor 第一步&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;input: the observation of machine represented as a vector or a matrix&lt;/li&gt;
  &lt;li&gt;output: each action corresponds to a neuron in putput layer
 比如 上面的电玩例子，input是每次的图片 pixels 经过NN 获得结果 左移，右移 或者开火
看到哪个output的几率会采取哪种action
&lt;img src=&quot;/img/rl/step1.jpg&quot; alt=&quot;&quot; /&gt;
好处就是：比较general，毕竟机器可以预测没有看到过的信息。&lt;/li&gt;
  &lt;li&gt;对于supervised learning 的 review
    &lt;h4 id=&quot;goodness-of-actor-第二步&quot;&gt;Goodness of Actor 第二步&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;give an actor&lt;/li&gt;
  &lt;li&gt;use actor to play the video game 
最大化每次游戏结束的total reward而不是每次action的reward，即使是给了相同的action还是会有不同的reward因为游戏本身有随机性。其实是max reward的期望。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/rl/step2/expectation.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pick-best-function-第三步&quot;&gt;pick best function 第三步&lt;/h4&gt;
&lt;p&gt;最大化R用Gradient Ascent
假设在sample data中 计算 gradient 其实就是很直觉的几率看到某个1observation 会的reward 会变好。
为什么要取log 对 p的微分 再除 p的几率 偏好 action b出现的几率多 出掉某个比较大的值相当于 normalization&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;问题 env 和 Reward是黑盒子需要用 policy gradient train
    &lt;h3 id=&quot;value-based---learning-a-critic&quot;&gt;value based -&amp;gt; learning a critic&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;a critic is a function depending on the actor pπie it is evaluated
    &lt;ul&gt;
      &lt;li&gt;the function is represented by a neural netword&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;state value function V&lt;sup&gt;π&lt;/sup&gt;(s)
    &lt;ul&gt;
      &lt;li&gt;when using actor π, the cumulated reward expects to be obtained after seeing observation(state)
critic 工作就是衡量一个actor好不好， critic会随着actor的不同而改变&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;怎么评估 Critic
    &lt;ol&gt;
      &lt;li&gt;蒙特卡洛 在游戏结束才知道 reward是多少&lt;/li&gt;
      &lt;li&gt;temporal-difference 方法 $V^π(S_t)=V^T(S_t+1)+r_t$&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;虽然不知道两个实验中获得的V是多少，但是要让差值越接近r_t越好，好处是在游戏没有结束的时候可以开始train&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;another critic 另一种 critic方式，在每次对V输入的时候不光是输入 observation 的S 还要输入 actor，算出取得的reward，假设 action是可以&lt;strong&gt;穷举&lt;/strong&gt;的。可以用Qfunction找出一个比较好的 actor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Q function 的妙用 1）初始的π 2）蒙特卡洛或者 temporal-difference 方法学出 Q value 3）学出的Qfunction 给了一个新的π 比原来的 π更好&lt;/p&gt;

&lt;p&gt;重点在2）到3）步骤 需要在 Voldπ大于等于Vnewπ，也就是π的更新值要一直大于 原先的值&lt;/p&gt;

&lt;p&gt;详情见一片rainbow文章&lt;/p&gt;

&lt;h3 id=&quot;actor-和-critic-a3c-asynchronous-advatage-actor-critic&quot;&gt;actor 和 critic A3C （Asynchronous Advatage Actor-Critic）&lt;/h3&gt;
&lt;p&gt;&lt;a hrrf=&quot;https://github.com/JoyDajunSpaceCraft/pytorch-a2c-ppo-acktr-gail/blob/master/a2c_ppo_acktr/model.py&quot; target=&quot;_blank&quot;&gt;A3C实现&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;a3c-的精神&quot;&gt;A3C 的精神&lt;/h4&gt;
&lt;p&gt;一般都是根据 Actor 来学习reward 但是A3C是根据 Critic学&lt;/p&gt;

&lt;h4 id=&quot;asynchronous&quot;&gt;Asynchronous&lt;/h4&gt;
&lt;p&gt;Asynchronous是什么意思：有一个global的 Actor 和 gobal 的 Critic 到学习的时候&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;copy global paramters&lt;/li&gt;
  &lt;li&gt;sampling some data&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;policy-gradient-方法-针对-env-和-reward&quot;&gt;policy gradient 方法 针对 env 和 reward&lt;/h3&gt;
&lt;p&gt;因为env 和 reward是不可微分的黑盒子，所以需要实现对这两个内容的train 就用 policy gradient&lt;/p&gt;

&lt;h3 id=&quot;inverse-reinforcement-learning&quot;&gt;inverse reinforcement learning&lt;/h3&gt;
&lt;p&gt;imitation learning 的一种 ，没有reward function ，因为多数的情况下是没有reward的，所以用这个来获得reward function&lt;/p&gt;

&lt;h1 id=&quot;小概念-ppo-proximal-policy-optimization&quot;&gt;小概念 PPO Proximal Policy Optimization&lt;/h1&gt;
&lt;p&gt;从policy gradient 到 on-policy 和 off-policy 再到 add constraint&lt;/p&gt;
&lt;h2 id=&quot;policy-gradient&quot;&gt;policy gradient&lt;/h2&gt;
&lt;p&gt;action env reward-function&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;policy π is a network with parameter Θ
    &lt;ul&gt;
      &lt;li&gt;input 电玩： 游戏画面&lt;/li&gt;
      &lt;li&gt;output 机器产生什么样的行为 电玩 ： 左右 开火
游戏初始画面 s1 做出action a1 获得 reward r1 
新的游戏画面s2 …
直到游戏决定结束了，一场游戏叫做episode R表示total reward 
trajectory τ = {s1,a1,s2,a2…}
获得 的几率是：pΘ(τ) = p(s1)pΘ(a1|s1)p(s2|s1,a1)pΘ(a2|s2)…
              = p(s1)∏pΘ(at,st)p(St+1|St,at)
p(St+1|St,at)是env也就是游戏环境，pΘ(at,st)是actor的行为。
所以前后的图片几率还是有关系的。
获得的R是有规律的，穷举每一个可能的τ，R&lt;sub&gt;Θ&lt;/sub&gt;= ∑&lt;sub&gt;τ&lt;/sub&gt;R(τ)pΘ(τ) 
就是得到期望值R(τ)，最大化 这个期望， 用到gradient deciant&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实作的时候的细节 loss function 是 crossentropy 要记得乘上 total reward&lt;/li&gt;
  &lt;li&gt;tips 1. add baseline 很多游戏只有正的reward ，因为reward一直是乘在几率之前，表示了上升的多少，但是我们是sample所以的action如果有一个reward没有被sample到，它的reward就是0，下次增加的几率就是0，所以将 reward要减去某个概率保证reward有正有负。减去的值就是平均值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;imag&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;tips 2. assign suitable credit 每次游戏可能会是某件事情的累加，因为sample次数不多，合理的contribution需要计算。所以前面的R变为从某个时间t开始直到游戏结束，还要再乘上 一个小于1的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;imag&lt;/p&gt;
&lt;h2 id=&quot;from-on-policy-to-off-policy&quot;&gt;from on-policy to off-policy&lt;/h2&gt;
</description>
        <pubDate>Mon, 27 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/12/27/ReinforcementLearning/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/27/ReinforcementLearning/</guid>
        
        <category>Python</category>
        
        <category>Reinforcement Learning</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> ParlAI Chatbot </title>
        <description>&lt;h1 id=&quot;parlai-a-dialog-research-software-platform-alexander-阅读&quot;&gt;ParlAI: A Dialog Research Software Platform Alexander 阅读&lt;/h1&gt;
&lt;h2 id=&quot;abstract&quot;&gt;abstract&lt;/h2&gt;
&lt;p&gt;一个用Python实现的对话研究的开源软件平台，可在http://parl.ai。其目标是提供一个统一的框架，用于共享、培训和测试对话模型；集成Amazon Mechani-cal Turk进行数据收集、人类评估和在线/强化学习；以及一个机器学习模型库，用于与其他模型进行比较，并改进现有架构。超过20个任务在第一次重新租赁支持，包括流行的数据集，SQuAD, bAbI tasks，MCTest，维基，QACNN，QADailyMail，CBT，bAbI Di-alog，Ubuntu，OpenSubtitles和VQA。集成了几种模型，包括记忆网络、seq2seq和注意LSTMs等神经模型。&lt;/p&gt;

&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;语言的目的是为了达到交流的目的，这通常涉及到两个或多个交流者之间的对话（Crystal，2004）。因此，试图解决对话是NLP社区研究人员的基本目标。从机器学习的角度来看，构建一个能够对话的学习代理也是很有趣的，原因很多，主要是解决方案涉及到实现领域的大多数子目标，而且在许多情况下，这些子任务直接影响任务。一方面，对话可以看作是一种罪恶-&lt;/p&gt;

&lt;p&gt;gle任务（学习如何交谈）和另一方面，作为数千个相关的任务，需要不同的技能，所有的输入和输出格式相同。预定餐厅、聊天的任务，关于体育或新闻，或回答事实或感性的问题都属于Dialog。因此，执行任务转移的方法对最终目标很有用。记忆、逻辑和常识推理、计划、交互学习、学习组合性和其他人工智能子目标在对话中也有明确的作用。然而，为了追求这些研究目标，软-&lt;/p&gt;

&lt;p&gt;软件工具应该统一不同的对话子任务和可以从中学习的代理。处理单个数据集可能会导致孤立&lt;/p&gt;

&lt;h2 id=&quot;goal&quot;&gt;Goal&lt;/h2&gt;
&lt;p&gt;开发dia-log模型的统一框架。ParlAI的目标是将提供给机器学习代理的对话数据集输入格式统一为单一格式，并尽可能使评估框架和指标标准化。搜索者可以将他们的新任务和他们的代理培训代码提交到存储库，以便与其他人共享，以帮助再现性，并更好地支持后续研究。&lt;/p&gt;

&lt;p&gt;涉及许多不同技能的一般对话。ParlAI包含真实和模拟语言数据集的无缝组合，并通过使多任务模型与单任务模型一样易于构建，鼓励多任务模型的开发和评估。这将减少模型设计对特定数据集的过度拟合，并鼓励执行任务转移的模型，这是通用对话代理的一个重要先决条件。&lt;/p&gt;

&lt;p&gt;真正与人对话。ParlAI通过Amazon Mechanical Turk可以收集、培训和评估与hu-mans的实时对话，这使得Turkers与对话代理之间的连接更加容易，见图2。这也使得比较不同研究小组Turker实验成为可能，这在历史上是很困难的。一个通用的对话模型。我们的目标是激励构建新的任务和代理，使领域朝着工作的方向发展。因此，进入知识库的每个新任务都应该朝着这个共同目标努力，而不是仅仅被看作是一项独立的研究。&lt;/p&gt;

&lt;h2 id=&quot;基本属性&quot;&gt;基本属性&lt;/h2&gt;
&lt;p&gt;ParlAI由许多任务和代理组成，可以用来解决这些问题。ParlAI中的所有任务都有一个单一格式（API），这使得将任何代理应用于任何任务或同时执行多个任务变得简单。这些任务包括固定的监督/模拟学习数据集（即会话日志）和交互式（在线或强化学习）任务，以及真实语言和模拟任务，这些任务都可以无缝地进行培训。ParlAI还支持其他媒体，例如图像以及视觉问题解答文本（Antol等人，2015年）或基于视觉的对话（Das等人，2017年）。ParlAI会在任务和数据集首次使用时自动下载它们。可以在环境（任务）中嵌入一个或多个机械突厥器来收集数据、训练或评估学习代理。示例包含在&lt;/p&gt;

&lt;p&gt;与PyTorch 和 Lua Torch一起训练。ParlAI使用ZeroMQ与Python以外的语言（如Lua Torch）进行对话。代码中支持模型的批训练和hog-wild训练。图3给出了用于训练主代理的示例。&lt;/p&gt;

&lt;h2 id=&quot;几个概念的解析&quot;&gt;几个概念的解析&lt;/h2&gt;

&lt;p&gt;World,agent teacher
World-环境。这可以从非常简单（例如只有两个agent进行转换）到更复杂（例如交互环境中的多个代理）。&lt;/p&gt;

&lt;p&gt;•agent——能够在世界范围内行动（尤其是说话）的agent。agent可以是学习者（即机器学习系统），也可以是硬编码的机器人，例如设计用来与学习者或人类（如Turker）互动的机器人。&lt;/p&gt;

&lt;p&gt;•teacher一种与学习者对话以进行教学的代理，例如执行图1中的任务之一。&lt;/p&gt;

&lt;p&gt;在定义了一个世界和其中的代理人之后&lt;/p&gt;

&lt;p&gt;主循环可以运行用于训练、测试或显示，调用函数世界谈判（）跑世界的一步。图3给出了显示数据的示例代码，运行该代码的输出如图4所示&lt;/p&gt;

&lt;h2 id=&quot;actions-and-observations&quot;&gt;Actions and Observations&lt;/h2&gt;
&lt;p&gt;所有的agent（包括teacher）都以一种单一的通用格式（观察/动作对象（python dict）进行交互，见图5。它用于在代理之间传递文本、标签和奖励。同一对象类型用于说话（演戏）和倾听（观察），但字段中的值不同。因此，对象从代理.act传入并传递给（）探员。观察（），见图3。信息的字段如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;text: a speech act.&lt;/li&gt;
  &lt;li&gt;id: the speaker’s identity.&lt;/li&gt;
  &lt;li&gt;reward: a real-valued reward assigned to the receiver of the message.&lt;/li&gt;
  &lt;li&gt;episode done: indicating the end of a dialog.&lt;/li&gt;
  &lt;li&gt;label: a set of answers the speaker is expect- ing to receive in reply, e.g. for QA datasets the right answers to a question.&lt;/li&gt;
  &lt;li&gt;label candidates: a set of possible ways to respond supplied by a teacher, e.g. for multi- ple choice datasets or ranking tasks.&lt;/li&gt;
  &lt;li&gt;text candidates: ranked candidate predic- tions from a learner. Used to evaluate ranking metrics, rather than just evaluate the single response in the text field.&lt;/li&gt;
  &lt;li&gt;metrics: A teacher can communicate to a learning agent metrics on its performance.
Finally other media can also be supported with additional fields:&lt;/li&gt;
  &lt;li&gt;image: an image, e.g. for Visual Question Answering or Visual Dialog datasets&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;code-structure&quot;&gt;Code Structure&lt;/h2&gt;
&lt;p&gt;The ParlAI codebase has five main directories: • core: the primary code for the platform.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;agents: contains agents which can interact with the worlds/tasks (e.g. learning models).&lt;/li&gt;
  &lt;li&gt;examples: contains examples of different mains (display data, training and evaluation).&lt;/li&gt;
  &lt;li&gt;tasks: contains code for the different tasks available from within ParlAI.&lt;/li&gt;
  &lt;li&gt;mturk: contains code for setting up Mechan- ical Turk and sample MTurk tasks.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;core&quot;&gt;core&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;agent.py:定义所有代理的代理基类，它实现observe（）和act（）方法，Teacher类也报告度量，以及MultiTaskTeacher进行多任务培训。&lt;/li&gt;
  &lt;li&gt;teacher.py:用于使用固定聊天日志进行对话的基本教师类。&lt;/li&gt;
  &lt;li&gt;world.py:定义基本World class, DialogPartnerWorld作用于两个对话者、用于两个以上对话者的MultiA-gentDialogWorld以及可以包装所选环境的两个容器：BatchWorld用于批处理培训，HogwildWorld用于跨多个线程进行培训。&lt;/li&gt;
  &lt;li&gt;dict.py:建筑语言文字规范。&lt;/li&gt;
  &lt;li&gt;计算精确匹配、F1和排名指标以供评估&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tasks&quot;&gt;tasks&lt;/h3&gt;
&lt;p&gt;任务分为五类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;问答（QA）：一种简单的对话形式，每个演讲者只需转一圈。任何智能对话代理都应该能够回答问题，并且可以构建许多种类的问题（以及数据集），从而提供一组非常重要的测试。问题回答特别有用，因为如果数据集用QA对标记，并且问题大多是明确的，那么求值比其他形式的对话更简单。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;句子完成（完形填空测试）Sentence Completion (Cloze Tests)：代理必须在对话的下一句话中填写缺失的单词。同样，这是一个特殊的对话框任务，但它的优点是数据集制作成本低，评估简单，这就是为什么社区已经构建了几个这样的数据集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向目标的对话Goal-Oriented Dialog：更现实的任务类别是在对话结束时有一个目标要实现。例如，一个顾客和一个旅行社讨论一个航班，一个演讲者推荐另一个要看的电影，等等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;闲聊Chit-Chat：对话任务，其中可能没有明确的目标，但更多的是讨论-例如两个发言者讨论体育、电影或共同兴趣。&lt;/li&gt;
  &lt;li&gt;视觉对话Visual Dialog：对话通常是建立在世界上的物理对象上的，所以我们也把对话任务包括图像和文本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在ParlAI中选择任务很容易在命令行上执行，如图4中的数据集显示实用程序所示。如果数据集以前没有使用过，ParlAI将自动下载它。因为所有数据集在ParlAI中都是以相同的方式处理的（使用一个对话框API，参见。5） ，一个模拟代理可以在任何一个代理之间切换培训和测试。重要的是，您可以通过提供一个逗号分隔的列表一次指定多个任务（多任务），例如命令行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t babi，squad&lt;/code&gt;，来同时使用这两个数据集，甚至所有的QA数据集（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t #qa&lt;/code&gt;），或者实际上一次在ParlAI中的每个任务（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t #all&lt;/code&gt;）。其目的是使构建和评估非常丰富的对话模型变得容易。
每个任务都包含在文件夹中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;build.py：用于设置任务数据的文件，包括首次请求时下载数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;agent.py：包含存在于任务世界中的教师类、代理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;world.py：为需要定义新/复杂环境的任务添加（可选）。要添加新任务，必须实现build.py&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载任何需要的数据，以及agent.py为了训练。
如果数据由固定的日志/对话框脚本组成，比如在许多受监控的数据集中（如SQuAD、Ubuntu等），则需要编写非常简单的代码。对于需要定义交互环境的更复杂的设置，可以实现新的world和/teacher&lt;/p&gt;

&lt;h3 id=&quot;mechanical-turk&quot;&gt;Mechanical Turk&lt;/h3&gt;
&lt;p&gt;ParlAI的一个重要部分是与Mechanical Turk无缝集成，用于数据收集、培训或评估。在ParlAI中，Human Turkers也被视为代理，因此Human-Human、Human bot或multiple Human和bot都可以在标准框架内进行对话，根据需要切换角色，而不会对代理进行代码更改。这是因为Turkers也通过相同的接口接收和发送：使用观察/动作指令的字段。我们在第一个版本中提供了两个示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（i）qa_collector：一个代理，它与Turkers对话，以收集给定上下文段落的问题-答案对，以构建qa数据集，见图2。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（ii）model_evaluator模型评估器：收集Turkers对机器人在给定任务中的性能的评级的代理。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行newMTurk任务需要实现运行主文件（比如运行.py)并为您希望人类对话的世界和代理定义几个特定于任务的参数。对于数据收集任务，代理应提出问题，并向Turker询问问题的答案，如图2所示。其他参数包括任务描述、突厥者在任务中的角色、描述任务的关键字、点击次数和突厥者的奖励。你可以在沙箱模式下运行，然后启动真正的任务，在那里Turker是付费的。对于在线培训或评估，Turker可以与您的机器学习代理交谈，例如LSTM、内存网络或其他实现的技术。新任务可以签入到存储库中，这样研究人员就可以共享数据收集和数据评估过程，并重现实验。&lt;/p&gt;

&lt;h2 id=&quot;实验说明&quot;&gt;实验说明&lt;/h2&gt;

&lt;p&gt;为了证明ParlAI在行动中的作用，我们在表1中给出了DrQA的结果，这是一个专注的LSTM架构，在班和bAbI任务上进行了单任务和多任务训练，据我们所知，这是以前没有用任何方法展示过的组合。这个实验同时显示了&lt;/p&gt;

&lt;p&gt;ParlAI的力量——建立这个实验是多么容易——以及目前方法的局限性。几乎所有在班上工作得很好的方法都被设计成从给定的上下文中预测一个短语（它们在训练中被指定为开始和结束索引）。因此，这些模型不能应用于所有对话数据集，例如，一些bAbI任务包括是/否问题，其中“是”和“否”不会出现在上下文中。这说明研究人员不应该把模型集中在单个数据集上。ParlAI不提供开始和结束标签索引，因为它的API只是对话框，见图5。这是一个经过深思熟虑的选择，可以阻止这种数据集过度拟合/专门化。然而，这也会导致性能略有下降，因为提供的信息较少5（66.4 EM vs.69.5 EM，见（Chen et al.，2017），这仍然在许多现有的良好表现方法的范围内，见https://stanford-qa.com). 总体而言，DrQA可以解决一些&lt;/p&gt;

&lt;p&gt;bAbI在班上任务和表现良好，与bAbI上的最佳表现方法不匹配（Seo et al.，2016；Henaff et al.，2016），多任务也无济于事。因此，ParlAI向社区提出了一个挑战，即寻找普遍适用的学习算法，并从许多对话数据集的培训中获益。&lt;/p&gt;

&lt;p&gt;5因为我们现在不知道真正答案的位置，&lt;/p&gt;

&lt;p&gt;我们随机选取匹配给定训练集答案的任何上下文短语的开始和结束索引，在某些情况下这是唯一的。&lt;/p&gt;

&lt;h1 id=&quot;response-quality-in-human-chatbot-collaborative-systems&quot;&gt;Response Quality in Human-Chatbot Collaborative Systems&lt;/h1&gt;
&lt;p&gt;Jiepu jiang&lt;/p&gt;

&lt;h1 id=&quot;相关综述&quot;&gt;相关综述&lt;/h1&gt;
&lt;p&gt;https://arxiv.org/pdf/2006.12442.pdf
Facebook AI主管人 Stephen Roller 做这个github https://stephenroller.com/ 虽然不是ParAI的一作，但是还是写了一些综述提到 ParAI和相关研究的&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/12/25/ParlAI%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/25/ParlAI%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</guid>
        
        <category>Python</category>
        
        <category>Chatbot</category>
        
        <category>paper-reading</category>
        
        
      </item>
    
      <item>
        <title> Spring 全家桶笔记05 SpringCloud 和 Cloud Native 概述 服务注册和发现 </title>
        <description>&lt;h1 id=&quot;chapter-11-springcloud-和-cloud-native-概述&quot;&gt;Chapter 11 SpringCloud 和 Cloud Native 概述&lt;/h1&gt;

&lt;h2 id=&quot;简单理解微服务&quot;&gt;简单理解微服务&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;“微服务就是⼀一些协同⼯工作的⼩小⽽而⾃自治的服务。”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;微服务的优点&quot;&gt;微服务的优点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;异构性
    &lt;ul&gt;
      &lt;li&gt;语⾔、存储……&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;弹性
    &lt;ul&gt;
      &lt;li&gt;一个组件不可用，不会导致级联故障&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;扩展
    &lt;ul&gt;
      &lt;li&gt;单体服务不易扩展，多个较⼩的服务可以按需扩展&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;易于部署&lt;/li&gt;
  &lt;li&gt;与组织结构对⻬&lt;/li&gt;
  &lt;li&gt;可组合性&lt;/li&gt;
  &lt;li&gt;可替代性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如和理解-cloud-native&quot;&gt;如和理解 Cloud Native&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;“云原⽣生技术有利利于各组织在公有云、私有云和混合云等新型动态环 境中，构建和运⾏行行可弹性扩展的应⽤用。”
    &lt;h2 id=&quot;12-factor-app&quot;&gt;12-Factor App&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目的 :为构建 SaaS 应⽤用提供⾏之有效的⽅法论 适⽤于任意语⾔和后端服务的开发的应用程序
https://12factor.net/zh_cn/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;基准代码(Codebase)
    &lt;ul&gt;
      &lt;li&gt;⼀份基准代码，多份部署&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;依赖(Dependencies)
    &lt;ul&gt;
      &lt;li&gt;显式声明依赖关系&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置(Config)
    &lt;ul&gt;
      &lt;li&gt;在环境中存储配置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后端服务(Backing services)
    &lt;ul&gt;
      &lt;li&gt;把后端服务当作附加资源&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;构建，发布，运⾏(Build, release, run)
    &lt;ul&gt;
      &lt;li&gt;严格分离构建和运⾏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;进程(Processes)
    &lt;ul&gt;
      &lt;li&gt;以一个或多个⽆状态进程运行应用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;端口绑定(Port Binding)
    &lt;ul&gt;
      &lt;li&gt;通过端⼝绑定提供服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;并发(Concurrency)
    &lt;ul&gt;
      &lt;li&gt;通过进程模型进行扩展&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;易处理(Disposability)
    &lt;ul&gt;
      &lt;li&gt;快速启动和优雅终止可最大化健壮性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开发环境与线上环境等价(Dev / Prod parity)
    &lt;ul&gt;
      &lt;li&gt;尽可能的保持开发，预发布，线上环境相同&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;日志(Logs)
    &lt;ul&gt;
      &lt;li&gt;把日志当作事件流&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;管理进程(Admin processes)
    &lt;ul&gt;
      &lt;li&gt;后台管理任务当作一次性进程运⾏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一份基准代码，多份部署
使用版本控制系统加以管理
基准代码与应用保持⼀一对应的关系
尽管每个应⽤用只对应⼀份基准代码，但可以同时存在多份部署&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显式声明依赖关系
12-Factor 的应用程序不会隐式依赖系统级的类库 它⼀定通过依赖清单，确切地声明所有依赖项
在运⾏过程中，通过依赖隔离⼯具来确保程序不会调用系统中存
在但清单中未声明的依赖项&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;严格分离构建和运⾏
12-Facfor 应⽤严格区分构建、发布、运行三个步骤
部署⼯具通常都提供了发布管理⼯具
每⼀个发布版本必须对应一个唯⼀的发布 ID&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以⼀个或多个无状态进程运行应用
12-Factor 应⽤的进程必须⽆状态且⽆共享 
任何需要持久化的数据都要存储在后端服务内&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速启动和优雅终⽌止可最⼤化健壮性
进程应当追求最小启动时间
进程⼀旦接收终止信号就会优雅的终止
进程应当在面对突然死亡时保持健壮&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能的保持开发，预发布，线上环境相同
想要做到持续部署就必须缩⼩本地与线上差异
后端服务是保持开发与线上等价的重要部分
应该反对在不同环境间使⽤不同的后端服务&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;spring-cloud-的主要功能&quot;&gt;Spring Cloud 的主要功能&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;服务发现 zookeeper等&lt;/li&gt;
  &lt;li&gt;服务熔断&lt;/li&gt;
  &lt;li&gt;配置服务 git&lt;/li&gt;
  &lt;li&gt;服务安全 Auth&lt;/li&gt;
  &lt;li&gt;服务⽹网关&lt;/li&gt;
  &lt;li&gt;分布式消息 rabbit MQ&lt;/li&gt;
  &lt;li&gt;分布式跟踪&lt;/li&gt;
  &lt;li&gt;各种云平台支持 google cloud engine ,azure 云&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-cloud-的版本号规则&quot;&gt;Spring Cloud 的版本号规则&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Cloud 是个⼤工程，其中包含多个独立项⽬&lt;/li&gt;
  &lt;li&gt;BOM - Release Train
    &lt;ul&gt;
      &lt;li&gt;London Tube Stations&lt;/li&gt;
      &lt;li&gt;字⺟序排列
        &lt;ul&gt;
          &lt;li&gt;Greenwich, Finchley, Edgware …&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SR - Service Release&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-12-服务注册和发现&quot;&gt;Chapter 12 服务注册和发现&lt;/h1&gt;

&lt;h2 id=&quot;使-eureka-作为服务注册中&quot;&gt;使⽤ Eureka 作为服务注册中⼼&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;什么是 Eureka
    &lt;ul&gt;
      &lt;li&gt;Eureka 是在 AWS 上定位服务的 REST 服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Netflix OSS
    &lt;ul&gt;
      &lt;li&gt;https://netflix.github.io&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring 对 Netflix 套件的支持
    &lt;ul&gt;
      &lt;li&gt;Spring Cloud Netflix&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;在本地启动一个简单的-eureka-服务&quot;&gt;在本地启动一个简单的 Eureka 服务&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Starter
    &lt;ul&gt;
      &lt;li&gt;spring-cloud-dependencies&lt;/li&gt;
      &lt;li&gt;spring-cloud-starter-netflix-eureka-starter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;声明
    &lt;ul&gt;
      &lt;li&gt;@EnableEurekaServer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注意事项
    &lt;ul&gt;
      &lt;li&gt;默认端口8761&lt;/li&gt;
      &lt;li&gt;Eureka ⾃己不要注册到 Eureka 了，在产线上记得要部署Eureka集群，不要在单机使用@EnableEurekaServer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;将服务注册到-eureka-server&quot;&gt;将服务注册到 Eureka Server&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Starter
    &lt;ul&gt;
      &lt;li&gt;spring-cloud-starter-netflix-eureka-client&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;声明
    &lt;ul&gt;
      &lt;li&gt;@EnableDiscoveryClient&lt;/li&gt;
      &lt;li&gt;@EnableEurekaClient
两个注解作用等价&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些配置项
    &lt;ul&gt;
      &lt;li&gt;eureka.client.service-url.default-zone&lt;/li&gt;
      &lt;li&gt;eureka.client.instance.prefer-ip-address&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关于-bootstrap-属性&quot;&gt;关于 Bootstrap 属性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bootstrap 属性
    &lt;ul&gt;
      &lt;li&gt;启动引导阶段加载的属性&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;bootstrap.properties&lt;/td&gt;
              &lt;td&gt;.yml&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;spring.cloud.bootstrap.name=bootstrap&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用配置
    &lt;ul&gt;
      &lt;li&gt;spring.application.name=应⽤用名&lt;/li&gt;
      &lt;li&gt;配置中⼼心相关&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例&quot;&gt;案例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;服务端 server pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;properties&amp;gt;
&amp;lt;spring-cloud.version&amp;gt;Greenwich.SR1&amp;lt;/spring-cloud.version&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
      &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;服务端 server application.properties中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;server.port=8761

eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;服务端 server 主函数文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;package geektime.spring.cloud.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}

}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;client 中 pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
    &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
    &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;client 主函数中加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableDiscoveryClient&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;client application.properties上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server.port=0&lt;/code&gt;随机指定一个端口
&lt;strong&gt;例子启动在jdk8上面，jdk11有依赖缺失的问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;不建议在不是AWS的情况下去启动Eureka&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;使-spring-cloud-loadbalancer-访问服务&quot;&gt;使⽤ Spring Cloud LoadBalancer 访问服务&lt;/h2&gt;

&lt;p&gt;就是在使用Eureka的情况下对服务进行的发现&lt;/p&gt;
&lt;h3 id=&quot;如何获得服务地址&quot;&gt;如何获得服务地址&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;EurekaClient
    &lt;ul&gt;
      &lt;li&gt;getNextServerFromEureka()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DiscoveryClient &lt;strong&gt;推荐使用&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;getInstances()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动了Eurekaserver端的代码之后显示
&lt;img src=&quot;/img/java-spring/chapter12-Eureka.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;load-balancer-client&quot;&gt;Load Balancer Client&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RestTemplate 与 WebClient
    &lt;ul&gt;
      &lt;li&gt;@LoadBalaced&lt;/li&gt;
      &lt;li&gt;实际是通过 ClientHttpRequestInterceptor 实现的
        &lt;ul&gt;
          &lt;li&gt;LoadBalancerInterceptor&lt;/li&gt;
          &lt;li&gt;LoadBalancerClient
            &lt;ul&gt;
              &lt;li&gt;RibbonLoadBalancerClient&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;了解ribbon-ribbon-customer-service&quot;&gt;了解Ribbon ribbon-customer-service&lt;/h3&gt;
&lt;p&gt;需要同时打开Eureka server 和 client&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;bootstrap.properties文件中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.application.name=customer-service
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在主函数上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableDiscoveryClient&lt;/code&gt;，并且在restTempate 上加上了LoadBalance注解&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@LoadBalanced
@Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
  return builder
      .setConnectTimeout(Duration.ofMillis(100))
      .setReadTimeout(Duration.ofMillis(500))
      .requestFactory(this::requestFactory)
      .build();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在CustomerRunner上定义了DiscoverClient的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private void showServiceInstances() {
  log.info(&quot;DiscoveryClient: {}&quot;, discoveryClient.getClass().getName());
  discoveryClient.getInstances(&quot;waiter-service&quot;).forEach(s -&amp;gt; {
      log.info(&quot;Host: {}, Port: {}&quot;, s.getHost(), s.getPort());
  });
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;以fegin做为服务注册中心发现服务&quot;&gt;以Fegin做为服务注册中心发现服务&lt;/h2&gt;

&lt;h3 id=&quot;认识-feign&quot;&gt;认识 Feign&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Feign
    &lt;ul&gt;
      &lt;li&gt;声明式 REST Web 服务客户端&lt;/li&gt;
      &lt;li&gt;https://github.com/OpenFeign/feign&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Cloud OpenFeign
    &lt;ul&gt;
      &lt;li&gt;spring-cloud-starter-openfeign&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;feign-的简单使&quot;&gt;Feign 的简单使⽤&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;开启 Feign ⽀支持
    &lt;ul&gt;
      &lt;li&gt;@EnableFeignClients&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定义 Feign 接⼝
    &lt;ul&gt;
      &lt;li&gt;@FeignClient&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;简单配置
    &lt;ul&gt;
      &lt;li&gt;FeignClientsConfiguration&lt;/li&gt;
      &lt;li&gt;Encoder / Decoder / Logger / Contract / Client …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;feign-的一些其他配置&quot;&gt;Feign 的⼀一些其他配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;feign.okhttp.enabled=true&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;feign.httpclient.enabled=true&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;feign.compression.response.enabled=true&lt;/li&gt;
  &lt;li&gt;feign.compression.request.enabled=true  对请求和响应压缩&lt;/li&gt;
  &lt;li&gt;feign.compression.request.mime-types=
         text/xml,application/xml,application/json&lt;/li&gt;
  &lt;li&gt;feign.compression.request.min-request-size=2048&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-1&quot;&gt;案例&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;feign-httpclient&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;bootstrap.properties中定义名字是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.application.name=customer-service&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;appliction.properties中显示的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server.port=0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;integeration 接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;coffeeOrderService&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import geektime.spring.springbucks.customer.model.CoffeeOrder;
import geektime.spring.springbucks.customer.model.NewOrderRequest;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = &quot;waiter-service&quot;, contextId = &quot;coffeeOrder&quot;)
public interface CoffeeOrderService {
    @GetMapping(&quot;/order/{id}&quot;)
    CoffeeOrder getOrder(@PathVariable(&quot;id&quot;) Long id);

    @PostMapping(path = &quot;/order/&quot;, consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    CoffeeOrder create(@RequestBody NewOrderRequest newOrder);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;coffeeService&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import geektime.spring.springbucks.customer.model.Coffee;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

@FeignClient(name = &quot;waiter-service&quot;, contextId = &quot;coffee&quot;, path = &quot;/coffee&quot;)
// 不要在接口上加@RequestMapping
public interface CoffeeService {
    @GetMapping(path = &quot;/&quot;, params = &quot;!name&quot;)
    List&amp;lt;Coffee&amp;gt; getAll();

    @GetMapping(&quot;/{id}&quot;)
    Coffee getById(@PathVariable Long id);

    @GetMapping(path = &quot;/&quot;, params = &quot;name&quot;)
    Coffee getByName(@RequestParam String name);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;不要写@RequestMapping注解而是直接写在路径上&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;里面的作用名解析两个都要去找waiter-serivce上面的服务，通过contextId来区分&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有了Fegin 的支持之后 CustomerRunner上的内容清爽很多， 不需要再写restTemplate&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在main函数上&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@EnableDiscoveryClient
@EnableFeignClients
...
@Bean
public CloseableHttpClient httpClient() {
  return HttpClients.custom()
      .setConnectionTimeToLive(30, TimeUnit.SECONDS)
      .evictIdleConnections(30, TimeUnit.SECONDS)
      .setMaxConnTotal(200)
      .setMaxConnPerRoute(20)
      .disableAutomaticRetries()//禁用自动重试
      .setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())//使用自定义的KeepAlive策略
      .build();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 18 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/12/18/Spring05/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/18/Spring05/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>Spring Cloud</category>
        
        <category>Cloud Native</category>
        
        <category>Fegin</category>
        
        <category>Zookeeper</category>
        
        <category>Consul</category>
        
        <category>Springbucks</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> jvm </title>
        <description>&lt;h1 id=&quot;chapter-1--什么是jvm&quot;&gt;Chapter 1  什么是JVM&lt;/h1&gt;
&lt;h2 id=&quot;定义-java-visual-machine&quot;&gt;定义 java visual machine&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ol&gt;
      &lt;li&gt;一次编写到处运行&lt;/li&gt;
      &lt;li&gt;自动内存管理，垃圾回收&lt;/li&gt;
      &lt;li&gt;数组下标越界自动检查&lt;/li&gt;
      &lt;li&gt;多态&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;学习jvm有什么用&quot;&gt;学习JVM有什么用&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;面试&lt;/li&gt;
  &lt;li&gt;理解底层原理&lt;/li&gt;
  &lt;li&gt;中高级的必备技能 项目上线之后会有内存溢出等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常见-jvm&quot;&gt;常见 JVM&lt;/h2&gt;
&lt;p&gt;hot spot&lt;/p&gt;

&lt;h2 id=&quot;jvm-学习路线&quot;&gt;JVM 学习路线&lt;/h2&gt;
&lt;p&gt;java class -&amp;gt; java classLoader &amp;lt;–&amp;gt;  (方法区 -&amp;gt; 堆 -&amp;gt; 虚拟机栈 -&amp;gt; 程序计数器 -&amp;gt; 本地方法栈) &amp;lt;–&amp;gt; 执行引擎(解释器 -&amp;gt; 即时编译器 -&amp;gt; GC 垃圾回收)&lt;/p&gt;

&lt;p&gt;学习顺序是1. 内存结构 2. 垃圾回收 3. java class 4. java classLoader 5. 即时编译器&lt;/p&gt;

&lt;h1 id=&quot;chapter2-内存结构&quot;&gt;Chapter2 内存结构&lt;/h1&gt;
&lt;h3 id=&quot;程序计数器--program-counter-register&quot;&gt;程序计数器 ： Program Counter Register&lt;/h3&gt;

&lt;h3 id=&quot;执行顺序&quot;&gt;执行顺序：&lt;/h3&gt;
&lt;p&gt;方法区 -&amp;gt; 堆 -&amp;gt; 虚拟机栈 -&amp;gt;  -&amp;gt; 本地方法栈&lt;/p&gt;

&lt;h3 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;作用
记住下一条jvm指令执行地址，利用寄存器来实现。&lt;/li&gt;
  &lt;li&gt;特点 ：线程私有&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;虚拟机栈&quot;&gt;虚拟机栈&lt;/h3&gt;
&lt;p&gt;类似于子弹夹，每个线程运行时的内存空间，栈由栈帧组成，一个栈帧对应一个方法的调用（参数，局部变量，返回地址）方法执行完就会释放栈帧，如果方法嵌套调用就会逐步释放但是都在一个栈内。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;定义 java virtual machine stacks
    &lt;ul&gt;
      &lt;li&gt;么个线程运行时所需要的内容称为虚拟机栈&lt;/li&gt;
      &lt;li&gt;每个栈由多个栈帧组成（frame），对应每次方法调用时所占的内存&lt;/li&gt;
      &lt;li&gt;每个线程只能有一个活动的栈帧，对应当前正在执行的方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;问题辨析
    &lt;ul&gt;
      &lt;li&gt;垃圾回收是否涉及栈内存？
不会，垃圾回收只回收堆内存中的对象。&lt;/li&gt;
      &lt;li&gt;栈内存分配越大越好吗？
栈内存可以根据运行指令指定大小，默认 都是1024KB  -Xss，栈内存越大，线程能运行的数目越少。&lt;/li&gt;
      &lt;li&gt;方法内的局部变量是否是线程安全的？
多个线程是共享还是私有的，栈内的是私有的所以没问题，但是如果是static来描述就会产生线程安全问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;栈线程安全问题
分为三个场景，如果不是局部变量，或者逃离了作用范围（作为返回值，或者作为参数传入），就会产生线程安全问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;栈的内存溢出（stackOverflowError）
    &lt;ul&gt;
      &lt;li&gt;栈帧过多：一直入栈没有出栈，方法的递归调用，没有设置正确的&lt;/li&gt;
      &lt;li&gt;栈帧过多：不容易出现
案例：json数据转换会产生无线递归，两个类中循环引用 @JsonIgnore就不会出现。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程运行诊断&quot;&gt;线程运行诊断&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;案例1 cpu占用过多，怎样定位
    &lt;ul&gt;
      &lt;li&gt;top 看哪个进程对cpu占用&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -o pid,gid,%cpu | grep 进程号&lt;/code&gt; ps命令进一步定位是哪个线程引起的cpu占用, -o表示按照 pid 进程id gid 和 cpu利用率来显示所有内容， grep表示筛选进程。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jstack 进程号&lt;/code&gt;显示所有java中的线程，线程编号是二进制。可以根据线程id找到问题线程 和 源码行数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;案例2 程序运行很长时间没有结果。多个线程是死锁。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;found one java-level deadlock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;本地方法栈&quot;&gt;本地方法栈&lt;/h3&gt;
&lt;p&gt;native method 用c或c++来使用本地方法接口。方法很多，最典型的就是Object中的native来修饰的就是通过c实现的。&lt;/p&gt;

&lt;h3 id=&quot;堆heap&quot;&gt;堆Heap&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;通过new关键字创建对象都会使用堆内存&lt;/li&gt;
  &lt;li&gt;特点：线程共享，堆中的对象都需要考虑线程安全问题；垃圾回收机制。
&lt;strong&gt;虚拟机栈等都是局部私有的，而堆是共有的&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;堆内存溢出OutOfMemoryError
虚拟机参数-Xmx一般是4g没有被回收掉的但一直在增加就会产生这种问题。&lt;/li&gt;
  &lt;li&gt;堆内存诊断
    &lt;ul&gt;
      &lt;li&gt;jps:查看当前系统中有哪些java进程&lt;/li&gt;
      &lt;li&gt;jmap:查看内存占用情况，常使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmap -heap 进程号&lt;/code&gt;对需要内容查询。&lt;/li&gt;
      &lt;li&gt;jconsole：图形界面，多功能的检测工具，可以连续监测。jdk自带&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;案例 垃圾回收后，内存占用依然很高
 使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jvisualvm&lt;/code&gt; 注意 我的java的jvisual的地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/bin/jvisualvm&lt;/code&gt;
 其中的监视-&amp;gt;堆dump点击-&amp;gt;右侧的查找，找到其中占用最大的20个堆对象，可以看到哪些元素占用的空间大。
    &lt;h3 id=&quot;方法区&quot;&gt;方法区&lt;/h3&gt;
    &lt;p&gt;Method Area JVM 规范中对方法区的定义：所有JAVA虚拟机线程共享的一块区域，存储了类的结构相关信息，成员方法，构造方法，运行时常量池等。方法区是堆的一个组成部分。 方法区的永久代 运行池（1.6）之后的1.8版本中不再使用永久代这样的概念了，反而是使用本地内存作为方法区。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;方法区内存溢出
    &lt;ul&gt;
      &lt;li&gt;方法区内存溢出的现象，类加载器，加载类的字节码，类名和报名。1.8以后类加载器都是用的系统内存，所以在设置错误案例的时候需要给元空间设置内存参数-XX:MaxMetaspaceSize=8m，因为产生很多class&lt;/li&gt;
      &lt;li&gt;实际场景中spring框架等原始的包名cjlib动态 生成类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常量池constant pool：给指令查找符号。
包含的二进制字节码：类基本信息，常量池，类方法定义，包含了虚拟机指令
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javap -v&lt;/code&gt;反编译获取静态变量就是去常量池中找到对应的类型方法。&lt;/li&gt;
  &lt;li&gt;运行时常量池：常量池是*.class文件中的，当该类被加载，它的常量池信息就会放在运行时常量池中，里面的符号地址变为真正的地址。
    &lt;h3 id=&quot;stringtable&quot;&gt;StringTable：&lt;/h3&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String s1=&quot;a&quot;;&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String s2=&quot;b&quot;;&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String s3=&quot;ab&quot;;&lt;/code&gt;
常量池存在于字节码中，运行时常量池写入常量池中的内容，这只a b ab 都只是常量池中的符号，还没有变为java对象。
StringTable[“a”,”b”,”ab”]hash table 对象，不能扩容。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;lbc  #2 会把符号变为”a”字符串对象，用hash表示长度等&lt;/li&gt;
      &lt;li&gt;lbc  #3 会把符号变为”b”字符串对象，用hash表示长度等&lt;/li&gt;
      &lt;li&gt;lbc  #4 会把符号变为”ab”字符串对象，用hash表示长度等&lt;/li&gt;
      &lt;li&gt;问题1:是在以上的代码中加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String s4 = s1+s2;&lt;/code&gt;反编译这个代码 运行顺序1）new StringBuilder 2)初始化方法 3）new  StringBuilder.append(“a”).append(“b”).toString()将StringBuilder中创建内容写入新的对象中。
请问s3==s4? &lt;strong&gt;不一样，s3是写在StringTable中的，而s4是新创建的堆中的对象&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;问题2：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String s5 = &quot;a&quot; + &quot;b&quot;&lt;/code&gt;
查看字节码会看到先去常量池中找到已经拼接好的StringTable中的内容不会创建新的对象，所以是s3==s5。javac编译器的优化，结果在编译期间已经可以确定了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stringtable特性
    &lt;ul&gt;
      &lt;li&gt;常量池中的字符串仅是符号，第一次用到时才会变为对象&lt;/li&gt;
      &lt;li&gt;利用StringTable的机制来避免重复创建字符串&lt;/li&gt;
      &lt;li&gt;字符串变量拼接的原理是StringBuilder1.8&lt;/li&gt;
      &lt;li&gt;字符串常量拼接的原来是编译器优化&lt;/li&gt;
      &lt;li&gt;可以是用intern方法，主动将StringTable中还没有的字符串放入
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);&lt;/code&gt; 这里的s所代表的的ab并没有放入StringTable中，此时的StringTable里面的内容就是[“a”,”b”]因为他代表的是堆中存放的内容。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s.intern(); &lt;/code&gt;就会把没有放到StringTable中的“ab”写入。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;StringTable 面试题
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;String s1 = &quot;a&quot;;
String s2 = &quot;b&quot;;
String s3 = &quot;a&quot;+&quot;b&quot;;//ab
String s4 = s1 + s2;// new String(&quot;ab&quot;)
String s5 = &quot;ab&quot;;
String s6 = s4.intern();

s3==s4; false
s3==s5; true
s3==s6; true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;StringTable 位置
1.6到1.8的优化StringTable的位置由永久代转移到堆中了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;StringTable垃圾回收
统计信息，StringTable类似于HashTable，如果需要存入StringTable一直在存，内存紧张，无用的字符串常量就会被回收。&lt;/li&gt;
  &lt;li&gt;StringTable的性能调优
本质是HashTable
    &lt;ul&gt;
      &lt;li&gt;案例：从外部读取一个文件，StringTable的桶信息其中桶大小和桶个数决定了耗费时间。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-XX:StringTableSize=桶个数&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;考虑将字符串对象是否入池，当应用里有大量字符串以及重复应用的时候可以使用intern()方法加入StringTable实现调优。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;直接内存directbuffer&quot;&gt;直接内存DirectBuffer&lt;/h3&gt;
&lt;p&gt;JVM 区没有直接内存区，是系统内存。
定义：常见于NIO区域，用于数据缓冲区，分配成本高，读写性能高。不需要从系统内存转换到java内存这一步。不受jvm内存回收管理&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;内存溢出&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List&amp;lt;ByteBuffer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
int i=0;
try{
  while(true){
    ByteBuffer bf = ByterBuffer.allocateDirect(1024*1024*100);
    list.add(bf);
    i++;
  }
}finally{
  System.out.println(i);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;直接内存溢出，底层的分配释放原理，在任务管理器中查看。&lt;/p&gt;

&lt;p&gt;unsafe类是必须通过反射方法拿到unsafe对象，分配内存&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe.allocateMemory(内存大小);&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe.setMemoey()&lt;/code&gt;搭配使用。直接内存释放是unsafe才能释放。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;byteBuffer源码分析，内存释放
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cleaner&lt;/code&gt;对象中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe.freeMemory&lt;/code&gt;
Cleaner对象，关联对象被回收时，会触发&lt;strong&gt;虚引用&lt;/strong&gt;对象的clean方法，在后台reference。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JVM 调优上的参数 -XX: DisableExplicitGC 禁用显式的垃圾回收，会影响直接内存的调优机制。比如在直接内存回收中使用这个调优参数就无法实现内存分配。
如何解决？可以直接用unsafe对象来手动释放。&lt;/p&gt;

&lt;h1 id=&quot;chapter3-垃圾回收&quot;&gt;Chapter3 垃圾回收&lt;/h1&gt;
&lt;h3 id=&quot;如何判断对象可以回收&quot;&gt;如何判断对象可以回收&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;引用计数法：当引用计数变为0就会被回收，弊端是循环引用问题。&lt;/li&gt;
  &lt;li&gt;可达性分析算法：确定一系列根对象，类似于葡萄根，扫描堆中的对象，看是否能验证GC Root对象 Memory Analyzer 专门的堆回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List&amp;lt;Object&amp;gt; list1 = ArrayList&amp;lt;&amp;gt;();
list1.add(&quot;a&quot;);
list1.add(&quot;b&quot;);

list1 = null;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;jmap搭配使用打印内存快照 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmap -dump:formate=b,live,file=1.bin 进程名&lt;/code&gt;，-dump:formate=b表示将这个快照转换为2进制存储，live表示存为快照之后进行垃圾回收,file=1.bin表示保存文件名。使用Memory Analyzer这个软件实现分析。垃圾不能回收的有Native Stack, System class, Thread, Busy monitor.&lt;/p&gt;
&lt;h4 id=&quot;四种引用面试&quot;&gt;四种引用（面试）&lt;/h4&gt;
&lt;p&gt;GC ROOT&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;强引用：只要沿着GC ROOT的引用链就不会被回收，只有在没有GC ROOT引用的时候就会断开&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软引用(softReference)：间接引用，在垃圾回收之后如果内存不足且就会回收，当引用对象被回收，软引用就会进入引用队列。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收的打印详细信息的参数-XX:+PrintGCDetails -verbose:gc&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;弱引用(weakReference)：没有强引用，发生垃圾回收不管内存够不够都会把弱引用回收。当引用对象被回收，弱引用就会进入引用队列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚引用(phantomReference)Cleaner直接内存地址（必须配合引用队列）：ByteBuffer+直接内存，会释放掉直接内存。在虚对象被回收就会调用unsafe.memory，并且将虚引用加入到引用队列中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;终结器引用(finalReference)（必须配合引用队列）：finalize()终结方法，当没有强引用时，虚拟机将终结器引用加入到引用队列，这个对象还没有被回收，优先级更低的线程将调用finalize()实现终结。&lt;strong&gt;效果不高，不推荐&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;软引用实例&quot;&gt;软引用实例&lt;/h4&gt;
&lt;p&gt;例子，如果直接引用较大的数组作为内存，可能会造成内存溢出。所以使用软引用list -&amp;gt; softreference-&amp;gt;byte[]&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List&amp;lt;SoftReference&amp;lt;byte[]&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
for (int i:10){
  SoftReference&amp;lt;byte[]&amp;gt; ref = new SoftReference&amp;lt;&amp;gt;(new byte[])
  list.add(ref);
  ...
} 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的结果显示在list中，在软引用最后不被引用之后还能保留最后一个软引用，问题就是怎样把之前已经置为null的软引用在list队列中删除，解决方案如下：
&lt;strong&gt;利用引用队列 在垃圾回收之后还会保留最后一个引用，可以将其删除&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceQueue&amp;lt;byte[]&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();&lt;/code&gt;
关联了软引用对象和引用队列
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SoftReference&amp;lt;byte[]&amp;gt; ref = new SoftReference&amp;lt;&amp;gt;(new byte[队列容纳参数]，queue);&lt;/code&gt;
当 软引用做关联到byte数组被回收时，软引用自己就会被加入到引用队列中去。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Refernece&amp;lt;? extends byte[]&amp;gt; poll = queue.poll()`
while (poll != null){
//当队列中的软引用为空，就remove掉存储在软引用队列中的对象
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;弱引用实例-解决强引用内存溢出&quot;&gt;弱引用实例 （解决强引用内存溢出）&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List &amp;lt;WeakReference&amp;lt;byte[]&amp;gt;&amp;gt; list= new ArrayList&amp;lt;&amp;gt;();
WeakReference&amp;lt;byte[]&amp;gt; ref = new WeakReference&amp;lt;&amp;gt;(new byte[弱引用大小]);
list.add(ref);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;弱引用在垃圾回收时就会将对象回收。&lt;/p&gt;
&lt;h3 id=&quot;垃圾回收算法&quot;&gt;垃圾回收算法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;标记清除：GC root 表示哪些没有引用的对象，清除就是将需要清除的内存的起始标记放到空闲的队列中，下次要用的时候直接覆盖，而不是物理意义上的”删除”
&lt;strong&gt;优点：速度快，缺点：会产生内存碎片&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;标记整理：GC root 表示哪些没有被引用，第二步就是整理，避免标记清除的时候的内存碎片问题，使内存紧凑。
&lt;strong&gt;优点：没有内存碎片，缺点：移动内存，速度慢&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;复制：将内存区域划分成大小相等的两个区，一个区叫FROM有内存 另一个TO区为空，将有引用的FROM区中的内存复制到TO区中，TO没有产生碎片，清空FROM区，最后交换FROM TO 位置
&lt;strong&gt;优点：不会产生碎片，缺点：占用较大的内存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;分代垃圾回收机制&quot;&gt;分代垃圾回收机制&lt;/h3&gt;
&lt;p&gt;实际的虚拟机会使用以上的垃圾回收算法 
新生代：伊甸园 幸存区 FROM 幸存区 TO
老年代：
居民楼中的垃圾：隔多久收垃圾 ，不会整个内存扫描，新生代相当于垃圾箱，是产生比较频繁的垃圾，老年代是执行频率较低的垃圾，等到整个内存不足时才会清理老年代。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一次垃圾回收minor gc：伊甸园是第一个被使用的空间，如果占满，新生代的垃圾回收minor GC。将内存进行一次复制垃圾回收，伊甸园清理。&lt;/li&gt;
  &lt;li&gt;第二次垃圾回收 minor gc，伊甸园中内存清理，幸存区每次垃圾回收都会计数，如果在FROM区有超过15次垃圾回收，就会转到老年代区。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Full GC当老年代空间不足，就会清理老年代和新生代。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;要点
    &lt;ol&gt;
      &lt;li&gt;对象首先分配在伊甸园区&lt;/li&gt;
      &lt;li&gt;新生代空间不足时，触发minor GC，伊甸园和FROM存活的对象使用cpoy复制到TO区，存活的对象和年龄加1，并且交换FROM TO&lt;/li&gt;
      &lt;li&gt;minor GC 会引发 STOP THE WORLD 其他用户的线程会暂停，因为对象地址会改变，等垃圾回收结束，用户线程才会恢复。&lt;/li&gt;
      &lt;li&gt;当对象寿命超过阈值，会晋升至老年代，最大寿命是15(4bit)&lt;/li&gt;
      &lt;li&gt;当老年代空间不足，会现场时触发minor GC 如果之后仍空间不足，那么触发Full GC， stop the world的时间会比较长。&lt;/li&gt;
      &lt;li&gt;如果此时还是空间不足就会触发outOfSpaceError&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;相关的VM 参数&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;含义&lt;/td&gt;
      &lt;td&gt;参数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;堆初始大小&lt;/td&gt;
      &lt;td&gt;-Xms&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;堆最大大小&lt;/td&gt;
      &lt;td&gt;-Xmx或-XX:MaxHeapSize=size&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;新生代大小&lt;/td&gt;
      &lt;td&gt;-Xmn或 -XX:NewSize=size+ -XX:MaxNewSize=size&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;幸存区比例（动态）&lt;/td&gt;
      &lt;td&gt;-XX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;幸存区比例&lt;/td&gt;
      &lt;td&gt;-XX:SurvivorRatio=ratio 默认为8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;晋升阈值&lt;/td&gt;
      &lt;td&gt;-XX:MaxTenuringThreshold=treshold&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;晋升详情&lt;/td&gt;
      &lt;td&gt;-XX:PrintTenuringDistributution&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GC详情&lt;/td&gt;
      &lt;td&gt;-XX:+PrintGCDetails -verbose:gc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Full GC 前 Minor GC&lt;/td&gt;
      &lt;td&gt;-XX:ScavengeBeforeFullGC&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在FullGC之前是不是要开Minor gc&lt;/p&gt;

&lt;h4 id=&quot;垃圾回收案例&quot;&gt;垃圾回收案例&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//分配内存
private static final int _512KB = 512* 1024;
private static final int _7M = 7 * 1024 * 1024;
...

// 堆空间20兆-Xms20M 堆空间最大20兆-Xmx20M 新生代10兆-Xmn10M 幸存区比例不会动态调整-XX:+UseSerial1GC 打印GC详情 -XX:+PrintGCDetails -verbose:gc
public static void main(String[] args){
  ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  // 第一次是放了7兆会产生一次垃圾回收
  list.add(new byte[_7M]);
  // 触发第二次垃圾回收，因为用了两个512k堆的总容量快占满，新生代快占满
  list.add(new byte[_512KB]); 
  list.add(new byte[_512KB]); 
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;案例2-大对象&quot;&gt;案例2 大对象&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private static final int _512KB = 512* 1024;
private static final int _8M = 8 * 1024 * 1024;

// 堆空间20兆-Xms20M 堆空间最大20兆-Xmx20M 新生代10兆-Xmn10M 幸存区比例不会动态调整-XX:+UseSerial1GC 打印GC详情 -XX:+PrintGCDetails -verbose:gc
public static void main(String[] args){
  ArrayList&amp;lt;byte[]&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  list.add(new byte[_8M]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;当加入的对象对于新生代内存不足但是老年代有空间的情况下，直接存储到老年代，相当于晋升，不会有新生代GC。&lt;/li&gt;
  &lt;li&gt;当加入内容都会导致堆空间不足的内存溢出时之前还是会执行两种垃圾回收。&lt;/li&gt;
  &lt;li&gt;当内存溢出发生在子线程中，会不会导致主线程的结束？&lt;strong&gt;主线程不会结束&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;垃圾回收器&quot;&gt;垃圾回收器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;串行：单线程，堆内存较小，适合个人电脑。居民楼 楼层不高，一个保洁工人打扫卫生。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;吞吐量优先：多线程，堆内存较大，多核CPU。让单位时间内Stop the world 时间短。垃圾回收次数占比低。高楼层，多个保洁，多CPU就是多个扫帚&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;响应时间优先：多线程，堆内存较大，多核CPU。垃圾回收次数占比高。尽可能stop the world时间短&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;串行垃圾回收器&quot;&gt;串行垃圾回收器&lt;/h4&gt;
&lt;p&gt;-XX:+UseSerialGC = Serial + SerialOld&lt;/p&gt;

&lt;p&gt;Serial：复制算法，在新生代
SerialOld：标记整理算法，老年代&lt;/p&gt;

&lt;p&gt;CPU0 运行 =&amp;gt;安全点 =&amp;gt;阻塞 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU1 运行 =&amp;gt;安全点 =&amp;gt;阻塞 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU2 运行 =&amp;gt;安全点 =&amp;gt;垃圾回收线程 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU3 运行 =&amp;gt;安全点 =&amp;gt;阻塞 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;为什么在安全点暂停，因为地址在改变所以到安全点再改。&lt;/p&gt;

&lt;h4 id=&quot;吞吐量优先&quot;&gt;吞吐量优先&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;-XX:+UseParallelGC -XX:+UseParallelOldGC 默认开启，只要这两个有一个开启另一个也开启&lt;/li&gt;
  &lt;li&gt;-XX:+UseAdaptiveSizePolicy&lt;/li&gt;
  &lt;li&gt;-XX:GCTimeRatio=ratio&lt;/li&gt;
  &lt;li&gt;-XX:MaxGCPauseMillis=ms&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-XX:ParallelGCThreads=n&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;垃圾回收线程个数和线程数一样，cpu使用曲线是一下子到100%&lt;/li&gt;
  &lt;li&gt;UseAdaptiveSizePolicy采用的自适应新生代的大小动态调整伊甸园和幸存区大小&lt;/li&gt;
  &lt;li&gt;GCTimeRatio是尝试调整吞吐量目标垃圾回收时间和总时间占比1/(1+ratio)&lt;/li&gt;
  &lt;li&gt;MaxGCPauseMillis毫秒数，每次垃圾回收耗时&lt;/li&gt;
  &lt;li&gt;ParallelGCThreads可以设置线程数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;GCTimeRatio和MaxGCPauseMillis是对立的指标一般radio是19（1/20 = 0.05）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU0 运行 =&amp;gt;安全点 =&amp;gt;垃圾回收线程 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU1 运行 =&amp;gt;安全点 =&amp;gt;垃圾回收线程 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU2 运行 =&amp;gt;安全点 =&amp;gt;垃圾回收线程 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU3 运行 =&amp;gt;安全点 =&amp;gt;垃圾回收线程 =&amp;gt; 运行&lt;/p&gt;

&lt;h4 id=&quot;响应时间优先&quot;&gt;响应时间优先&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld&lt;/li&gt;
  &lt;li&gt;-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads 初始执行的并行线程数，并发线程数，建议设置为并行的四分之一（比如四个线程，保留一个做垃圾回收）&lt;/li&gt;
  &lt;li&gt;-XX:CMSInitingOccupancyFraction=percent 控制执行垃圾回收的内存占比，当内存占用到多少的时候就执行垃圾回收，是保证对浮动垃圾的清理。默认值65%&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-XX:CMSScavenegBeforeRemark 重新标记的时候新生代会引用老年代，对性能影响大，相当于在回收之前做了无用的查找，这个参数就是对新生代垃圾回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;UseConcMarkSweepGC 基于垃圾清除的回收器，并发，工作于老年代，UseParNewGC在新生代  SerialOld基于标记整理的老年代回收器。&lt;/li&gt;
  &lt;li&gt;CMS对CPU占用不高，用户工作线程会收影响，对整个应用程序吞吐量会有影响。
&lt;strong&gt;concurrent并发：垃圾回收执行，用户线程也执行&lt;/strong&gt;
&lt;strong&gt;parallel并行：垃圾回收期间，用户线程stoptheworld了&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老年代不足： 初始标记 -&amp;gt; 跟用户执行并发，重新标记时也要stop the world 用户线程又开始运行。
CPU0 运行 =&amp;gt; 安全点 =&amp;gt; 阻塞 =&amp;gt; 安全点 =&amp;gt;运行 =&amp;gt;安全点 =&amp;gt; 重新标记 =&amp;gt; 安全点 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU1 运行 =&amp;gt; 安全点 =&amp;gt; &lt;strong&gt;初始标记&lt;/strong&gt; =&amp;gt; 安全点 =&amp;gt; &lt;strong&gt;并发标记 =&amp;gt;安全点 =&amp;gt; 重新标记 =&amp;gt; 安全点 =&amp;gt; 并发清理 =&amp;gt; 运行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU2 运行 =&amp;gt; 安全点 =&amp;gt; 阻塞 =&amp;gt; 安全点 =&amp;gt;运行 =&amp;gt;安全点 =&amp;gt; 重新标记 =&amp;gt; 安全点 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;CPU3 运行 =&amp;gt; 安全点 =&amp;gt; 阻塞 =&amp;gt; 安全点 =&amp;gt;运行 =&amp;gt;安全点 =&amp;gt; 重新标记 =&amp;gt; 安全点 =&amp;gt; 运行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;碎片过多不能回收，导致并发失败，垃圾回收时间会增加。CMS回收问题&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;g1-垃圾回收器&quot;&gt;G1 垃圾回收器&lt;/h3&gt;

&lt;p&gt;Garbage First,JDK9开始使用这个回收器，CMS被替代了&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;重视吞吐量和低延迟，默认暂停的目标是200ms&lt;/li&gt;
  &lt;li&gt;超大内存，将堆划分为多个大小相等的Region&lt;/li&gt;
  &lt;li&gt;标记整理算法，两个区域之间是复制算法&lt;/li&gt;
  &lt;li&gt;相关JVM参数
-XX:+UseG1GC
-XX:G1HeapRegionSize=size
-XX:MaxGCPauseMillis=time
    &lt;h4 id=&quot;g1回收阶段&quot;&gt;G1回收阶段&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Young Collection &amp;lt;-&amp;gt; Mix Collection &amp;lt;-&amp;gt; Young Collection Concurrent Mark&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;young collection ： 伊甸园区 被占满&lt;/li&gt;
  &lt;li&gt;young collection + CM
    &lt;ul&gt;
      &lt;li&gt;在young GC 会进行GC Root&lt;/li&gt;
      &lt;li&gt;老年代，占用堆空间比例达到阈值，进行并发标记，不会STW 由-XX:InitiatingHeapOccupancyPercent=percent参数决定 默认为45%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;mixed Collection 
全面垃圾回收，老年代优先回收垃圾多的区。
    &lt;ul&gt;
      &lt;li&gt;最终标记Remark会STW&lt;/li&gt;
      &lt;li&gt;拷贝存活Evacuation 会STW&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Full GC
    &lt;ul&gt;
      &lt;li&gt;SerialGC
        &lt;ul&gt;
          &lt;li&gt;新生代内存不足minor gc&lt;/li&gt;
          &lt;li&gt;老年代内存不足 full gc&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ParallelGC
        &lt;ul&gt;
          &lt;li&gt;新生代内存不足minor gc&lt;/li&gt;
          &lt;li&gt;老年代内存不足 full gc&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CMS
        &lt;ul&gt;
          &lt;li&gt;新生代内存不足minor gc&lt;/li&gt;
          &lt;li&gt;老年代内存不足&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;G1
        &lt;ul&gt;
          &lt;li&gt;新生代内存不足minor gc&lt;/li&gt;
          &lt;li&gt;老年代内存不足 有阈值&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;垃圾回收调优&quot;&gt;垃圾回收调优&lt;/h3&gt;

&lt;h1 id=&quot;chapter-4-类加载和字节码技术&quot;&gt;Chapter 4 类加载和字节码技术&lt;/h1&gt;

&lt;h2 id=&quot;类文件结构&quot;&gt;类文件结构&lt;/h2&gt;
&lt;p&gt;编译期间每一个字节的含义 
类文件节后如下
&lt;img src=&quot;/img/jvm-classFile.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;魔数&quot;&gt;魔数&lt;/h3&gt;
&lt;p&gt;0-3字节 表示它是否是【class】类型文件ca fe ba be&lt;/p&gt;
&lt;h3 id=&quot;版本&quot;&gt;版本&lt;/h3&gt;
&lt;p&gt;4-7地接，表示类版本 00 34(翻译成10进制52表示java 8)&lt;/p&gt;

&lt;h3 id=&quot;常量池&quot;&gt;常量池&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jvm-constantPool.jpg&quot; alt=&quot;&quot; /&gt;
8-9 字节 表示常量池长度 00 23 (10进制翻译为35 表示常量池有#1~#34项 注意#0项不计入)
#1第一项0a需要查表表示第一个Method信息 0a &lt;strong&gt;00 06&lt;/strong&gt; &lt;strong&gt;00 15（21）&lt;/strong&gt; 表示引用常量池#6和#21项来获得【所属类】和【方法名】&lt;/p&gt;

&lt;p&gt;先是将16进制转10进制再去查找常量池的项，对照某项的数值去常量池表找对应含义。&lt;/p&gt;

&lt;h3 id=&quot;访问表示与继承信息&quot;&gt;访问表示与继承信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jvm-extends.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;field信息&quot;&gt;Field信息&lt;/h3&gt;
&lt;p&gt;用字节码表示
&lt;img src=&quot;/img/jvm-field.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;方法信息&quot;&gt;方法信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jvm-method.jpg&quot; alt=&quot;&quot; /&gt;
方法属性&lt;/p&gt;

&lt;h3 id=&quot;附加属性&quot;&gt;附加属性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jvm-attachAttr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;字节码指令&quot;&gt;字节码指令&lt;/h2&gt;
&lt;h3 id=&quot;入门&quot;&gt;入门&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;构造方法中的字节含义 2a b7 00 01 b1
    &lt;h3 id=&quot;finally&quot;&gt;finally&lt;/h3&gt;
    &lt;p&gt;如果在finally中写入return会吞掉异常&lt;/p&gt;
    &lt;h3 id=&quot;synchronized从字节码角度理解&quot;&gt;synchronized从字节码角度理解&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加锁成对出现 monitorenter 加锁monitorexit 解锁
如果出现异常就会将异常的引用被抛出，总会进入到暂存lock对象并进行解锁操作。&lt;/p&gt;

&lt;h2 id=&quot;编译器处理&quot;&gt;编译器处理&lt;/h2&gt;

&lt;h3 id=&quot;语法糖-默认构造&quot;&gt;语法糖 默认构造&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;java源码编译为class字节码文件 解释为伪代码
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public class C{}&lt;/code&gt;编译为class之后的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class C1{
  // 无参构造是编译器帮助我们加上的
  public C1(){
    super();// 调用父类OBject的无参构造方法，即调用java/lang.Object
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;语法糖-自动拆装箱&quot;&gt;语法糖 自动拆装箱&lt;/h3&gt;
&lt;p&gt;JDK5开始&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public static void main (String[] args){
  Integer x = Integer.valueOf(1);//Integer x = 1 装箱
  int y = x.intValue(); // int y = x拆箱
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译器帮助写入字节码&lt;/p&gt;

&lt;h3 id=&quot;语法糖-泛型集合&quot;&gt;语法糖 泛型集合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;泛型擦除
JDK5之后的特性：泛型信息在编译成字节码之后就会擦除掉&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(10);// 实际调用的是List.add(Object e)
Integer x = list.get(0);// 实际调用的是Object obj = List.get(int index);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;泛型反射
如果以上的integer转换为int就是
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int x = ((Integer)list.get(0)).intValue();&lt;/code&gt;。
有些字节码信息改变了，局部变量类型表，包含了泛型信息，泛型没有被擦除，不能使用反射拿到泛型信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;语法糖-可变参数&quot;&gt;语法糖 可变参数&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public static void foo(String... arge){
  String[] array = args;
}  
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可变参数 String… args 其实是一个String[] args 在java编译器上会显示为，根据实参数量创建，如果是无参，则会创建一个长度为0的形参。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public static void foo (String[] args){
  String[] args = args;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;语法糖-foreach&quot;&gt;语法糖 foreach&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;int[] array = {1,2,3};// 数组赋值的简化写法
for (int e: array){...}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译成&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;int[] array = new int[]{1,2,3};
for (int i=0;i&amp;lt;array.length;i+++){
  int e = array[i];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果要实现foreach一定要有迭代器！！！&lt;/p&gt;

&lt;h3 id=&quot;语法糖-switch-string&quot;&gt;语法糖 switch string&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;switch case   
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;… 还有各种语法糖就不一一写了&lt;/p&gt;

&lt;h3 id=&quot;语法糖-匿名内部类&quot;&gt;语法糖 匿名内部类&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Runnable runnable = new Runnable(){
  @Override
  public void run(){}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;转换后的代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;final class 外部类名$1 implemplents Runnable{
  public void run(){}
}
...
public class 内部类名{
  public static void main(String[] args){
    Runnable runnable = new 外部类名$1
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;引用局部变量的匿名内部类的语法糖&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;publc static void test(final int x){
  Runnable runnable = new Runnable(){
    @Override
    public void run(){
      ...
    }
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;转换之后的代码为&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 额外生成的类
final class 外部类名$1 implements Runnable{
  int val$x;
  构造方法 赋值属性
  public void run(){...}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;为什么匿名内部类局部变量一定是final的，因为在创建外部类名$1对象时将x的值赋值隔离外部类名$1对象的valx属性，所以x不能再发生变化，否则valx属性会跟着一起变。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;类加载阶段&quot;&gt;类加载阶段&lt;/h2&gt;

&lt;h3 id=&quot;加载&quot;&gt;加载&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jvm-classloader.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;验证 检查是否符合JVM规范，安全性检查&lt;/li&gt;
  &lt;li&gt;准备 为static变量分配空间 设置默认值 静态变量存储在堆中跟着类对象
    &lt;ul&gt;
      &lt;li&gt;分配空间在准备阶段和赋值在初始化阶段是两个步骤&lt;/li&gt;
      &lt;li&gt;赋值时在类的构造方法中&lt;/li&gt;
      &lt;li&gt;final类型静态变量赋值动作和String赋值不是在初始 化阶段而是在准备阶段的。&lt;/li&gt;
      &lt;li&gt;如果final但是属于引用类型也就是new了就是在初始化阶段完成&lt;/li&gt;
      &lt;li&gt;new 新变量是在初始化阶段完成的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解析:将常量池中的符号引用解析为直接引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Load2{
  public static void main (String[] args) throws Exception{
    ClassLoader cl = Load2.class.getClassLoader();
    // loadClass方法不会导致类的解析和初始化
    Class&amp;lt;?&amp;gt; c = cl.loadClass(&quot;C的全限定类名&quot;);
    ...
    // new C();
  }
}

class C{
  D d = new D();
}
class D{

}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;cinit&gt;&lt;/cinit&gt;&lt;/h3&gt;
&lt;p&gt;初始化就是调用&lt;cinit&gt;&lt;/cinit&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/jvm-classloaderInit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;chapter5-类加载器&quot;&gt;Chapter5 类加载器&lt;/h1&gt;
&lt;p&gt;以JDK8为例&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/jvm-classloaderMain.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只有在以上类都没有加载过的时候才会执行自定义的类加载器。&lt;/p&gt;

&lt;h2 id=&quot;启动类加载器-不能直接访问&quot;&gt;启动类加载器 不能直接访问&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Class F{
  static {...}
}
Class Load{
  public void main (){
    Class&amp;lt;?&amp;gt; aclass = Class.forname(&quot;F的全限定类名&quot;);
    aclass.getClassLoader();//打印类加载器
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;扩展类加载器&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 17 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/12/17/JAVA-jvm/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/17/JAVA-jvm/</guid>
        
        <category>Java</category>
        
        <category>JVM</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记04 重新认识SpringBoot 运行中的SpringBoot </title>
        <description>&lt;h1 id=&quot;chapter-8-重新认识springboot&quot;&gt;Chapter 8 重新认识SpringBoot&lt;/h1&gt;
&lt;p&gt;Spring boot 不是什么
不是应⽤用服务器
不是 Java EE 之类的规范 
不是代码⽣生成器
不是 Spring Framework 的升级版&lt;/p&gt;

&lt;h2 id=&quot;spring-boot-特性&quot;&gt;Spring Boot 特性&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;⽅便地创建可独⽴运行的 Spring 应⽤程序&lt;/li&gt;
  &lt;li&gt;直接内嵌 Tomcat、Jetty 或 Undertow&lt;/li&gt;
  &lt;li&gt;简化了项⽬的构建配置&lt;/li&gt;
  &lt;li&gt;为 Spring 及第三⽅库提供⾃动配置&lt;/li&gt;
  &lt;li&gt;提供⽣产级特性&lt;/li&gt;
  &lt;li&gt;无需⽣成代码或进⾏ XML 配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-boot-核心&quot;&gt;Spring Boot 核心&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;⾃动配置 - Auto Configuration&lt;/li&gt;
  &lt;li&gt;起步依赖 - Starter Dependency&lt;/li&gt;
  &lt;li&gt;命令行界⾯面 - Spring Boot CLI&lt;/li&gt;
  &lt;li&gt;Actuator&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;了解自动配置原理&quot;&gt;了解自动配置(原理)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;自动配置
    &lt;ul&gt;
      &lt;li&gt;基于添加的 JAR 依赖⾃自动对 Spring Boot 应⽤用程序进行配置&lt;/li&gt;
      &lt;li&gt;spring-boot-autoconfiguration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启⾃动配置
    &lt;ul&gt;
      &lt;li&gt;@EnableAutoConfiguration
        &lt;ul&gt;
          &lt;li&gt;exclude = Class&amp;lt;?&amp;gt;[] 指定排除哪些配置&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;@SpringBootApplication（默认带了@EnableAutoConfiguration）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自动配置实现原理&quot;&gt;自动配置实现原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;@EnableAutoConfiguration
    &lt;ul&gt;
      &lt;li&gt;AutoConfigurationImportSelector&lt;/li&gt;
      &lt;li&gt;META-INF/spring.factories
        &lt;ul&gt;
          &lt;li&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;了解自动配置的情况&quot;&gt;了解⾃自动配置的情况&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;观察⾃自动配置的判断结果
run configuration 里面 –debug&lt;/li&gt;
  &lt;li&gt;ConditionEvaluationReportLoggingListener
    &lt;ul&gt;
      &lt;li&gt;Positive matches&lt;/li&gt;
      &lt;li&gt;Negative matches&lt;/li&gt;
      &lt;li&gt;Exclusions&lt;/li&gt;
      &lt;li&gt;Unconditional classes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;手动实现自动配置&quot;&gt;手动实现自动配置&lt;/h2&gt;
&lt;h3 id=&quot;主要工作内容&quot;&gt;主要工作内容&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;编写 Java Config
    &lt;ul&gt;
      &lt;li&gt;@Configuration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;添加条件
    &lt;ul&gt;
      &lt;li&gt;定位⾃自动配置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@Conditional
    &lt;ul&gt;
      &lt;li&gt;META-INF/spring.factories&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;条件注解&quot;&gt;条件注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;条件注解
    &lt;ul&gt;
      &lt;li&gt;@Conditional &lt;strong&gt;在Spring 4中引入的在3中没有&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnClass 存在一个类时做什么&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingClass&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;属性条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnProperty 属性等于特定的值时应该做什么&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bean 条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnBean 存在某个Bean做什么&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingBean&lt;/li&gt;
      &lt;li&gt;@ConditionalOnSingleCandidate 上下文只有一个候选的Bean的时候应该做什么 如果是Primary也是满足这个条件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;资源条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnResource&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Web 应⽤用条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnWebApplication 如果是web应用满足什么条件&lt;/li&gt;
      &lt;li&gt;@ConditionalOnNotWebApplication&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnExpression&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJava&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJndi&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自动配置执行顺序&quot;&gt;自动配置执行顺序&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;自动配置的执⾏顺序
    &lt;ul&gt;
      &lt;li&gt;@AutoConfigureBefore&lt;/li&gt;
      &lt;li&gt;@AutoConfigureAfter&lt;/li&gt;
      &lt;li&gt;@AutoConfigureOrder&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;在需要引入自动配置的类下面引入两个写好的自动配置项，注意是applicationRunner格式不佳任何注解，防止生成Bean，详见69课&lt;/p&gt;

&lt;h2 id=&quot;springboot-提供的failureanalysis&quot;&gt;SpringBoot 提供的FailureAnalysis&lt;/h2&gt;
&lt;p&gt;位置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/Users/apple/.m2/repository/org/springframework/boot/spring-boot/2.1.4.RELEASE/spring-boot-2.1.4.RELEASE.jar!/org/springframework/boot/diagnostics/FailureAnalysis.class&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;private final String description; 失败描述&lt;/li&gt;
  &lt;li&gt;private final String action; 失败建议后续动作&lt;/li&gt;
  &lt;li&gt;private final Throwable cause; 失败异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何在低版本-spring-中快速实现类似自动配置的功能&quot;&gt;如何在低版本 Spring 中快速实现类似⾃自动配置的功能&lt;/h2&gt;

&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;3.x 的 Spring 没有条件注解&lt;/li&gt;
  &lt;li&gt;⽆法⾃动定位需要加载的⾃动配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;核解决思路&quot;&gt;核⼼解决思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;条件判断
    &lt;ul&gt;
      &lt;li&gt;通过 BeanFactoryPostProcessor 进⾏判断&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置加载
    &lt;ul&gt;
      &lt;li&gt;编写 Java Config 类&lt;/li&gt;
      &lt;li&gt;引入配置类
        &lt;ul&gt;
          &lt;li&gt;通过 component-scan&lt;/li&gt;
          &lt;li&gt;通过 XML ⽂件 import&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-的两个扩展点&quot;&gt;Spring 的两个扩展点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BeanPostProcessor
    &lt;ul&gt;
      &lt;li&gt;针对 Bean 实例例&lt;/li&gt;
      &lt;li&gt;在 Bean 创建后提供定制逻辑回调&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BeanFactoryPostProcessor
    &lt;ul&gt;
      &lt;li&gt;针对 Bean 定义&lt;/li&gt;
      &lt;li&gt;在容器创建 Bean 前获取配置元数据&lt;/li&gt;
      &lt;li&gt;Java Config 中需要定义为 static ⽅方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关于-bean-的一些定制&quot;&gt;关于 Bean 的一些定制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Lifecycle Callback
    &lt;ul&gt;
      &lt;li&gt;InitializingBean / @PostConstruct / init-method 初始化&lt;/li&gt;
      &lt;li&gt;DisposableBean / @PreDestroy / destroy-method bean销毁时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XxxAware 接⼝
    &lt;ul&gt;
      &lt;li&gt;ApplicationContextAware 注入ApplicationContext&lt;/li&gt;
      &lt;li&gt;BeanFactoryAware&lt;/li&gt;
      &lt;li&gt;BeanNameAware 注入Bean名字&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用操作&quot;&gt;常用操作&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;判断类是否存在
    &lt;ul&gt;
      &lt;li&gt;ClassUtils.isPresent()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;判断 Bean 是否已定义
    &lt;ul&gt;
      &lt;li&gt;ListableBeanFactory.containsBeanDefinition()&lt;/li&gt;
      &lt;li&gt;ListableBeanFactory.getBeanNamesForType()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注册 Bean 定义
    &lt;ul&gt;
      &lt;li&gt;BeanDefinitionRegistry.registerBeanDefinition()
        &lt;ul&gt;
          &lt;li&gt;GenericBeanDefinition&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BeanFactory.registerSingleton()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-9-使用lucene-和-elasticsearch-实现全文检索和分析&quot;&gt;chapter 9 使用Lucene 和 ElasticSearch 实现全文检索和分析&lt;/h1&gt;
&lt;p&gt;1、创建一个索引文件目录，然后把需要检索的信息 用Field 对应匹配的 封装成一个Document文档对象，将这个对象放入索引文件目录中，这里既可以将索引存放到磁盘中，也可以放入内存中，如果放入内存，那么程序关闭索引就没有了，所以一般都是将索引放入磁盘中；&lt;/p&gt;

&lt;p&gt;2、如果发现信息有问题需要删除，那么索引文件也要删除，否则检索的时候还是会查询得到，这个时候需要根据索引id去删除对应的索引；&lt;/p&gt;

&lt;p&gt;3、如果发现信息被更新了，那么索引文件也要更新，这个时候需要先将旧的索引删除然后添加新的索引；&lt;/p&gt;

&lt;p&gt;4、最后重头戏是全文搜索了，这和查询数据库一样，先需要创建索引读取对象，然后封装Query查询对象，调用search()方法 得到检索结果。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/supermao1013/article/details/83443611&quot; target=&quot;_blank&quot;&gt; lucene 在java中如何使用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用elasticsearch可视化内容&quot;&gt;使用ElasticSearch可视化内容&lt;/h2&gt;

&lt;p&gt;如何利用docker开启elasticSearch在本地的方法在Docker那个小结已经实现，主要注意力在code上。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Elasticsearch是基于Lucene开发的一个分布式全文检索框架，向Elasticsearch中存储和从Elasticsearch中查询，格式是json。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;索引index，相当于数据库中的database。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型type相当于数据库中的table。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主键id相当于数据库中记录的主键，是唯一的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向Elasticsearch中存储数据，其实就是向es中的index下面的type中存储json类型的数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Elasticsearch是RestFul风格的api，通过http的请求形式（注意，参数是url拼接还是请求的json形式哦），发送请求，对Elasticsearch进行操作。
    &lt;ul&gt;
      &lt;li&gt;查询，请求方式应该是get。删除，请求方式应该是delete。添加，请求方式应该是put/post。修改，请求方式应该是put/post。&lt;/li&gt;
      &lt;li&gt;RESTFul接口url的格式:http://ip:port/&lt;index&gt;/&lt;type&gt;/&amp;lt;[id]&amp;gt;。其中index、type是必须提供的。id是可以选择的，不提供es会自动生成，index、type将信息进行分层，利于管理。&lt;/type&gt;&lt;/index&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;chapter-10-运行中的springboot&quot;&gt;Chapter 10 运行中的SpringBoot&lt;/h1&gt;

&lt;h2 id=&quot;springboot的各种-actuator-endpoint&quot;&gt;SpringBoot的各种 Actuator EndPoint&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Actuator 目的是监控和管理应用程序&lt;/li&gt;
  &lt;li&gt;访问形式 HTTP,JMX&lt;/li&gt;
  &lt;li&gt;使用 引入spring-boot-start-actuator&lt;/li&gt;
  &lt;li&gt;访问接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;接入访问&quot;&gt;接入访问&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 访问
    &lt;ul&gt;
      &lt;li&gt;/actuator/&lt;id&gt;&lt;/id&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;端⼝与路径
    &lt;ul&gt;
      &lt;li&gt;management.server.address=&lt;/li&gt;
      &lt;li&gt;management.server.port= actuator 发布端口和应用端口分开实现隔离外部访问端口设置为8080 但是actuator端口是用8081外部就不会访问acutuator&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.base-path=/actuator&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.path-mapping.&lt;id&gt;=路径&lt;/id&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启 Endpoint
    &lt;ul&gt;
      &lt;li&gt;management.endpoint.&lt;id&gt;.enabled=true 可以通过这种方式关掉某写端口&lt;id&gt;变成health并且设置为false就能关掉health端口&lt;/id&gt;&lt;/id&gt;&lt;/li&gt;
      &lt;li&gt;management.endpoints.enabled-by-default=false&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;暴露 Endpoint
    &lt;ul&gt;
      &lt;li&gt;management.endpoints.jmx.exposure.exclude=&lt;/li&gt;
      &lt;li&gt;management.endpoints.jmx.exposure.include=* 表示发布所有&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.exposure.exclude=&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.exposure.include=info, health&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;打开 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:8080/actuator&lt;/code&gt; 可以看见各种对web状况&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自己定制-health-indicator&quot;&gt;自己定制 health Indicator&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;目的：检查应用程序的运行状态&lt;/li&gt;
  &lt;li&gt;状态：
    &lt;ul&gt;
      &lt;li&gt;DOWN 503&lt;/li&gt;
      &lt;li&gt;OUT_OF_SERVICE 503&lt;/li&gt;
      &lt;li&gt;UP 200&lt;/li&gt;
      &lt;li&gt;UNKNOWN 200&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-boot-带的-health-indicator&quot;&gt;Spring Boot ⾃带的 Health Indicator&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;机制
    &lt;ul&gt;
      &lt;li&gt;通过 HealthIndicatorRegistry 收集信息&lt;/li&gt;
      &lt;li&gt;HealthIndicator 实现具体检查逻辑&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置项
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;management.health.defaults.enabled=true&lt;/td&gt;
              &lt;td&gt;false 默认打开所有indicator&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;management.health.&lt;id&gt;.enabled=true&lt;/id&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;management.endpoint.health.show-details=never&lt;/td&gt;
              &lt;td&gt;when-&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;authorized&lt;/td&gt;
              &lt;td&gt;always 看到具体明细状况&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自定义health-indicator&quot;&gt;自定义Health Indicator&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pom&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;application.properties文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.jpa.hibernate.ddl-auto=none
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true

management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

info.app.author=DigitalSonic
info.app.encoding=@project.build.sourceEncoding@
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的info.app是这是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8080/actuctor/info&lt;/code&gt;中能看到的author信息和encoding&lt;/p&gt;

&lt;p&gt;因为是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show-details&lt;/code&gt;所以是显示所有的database具体信息的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实际的indicator
在support文件中加入&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
public class CoffeeIndicator implements HealthIndicator {
  @Autowired
  private CoffeeService coffeeService;

  @Override
  public Health health() {
    long count = coffeeService.getCoffeeCount();
    Health health;
    if (count &amp;gt; 0) {
      health = Health.up()
        .withDetail(&quot;count&quot;, count)
        .withDetail(&quot;message&quot;, &quot;We have enough coffee.&quot;)
        .build();
    } else {
      health = Health.down()
              .withDetail(&quot;count&quot;, 0)
              .withDetail(&quot;message&quot;, &quot;We are out of coffee.&quot;)
              .build();
    }
    return health;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码表示如果没有在数据库中有多余0的数量的coffee就表示插入失败，是一种自动配置不需要再Controller中实现调用&lt;/p&gt;

&lt;h2 id=&quot;micrometer-获得运行数据&quot;&gt;Micrometer 获得运行数据&lt;/h2&gt;
&lt;p&gt;度量界的Sl4j&lt;/p&gt;
&lt;h3 id=&quot;micrometer-特性&quot;&gt;Micrometer 特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;多维度
    &lt;ul&gt;
      &lt;li&gt;支持Tag&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;预置了大量探针
    &lt;ul&gt;
      &lt;li&gt;缓存 类加载器 GC CPU使用率 线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;与 Spring深度整合&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;核心度量指标&quot;&gt;核心度量指标&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;核心接口
    &lt;ul&gt;
      &lt;li&gt;Meter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内置实现
    &lt;ul&gt;
      &lt;li&gt;Gauge TimeGauge CPU使用情况&lt;/li&gt;
      &lt;li&gt;Timer LongTaskTimer FunctionTimer&lt;/li&gt;
      &lt;li&gt;Counter, FunctionCounter 分布式情况&lt;/li&gt;
      &lt;li&gt;DistributionSummary&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;micrometer-in-spring-boot-2x&quot;&gt;Micrometer in Spring Boot 2.x&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;⼀些 URL
    &lt;ul&gt;
      &lt;li&gt;/actuator/metrics&lt;/li&gt;
      &lt;li&gt;/actuator/prometheus&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些配置项
    &lt;ul&gt;
      &lt;li&gt;management.metrics.export.*&lt;/li&gt;
      &lt;li&gt;management.metrics.tags.*&lt;/li&gt;
      &lt;li&gt;management.metrics.enable.*&lt;/li&gt;
      &lt;li&gt;management.metrics.distribution.*&lt;/li&gt;
      &lt;li&gt;management.metrics.web.server.auto-time-requests&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;micrometer-in-spring-boot-2x-1&quot;&gt;Micrometer in Spring Boot 2.x&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;核⼼度量项
    &lt;ul&gt;
      &lt;li&gt;JVM、CPU、⽂文件句句柄数、⽇日志、启动时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他度量量项
    &lt;ul&gt;
      &lt;li&gt;Spring MVC、Spring WebFlux&lt;/li&gt;
      &lt;li&gt;Tomcat、Jersey JAX-RS&lt;/li&gt;
      &lt;li&gt;RestTemplate、WebClient&lt;/li&gt;
      &lt;li&gt;缓存、数据源、Hibernate&lt;/li&gt;
      &lt;li&gt;Kafka、RabbitMQ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;具体的实现&quot;&gt;具体的实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;自定义度量指标
    &lt;ul&gt;
      &lt;li&gt;通过 MeterRegistry 注册 Meter&lt;/li&gt;
      &lt;li&gt;提供 MeterBinder Bean 让 Spring Boot ⾃动绑定&lt;/li&gt;
      &lt;li&gt;通过 MeterFilter 进行定制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在Service 上面implements一个MeterBiner的接口 在这个Service中注册一个 Counter&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Service
@Transactional
@Slf4j
public class CoffeeOrderService implements MeterBinder {
  @Autowired
  private CoffeeOrderRepository orderRepository;

  private Counter orderCounter = null;

  public CoffeeOrder get(Long id) {
      return orderRepository.getOne(id);
  }

  public CoffeeOrder createOrder(String customer, Coffee...coffee) {
    CoffeeOrder order = CoffeeOrder.builder()
            .customer(customer)
            .items(new ArrayList&amp;lt;&amp;gt;(Arrays.asList(coffee)))
            .state(OrderState.INIT)
            .build();
    CoffeeOrder saved = orderRepository.save(order);
    log.info(&quot;New Order: {}&quot;, saved);
    orderCounter.increment();
    return saved;
  }

  public boolean updateState(CoffeeOrder order, OrderState state) {
    if (state.compareTo(order.getState()) &amp;lt;= 0) {
      log.warn(&quot;Wrong State order: {}, {}&quot;, state, order.getState());
      return false;
    }
    order.setState(state);
    orderRepository.save(order);
    log.info(&quot;Updated Order: {}&quot;, order);
    return true;
  }

  @Override
  public void bindTo(MeterRegistry meterRegistry) {
    this.orderCounter = meterRegistry.counter(&quot;order.count&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码维护了一个Counter并在最后将他注册为了一个MeterRegistry在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8080/actuator/order.count&lt;/code&gt;中只要是创建了订单就都会在这里有所体现。&lt;/p&gt;

&lt;h2 id=&quot;收集监控信息并展示springboot-admin&quot;&gt;收集监控信息并展示SpringBoot Admin&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目的:为 Spring Boot 应用程序提供一套管理界⾯ &lt;strong&gt;actuator中通过json显示的信息可以可视化的显示出来&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;主要功能:
    &lt;ul&gt;
      &lt;li&gt;集中展示应⽤用程序 Actuator 相关的内容&lt;/li&gt;
      &lt;li&gt;变更通知&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;快速上手&quot;&gt;快速上手&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;服务端
    &lt;ul&gt;
      &lt;li&gt;de.codecentric:spring-boot-admin-starter-server:2.1.3&lt;/li&gt;
      &lt;li&gt;@EnableAdminServer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端
    &lt;ul&gt;
      &lt;li&gt;de.codecentric:spring-boot-admin-starter-client:2.1.3 配置服务端及Endpoint&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.url=http://localhost:8080&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.exposure.include=*&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全控制&quot;&gt;安全控制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;安全相关依赖
    &lt;ul&gt;
      &lt;li&gt;spring-boot-starter-security&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务端配置
    &lt;ul&gt;
      &lt;li&gt;spring.security.user.name&lt;/li&gt;
      &lt;li&gt;spring.security.user.password&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端配置
    &lt;ul&gt;
      &lt;li&gt;spring.boot.admin.client.username&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.password&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.instance.metadata.user.name&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.instance.metadata.user.password&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-sba-server-demo-sba-client-demo&quot;&gt;案例 sba-server-demo sba-client-demo&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;server端的pom&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;server 端 applic.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.application.name=sba-server
server.port=8080

spring.security.user.name=geektime
spring.security.user.password=sba-server-password
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;server端 的主程序
加上了@EnableAdminServer注解&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
@EnableAdminServer
public class SbaServerApplication extends WebSecurityConfigurerAdapter {
	@Autowired
	private AdminServerProperties adminServerProperties;

	public static void main(String[] args) {
		SpringApplication.run(SbaServerApplication.class, args);
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		String adminContextPath = adminServerProperties.getContextPath();

		SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();
		successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);
		successHandler.setDefaultTargetUrl(adminContextPath + &quot;/&quot;);

		http.authorizeRequests()
				.antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()
				.antMatchers(adminContextPath + &quot;/login&quot;).permitAll()
				.anyRequest().authenticated()
				.and()
				.formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and()
				.logout().logoutUrl(adminContextPath + &quot;/logout&quot;).and()
				.httpBasic().and()
				.csrf()
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
				.ignoringAntMatchers(
						adminContextPath + &quot;/instances&quot;,
						adminContextPath + &quot;/actuator/**&quot;
				);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码实现了AdminServerProperties自动注入，并且对url的类型做出控制，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTargetUrlParameter(&quot;redirectTo&quot;);&lt;/code&gt;表示可以进行重定向，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/assets/**&quot;&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/login&quot;&lt;/code&gt;是不需要身份认证的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formLogin&lt;/code&gt;表示通过表单做登录，登出的url是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logout&lt;/code&gt;还开启了csrf支持&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.ignoringAntMatchers(
  adminContextPath + &quot;/instances&quot;,
  adminContextPath + &quot;/actuator/**&quot;
)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示忽略因为instances是server对client注册信息，actuator是用来监控&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client端的pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;client端application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.application.name=sba-client
server.port=8081

management.endpoints.web.exposure.include=*

info.demo.name=Spring Boot Admin Client Demo

spring.security.user.name=geektime
spring.security.user.password=sba-client-password

spring.boot.admin.client.url=http://localhost:8080
spring.boot.admin.client.username=geektime
spring.boot.admin.client.password=sba-server-password

spring.boot.admin.client.instance.metadata.user.name=${spring.security.user.name}
spring.boot.admin.client.instance.metadata.user.password=${spring.security.user.password}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;转为了8081端口，发布了所有端口，访问的server 是8080端口上的，用户名密码都对应了server中的用户名密码，通过占位符配置了instance的用户名密码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不建议产线上使用spring boot admin&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何定制web容器参数&quot;&gt;如何定制web容器参数&lt;/h2&gt;
&lt;h3 id=&quot;可选容器列表&quot;&gt;可选容器列表&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;spring-boot-starter-tomcat&lt;/li&gt;
  &lt;li&gt;spring-boot-starter-jetty&lt;/li&gt;
  &lt;li&gt;spring-boot-starter-undertow&lt;/li&gt;
  &lt;li&gt;spring-boot-starter-reactor-netty&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;修改容器配置&quot;&gt;修改容器配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;端⼝
    &lt;ul&gt;
      &lt;li&gt;server.port&lt;/li&gt;
      &lt;li&gt;server.address&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;压缩
    &lt;ul&gt;
      &lt;li&gt;server.compression.enabled 设置为True&lt;/li&gt;
      &lt;li&gt;server.compression.min-response-size 最小默认为2k&lt;/li&gt;
      &lt;li&gt;server.compression.mime-types&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;修改容器配置&quot;&gt;修改容器配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Tomcat 配置
    &lt;ul&gt;
      &lt;li&gt;server.tomcat.max-connections=10000&lt;/li&gt;
      &lt;li&gt;server.tomcat.max-http-post-size=2MB&lt;/li&gt;
      &lt;li&gt;server.tomcat.max-swallow-size=2MB&lt;/li&gt;
      &lt;li&gt;server.tomcat.max-threads=200&lt;/li&gt;
      &lt;li&gt;server.tomcat.min-spare-threads=10&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;错误处理
    &lt;ul&gt;
      &lt;li&gt;server.error.path=/error 错误页面是不是要显示信息&lt;/li&gt;
      &lt;li&gt;server.error.include-exception=false&lt;/li&gt;
      &lt;li&gt;server.error.include-stacktrace=never  在产线上不要打开&lt;/li&gt;
      &lt;li&gt;server.error.whitelabel.enabled=true&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他
    &lt;ul&gt;
      &lt;li&gt;server.use-forward-headers 设置头 传递真实的来源IP&lt;/li&gt;
      &lt;li&gt;server.servlet.session.timeout 设置超时&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编程方式
    &lt;ul&gt;
      &lt;li&gt;WebServerFactoryCustomizer&lt;T&gt;
&lt;/T&gt;        &lt;ul&gt;
          &lt;li&gt;TomcatServletWebServerFactory&lt;/li&gt;
          &lt;li&gt;JettyServletWebServerFactory&lt;/li&gt;
          &lt;li&gt;UndertowServletWebServerFactory&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;也可以自己写一个WebServerFactoryCustomizer 详见tomcat-demo&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实际案例&quot;&gt;实际案例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.jpa.hibernate.ddl-auto=none
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true

server.compression.enabled=true
server.compression.min-response-size=512B

server.error.include-stacktrace=always
server.error.include-exception=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置了压缩量，include了错误信息和栈信息，设置为true在实际生产中不要这么用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;替换压缩配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要编程实现压缩可以在主程序中写以下代码，application中的配置可以注掉&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void customize(TomcatServletWebServerFactory factory) {
  Compression compression = new Compression();
  compression.setEnabled(true);
  compression.setMinResponseSize(DataSize.ofBytes(512));
  factory.setCompression(compression);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;如何配置http2-上&quot;&gt;如何配置HTTP2 （上）&lt;/h2&gt;

&lt;h3 id=&quot;服务端配置https-service&quot;&gt;服务端配置HTTPS Service&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通过参数进行配置
    &lt;ul&gt;
      &lt;li&gt;server.port=8443&lt;/li&gt;
      &lt;li&gt;server.ssl.*
        &lt;ul&gt;
          &lt;li&gt;server.ssl.key-store&lt;/li&gt;
          &lt;li&gt;server.ssl.key-store-type，JKS或者PKCS12&lt;/li&gt;
          &lt;li&gt;server.ssl.key-store-password=secret&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;⽣成证书文件
    &lt;ul&gt;
      &lt;li&gt;命令
        &lt;ul&gt;
          &lt;li&gt;keytool -genkey -alias 别名&lt;/li&gt;
          &lt;li&gt;-storetype 仓库类型 -keyalg 算法 -keysize ⻓度&lt;/li&gt;
          &lt;li&gt;-keystore 文件名 -validity 有效期&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;说明
    &lt;ul&gt;
      &lt;li&gt;仓库类型，JKS、JCEKS、PKCS12 等&lt;/li&gt;
      &lt;li&gt;算法，RSA、DSA 等&lt;/li&gt;
      &lt;li&gt;⻓度，例例如 2048&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;eg. terminal上写入 springbucks apple$ keytool -genkey -alias springbucks -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore springbucks.p12 -validity 365&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;输入密钥库口令: spring 
再次输入新口令: spring
您的名字与姓氏是什么?
  [Unknown]:  Yuelyu
您的组织单位名称是什么?
  [Unknown]:  Yuelyu
您的组织名称是什么?
  [Unknown]:  Yuelyu
您所在的城市或区域名称是什么?
  [Unknown]:  Changchun
您所在的省/市/自治区名称是什么?
  [Unknown]:  Jilin
该单位的双字母国家/地区代码是什么?
  [Unknown]:  CN   
CN=Yuelyu, OU=Yuelyu, O=Yuelyu, L=Changchun, ST=Jilin, C=CN是否正确?
  [否]:  Y
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后会显示一个叫 springbucks.p12的文件&lt;/p&gt;

&lt;h3 id=&quot;客户端-https-支持&quot;&gt;客户端 HTTPS ⽀支持&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;配置 HttpClient ( &amp;gt;= 4.4 )
    &lt;ul&gt;
      &lt;li&gt;SSLContextBuilder 构造 SSLContext&lt;/li&gt;
      &lt;li&gt;setSSLHostnameVerifier(new NoopHostnameVerifier())&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置 RequestFactory
    &lt;ul&gt;
      &lt;li&gt;HttpComponentsClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;setHttpClient()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-ssl-waiter-service--ssl-customer-service&quot;&gt;案例 ssl-waiter-service &amp;amp; ssl-customer-service&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;service 中显示将刚刚配置的springbucks.p12文件导入到其中的resource目录下
在application.properties中写入，这里换了端口&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;# 在使用SSL属性时开的端口
server.port=8443
server.ssl.key-store=classpath:springbucks.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=spring
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;client
    &lt;ul&gt;
      &lt;li&gt;在application.properties中配置，对应的发现的地址，并且配置一个同样的p12文件和密码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;waiter.service.url=https://localhost:8443

security.key-store=classpath:springbucks.p12
security.key-pass=spring
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在主程序中，注入用户名密码，配置SSL校验SSLContextBuilder&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Value(&quot;${security.key-store}&quot;)
private Resource keyStore;
@Value(&quot;${security.key-pass}&quot;)
private String keyPass;
...
// 在main函数中配置 bean
@Bean
	public HttpComponentsClientHttpRequestFactory requestFactory() {
		SSLContext sslContext = null;
		try {
			sslContext = SSLContextBuilder.create()
					// 会校验证书
					.loadTrustMaterial(keyStore.getURL(), keyPass.toCharArray())
					// 放过所有证书校验
//					.loadTrustMaterial(null, (certificate, authType) -&amp;gt; true)
					.build();
		} catch(Exception e) {
			log.error(&quot;Exception occurred while creating SSLContext.&quot;, e);
		}

		CloseableHttpClient httpClient = HttpClients.custom()
				.evictIdleConnections(30, TimeUnit.SECONDS)
				.setMaxConnTotal(200)
				.setMaxConnPerRoute(20)
				.disableAutomaticRetries()
				.setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())
				.setSSLContext(sslContext)
				.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)
				.build();

		HttpComponentsClientHttpRequestFactory requestFactory =
				new HttpComponentsClientHttpRequestFactory(httpClient);

		return requestFactory;
	}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;terminal中curl 地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8443/menu&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl -k -v https://localhost:8443/menu/&lt;/code&gt; 带上-k是接收不安全的证书 -v打印详细信息，不要忘记加https&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显示的是详细的返回信息和证书的信息&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8443 (#0)
* ALPN, offering http/1.1
* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH
* successfully set certificate verify locations:
*   CAfile: /Users/apple/anaconda3/ssl/cacert.pem
  CApath: none
* TLSv1.2 (OUT), TLS header, Certificate Status (22):
* TLSv1.2 (OUT), TLS handshake, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Server hello (2):
* TLSv1.2 (IN), TLS handshake, Certificate (11):
* TLSv1.2 (IN), TLS handshake, Server key exchange (12):
* TLSv1.2 (IN), TLS handshake, Server finished (14):
* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):
* TLSv1.2 (OUT), TLS handshake, Finished (20):
* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):
* TLSv1.2 (IN), TLS handshake, Finished (20):
* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384
* ALPN, server did not agree to a protocol
* Server certificate:
*  subject: C=CN; ST=Jilin; L=Changchun; O=Yuelyu; OU=Yuelyu; CN=Yuelyu
*  start date: Dec 18 02:21:13 2020 GMT
*  expire date: Dec 18 02:21:13 2021 GMT
*  issuer: C=CN; ST=Jilin; L=Changchun; O=Yuelyu; OU=Yuelyu; CN=Yuelyu
*  SSL certificate verify result: self signed certificate (18), continuing anyway.
&amp;gt; GET /menu/ HTTP/1.1
&amp;gt; Host: localhost:8443
&amp;gt; User-Agent: curl/7.61.1
&amp;gt; Accept: */*
&amp;gt; 
&amp;lt; HTTP/1.1 200 
&amp;lt; vary: accept-encoding
&amp;lt; Content-Type: application/json;charset=UTF-8
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Date: Fri, 18 Dec 2020 02:54:50 GMT
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;在client端运行文件 使用的是restTemplate将所有的内容通过编程的方式获得&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;配置-http2-下&quot;&gt;配置 HTTP/2 （下）&lt;/h2&gt;

&lt;h3 id=&quot;前提条件&quot;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;支持 Java &amp;gt;= JDK 9&lt;/li&gt;
  &lt;li&gt;Tomcat &amp;gt;= 9.0.0&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Boot 不支持 h2c，需要先配置 SSL&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置项&quot;&gt;配置项&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;server.http2.enabled&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;客户端-http2-支持&quot;&gt;客户端 HTTP/2 支持&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 库选择
    &lt;ul&gt;
      &lt;li&gt;OkHttp( com.squareup.okhttp3:okhttp:3.14.0 )
        &lt;ul&gt;
          &lt;li&gt;OkHttpClient&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RestTemplate 配置
    &lt;ul&gt;
      &lt;li&gt;OkHttp3ClientHttpRequestFactory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例--http2-waiter-service--http2-customer-service&quot;&gt;案例  http2-waiter-service &amp;amp; http2-customer-service&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;server端 的 application.properties文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#设置 http2可行
server.http2.enabled=true
server.port=8443
server.ssl.key-store=classpath:springbucks.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=spring
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;client 端 修改CustormerApplication 主程序中注册的HttpClient为&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public ClientHttpRequestFactory requestFactory() {
  OkHttpClient okHttpClient = null;
  try {
    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
    keyStore.load(this.keyStore.getInputStream(), keyPass.toCharArray());//加载key store
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(keyStore);
    SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
    sslContext.init(null, tmf.getTrustManagers(), null);

    okHttpClient = new OkHttpClient.Builder()
        .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) tmf.getTrustManagers()[0])
        .hostnameVerifier((hostname, session) -&amp;gt; true)//对hostname 不做校验  
        .build();
  } catch (Exception e) {
    log.error(&quot;Exception occurred!&quot;, e);
  }
  return new OkHttp3ClientHttpRequestFactory(okHttpClient);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的代码只需要贴上去就可以实现http2的请求访问了&lt;/p&gt;

&lt;h2 id=&quot;spring-怎样开发一个只用命令行运行的程序&quot;&gt;Spring 怎样开发一个只用命令行运行的程序&lt;/h2&gt;

&lt;h3 id=&quot;关闭-web-容器&quot;&gt;关闭 Web 容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;控制依赖
    &lt;ul&gt;
      &lt;li&gt;不添加 Web 相关依赖&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置⽅式
    &lt;ul&gt;
      &lt;li&gt;spring.main.web-application-type=none&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编程⽅式
    &lt;ul&gt;
      &lt;li&gt;SpringApplication
        &lt;ul&gt;
          &lt;li&gt;setWebApplicationType()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SpringApplicationBuilder
        &lt;ul&gt;
          &lt;li&gt;web()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在调⽤ SpringApplication 的 run() ⽅法前 设置 WebApplicationType&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用工具类&quot;&gt;常⽤用⼯工具类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不同的 Runner
    &lt;ul&gt;
      &lt;li&gt;ApplicationRunner
        &lt;ul&gt;
          &lt;li&gt;参数是 ApplicationArguments&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CommandLineRunner
        &lt;ul&gt;
          &lt;li&gt;参数是 String[] 
&lt;strong&gt;以上两个功能是类似，就是在程序开始之前启动一段代码，区别在于参数&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;返回码
    &lt;ul&gt;
      &lt;li&gt;ExitCodeGenerator&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-command-line-demo&quot;&gt;案例 command-line-demo&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在application.properties中设置不能开启web
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.main.web-application-type=none&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在主程序中设置配置项，表示web不启用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
public class CommandLineApplication {

	public static void main(String[] args) {
		new SpringApplicationBuilder(CommandLineApplication.class)
				.web(WebApplicationType.NONE)
				.run(args);
		// 根据 application.properties 里的配置来决定 WebApplicationType
//		SpringApplication.run(CommandLineApplication.class, args);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;设置3个执行的主方法根据执行顺序
    &lt;ol&gt;
      &lt;li&gt;Foo&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
@Order(1)
@Slf4j
public class FooCommandLineRunner implements CommandLineRunner {
  @Override
  public void run(String... args) throws Exception {
      log.info(&quot;Foo&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Bar&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
@Order(2)
@Slf4j
public class BarApplicationRunner implements ApplicationRunner {
  @Override
  public void run(ApplicationArguments args) throws Exception {
      log.info(&quot;Bar&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;获得 ApplicationContextAware 取得 applicationContext 在将其传入 SpringApplication其实就是能获得返回码&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
@Order(3)
@Slf4j
public class ExitApplicationRunner implements ApplicationRunner, ApplicationContextAware {
  private ApplicationContext applicationContext;//获取

  @Override
  public void run(ApplicationArguments args) throws Exception {
    int code = SpringApplication.exit(applicationContext);
    log.info(&quot;Exit with {}.&quot;, code);//打印返回码 后面扩展 传入 exit值
    System.exit(code);
  }

  @Override
  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    this.applicationContext = applicationContext;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;返回码的Generator&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
public class MyExitCodeGenerator implements ExitCodeGenerator {
  @Override
  public int getExitCode() {
      return 1;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;可执行jar包&quot;&gt;可执行jar包&lt;/h2&gt;

&lt;h3 id=&quot;认识可执-jar&quot;&gt;认识可执⾏ Jar&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;包含
    &lt;ul&gt;
      &lt;li&gt;Jar 描述，META-INF/MANIFEST.MF&lt;/li&gt;
      &lt;li&gt;Spring Boot Loader，org/springframework/boot/loader&lt;/li&gt;
      &lt;li&gt;项⽬目内容，BOOT-INF/classes&lt;/li&gt;
      &lt;li&gt;项目依赖，BOOT-INF/lib&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不包含
    &lt;ul&gt;
      &lt;li&gt;JDK / JRE&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何找到程序的口&quot;&gt;如何找到程序的⼊口&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Jar 的启动类
    &lt;ul&gt;
      &lt;li&gt;MANIFEST.MF
        &lt;ul&gt;
          &lt;li&gt;Main-Class: org.springframework.boot.loader.JarLauncher&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;项目的主类
    &lt;ul&gt;
      &lt;li&gt;@SpringApplication&lt;/li&gt;
      &lt;li&gt;MANIFEST.MF
        &lt;ul&gt;
          &lt;li&gt;Start-Class: xxx.yyy.zzz&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何直接创建可执行的jar&quot;&gt;如何直接创建可执行的jar&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;executable&amp;gt;true&amp;lt;/executable&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;打包后的 Jar 可直接运行，无需 java 命令  运行方式就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./ jar包名&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可以在 .conf 的同名⽂件中配置参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;config中的可执行参数&quot;&gt;config中的可执行参数&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;配置项&lt;/td&gt;
      &lt;td&gt;说明&lt;/td&gt;
      &lt;td&gt;备注&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CONF_FOLDER&lt;/td&gt;
      &lt;td&gt;放置 .conf 的⽬录位置&lt;/td&gt;
      &lt;td&gt;只能放环境变量量中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JAVA_OPTS&lt;/td&gt;
      &lt;td&gt;JVM 启动时的参数&lt;/td&gt;
      &lt;td&gt;比如 JVM 的内存和 GC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RUN_ARGS&lt;/td&gt;
      &lt;td&gt;传给程序执⾏的参数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;案例-jar-demo&quot;&gt;案例 jar-demo&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进入到 jar-demo的文件夹下执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn clean package -Dmaven.test.skip=true&lt;/code&gt;开始打包
[INFO] Scanning for projects…
[INFO]
[INFO] ————-&amp;lt; geektime.spring.springbucks:waiter-service &amp;gt;————-
[INFO] Building waiter-service 0.0.1-SNAPSHOT
[INFO] ——————————–[ jar ]———————————
…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;之后进入到target目录中解码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd target/
unzip -l waiter-service-0.0.1-SNAPSHOT.jar
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看到jar包内容其中包含 META-INF/MANIFEST.MF这个文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;之后进入到 META-INF/MANIFEST.MF文件中获得 基本信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unzip -p waiter-service-0.0.1-SNAPSHOT.jar META-INF/MANIFEST.MF&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;warning [waiter-service-0.0.1-SNAPSHOT.jar]:  8692 extra bytes at beginning or within zipfile
  (attempting to process anyway)
Manifest-Version: 1.0
Implementation-Title: waiter-service
Implementation-Version: 0.0.1-SNAPSHOT
Built-By: apple
Implementation-Vendor-Id: geektime.spring.springbucks
Spring-Boot-Version: 2.1.3.RELEASE
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: geektime.spring.springbucks.waiter.WaiterServiceApplicati
 on
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Created-By: Apache Maven 3.6.3
Build-Jdk: 1.8.0_181
Implementation-URL: https://projects.spring.io/spring-boot/#/spring-bo
 ot-starter-parent/waiter-service
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示是谁写的，jdk版本，Main-Class，Start-Class等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unzip 的使用 -l 显示压缩文件内所包含的文件。-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将这个jar包赋值到外面
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp -f waiter-service-0.0.1-SNAPSHOT.jar ../waiter-service.jar&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同一个目录下准备了一个waiter-service.conf文件用来配置 JVM 的参数
文件中的内容是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JAVA_OPTS=&quot;-Xmx1024m -Xms1024m -Xmn384m&quot;&lt;/code&gt; 查看 这个config文件的命令行是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat waiter-service.conf&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;执行已经打包好的jar文件 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./waiter-service.jar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看是否按照conf配置jvm参数
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps xu| grep java&lt;/code&gt;可以看到 刚刚运行的java&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;apple 56271   0.0  5.8  6921632 486412 s003  S+    1:58下午   0:41.47 /usr/bin/java -Dsun.misc.URLClassPath.disableJarChecking=true -Xmx1024m -Xms1024m -Xmn384m -jar /Users/apple/Downloads/spring全家桶/geektime-spring-family/Chapter 10/jar-demo/waiter-service.jar
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spring-boot-打包成docker镜像&quot;&gt;Spring boot 打包成Docker镜像&lt;/h2&gt;

&lt;h3 id=&quot;什么是docker镜像&quot;&gt;什么是Docker镜像&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;镜像是静态的只读模板&lt;/li&gt;
  &lt;li&gt;镜像中包含构建 Docker 容器的指令&lt;/li&gt;
  &lt;li&gt;镜像是分层的&lt;/li&gt;
  &lt;li&gt;通过 Dockerfile 来创建镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;指令&lt;/td&gt;
      &lt;td&gt;作⽤&lt;/td&gt;
      &lt;td&gt;格式举例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FROM&lt;/td&gt;
      &lt;td&gt;基于哪个镜像&lt;/td&gt;
      &lt;td&gt;FROM /&lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]&lt;/name&gt;&lt;/tag&gt;&lt;/image&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LABEL&lt;/td&gt;
      &lt;td&gt;设置标签&lt;/td&gt;
      &lt;td&gt;LABEL maintainer=“Geektime”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RUN&lt;/td&gt;
      &lt;td&gt;运行安装命令&lt;/td&gt;
      &lt;td&gt;RUN [“executable”, “param1”, “param2”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CMD&lt;/td&gt;
      &lt;td&gt;容器启动时的命令&lt;/td&gt;
      &lt;td&gt;CMD [“executable”,”param1”,”param2”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ENTRYPOINT&lt;/td&gt;
      &lt;td&gt;容器启动后的命令&lt;/td&gt;
      &lt;td&gt;ENTRYPOINT [“executable”, “param1”, “param2”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VOLUME&lt;/td&gt;
      &lt;td&gt;挂载目录&lt;/td&gt;
      &lt;td&gt;VOLUME [“/data”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EXPOSE&lt;/td&gt;
      &lt;td&gt;容器要监听的端⼝&lt;/td&gt;
      &lt;td&gt;EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]&lt;/protocol&gt;&lt;/port&gt;&lt;/port&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ENV&lt;/td&gt;
      &lt;td&gt;设置环境变量&lt;/td&gt;
      &lt;td&gt;ENV &lt;key&gt; &lt;value&gt;&lt;/value&gt;&lt;/key&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ADD&lt;/td&gt;
      &lt;td&gt;添加⽂件&lt;/td&gt;
      &lt;td&gt;ADD [–chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;&lt;/dest&gt;&lt;/src&gt;&lt;/group&gt;&lt;/user&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WORKDIR&lt;/td&gt;
      &lt;td&gt;设置运行的⼯作⽬录&lt;/td&gt;
      &lt;td&gt;WORKDIR /path/to/workdir&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;USER&lt;/td&gt;
      &lt;td&gt;设置运行的⽤户&lt;/td&gt;
      &lt;td&gt;USER &lt;user&gt;[:&lt;group&gt;]&lt;/group&gt;&lt;/user&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;maven来构建docker&quot;&gt;maven来构建Docker&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;准备⼯作
    &lt;ul&gt;
      &lt;li&gt;提供⼀个 Dockerfile&lt;/li&gt;
      &lt;li&gt;配置 dockerfile-maven-plugin 插件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;执行构建
    &lt;ul&gt;
      &lt;li&gt;mvn package&lt;/li&gt;
      &lt;li&gt;mvn dockerfile:build&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;检查结果
    &lt;ul&gt;
      &lt;li&gt;docker images&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-1&quot;&gt;案例&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;properties&amp;gt;
  &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
  &amp;lt;docker.image.prefix&amp;gt;springbucks&amp;lt;/docker.image.prefix&amp;gt;
&amp;lt;/properties&amp;gt;

...

&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;com.spotify&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;dockerfile-maven-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.4.10&amp;lt;/version&amp;gt;
  &amp;lt;executions&amp;gt;
    &amp;lt;execution&amp;gt;
      &amp;lt;id&amp;gt;default&amp;lt;/id&amp;gt;
      &amp;lt;goals&amp;gt;
        &amp;lt;goal&amp;gt;build&amp;lt;/goal&amp;gt;
        &amp;lt;goal&amp;gt;push&amp;lt;/goal&amp;gt;
      &amp;lt;/goals&amp;gt;
    &amp;lt;/execution&amp;gt;
  &amp;lt;/executions&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;repository&amp;gt;${docker.image.prefix}/${project.artifactId}&amp;lt;/repository&amp;gt;
    &amp;lt;tag&amp;gt;${project.version}&amp;lt;/tag&amp;gt;
    &amp;lt;buildArgs&amp;gt;
      &amp;lt;JAR_FILE&amp;gt;${project.build.finalName}.jar&amp;lt;/JAR_FILE&amp;gt;
    &amp;lt;/buildArgs&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;pom文件同目录下写入Docker文件 
其中Docker文件如下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;FROM java:8
EXPOSE 8080
ARG JAR_FILE
ADD target/${JAR_FILE} /waiter-service.jar
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;/waiter-service.jar&quot;]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;镜像是基于java8构建、端口是8080、将target文件夹下的jar文件放到 /waiter-service.jar这个文件下 ，在程序运行的时候就是执行 java -jar /waiter-service.jar这样来执行的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进入到pom文件所在目录 开始利用maven打包&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn clean package -Dmaven.test.skip=true&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;经过漫长时间的打包终于能看到镜像了
执行镜像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name waiter-service -d -p 8080:8080 springbucks/waiter-service:0.0.1-SNAPSHOT&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看日志
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker logs waiter-service&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 09 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/12/09/Spring04/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/09/Spring04/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记03 访问Web资源和Web开发进阶 </title>
        <description>&lt;h1 id=&quot;chapter-6-访问web资源&quot;&gt;Chapter 6 访问Web资源&lt;/h1&gt;

&lt;h2 id=&quot;通过-resttemplate-访问-web-资源&quot;&gt;通过 RestTemplate 访问 Web 资源&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Boot 中的 RestTemplate
    &lt;ul&gt;
      &lt;li&gt;Spring Boot 中没有⾃自动配置 RestTemplate&lt;/li&gt;
      &lt;li&gt;Spring Boot 提供了了 RestTemplateBuilder
        &lt;ul&gt;
          &lt;li&gt;RestTemplateBuilder.build()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用方法
    &lt;ul&gt;
      &lt;li&gt;GET 请求  getForObject() / getForEntity()&lt;/li&gt;
      &lt;li&gt;POST 请求 postForObject() / postForEntity() PUT 请求&lt;/li&gt;
      &lt;li&gt;PUT 请求 put()&lt;/li&gt;
      &lt;li&gt;DELETE 请求 delete()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;构造URI
    &lt;ul&gt;
      &lt;li&gt;构造 URI： UriComponentsBuilder&lt;/li&gt;
      &lt;li&gt;构造相对于当前请求的 URI： ServletUriComponentsBuilder&lt;/li&gt;
      &lt;li&gt;构造指向 Controller 的 URI：MvcUriComponentsBuilder
simple-restTemplate-demo示例&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resttemplate-的高阶用法&quot;&gt;RestTemplate 的高阶用法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;传递 HTTP Header在requestEntity中传入响应头
    &lt;ul&gt;
      &lt;li&gt;RestTemplate.exchange()&lt;/li&gt;
      &lt;li&gt;RequestEntity&lt;T&gt; / ResponseEntity&lt;T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类型转化
    &lt;ul&gt;
      &lt;li&gt;JsonSerializer / JsonDeserializer 序列化和反序列化&lt;/li&gt;
      &lt;li&gt;@JsonComponent&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解析泛型队形
    &lt;ul&gt;
      &lt;li&gt;RestTemplate.exchange()&lt;/li&gt;
      &lt;li&gt;ParameterizedTypeReference&lt;T&gt;
以上内容的具体实现是complex-resttemplate-demo&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;getForObject–发送GET请求，将HTTP response转换成一个指定的object对象&lt;/strong&gt;
&lt;strong&gt;postForEntity – 发送POST请求，将给定的对象封装到HTTP请求体，返回类型是一个HttpEntity对象&lt;/strong&gt;
&lt;strong&gt;每个HTTP方法对应的RestTemplate方法都有3种。其中2种的url参数为字符串，URI参数变量分别是Object数组和Map，第3种使用URI类型作为参数exchange 和execute 方法比上面列出的其它方法（如getForObject、postForEntity等）使用范围更广，允许调用者指定HTTP请求的方法（GET、POST、PUT等），并且可以支持像HTTP PATCH（部分更新)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在RestTemplate.exchange中的参数&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;url: 请求地址；&lt;/li&gt;
  &lt;li&gt;method: 请求类型(如：POST,PUT,DELETE,GET)；&lt;/li&gt;
  &lt;li&gt;requestEntity: 请求实体，封装请求头，请求内容&lt;/li&gt;
  &lt;li&gt;responseType: 响应类型，根据服务接口的返回类型决定&lt;/li&gt;
  &lt;li&gt;uriVariables: url中参数变量值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;以上的参数可以采用单独requestEntity和 responseType两个合起来实现的方式&lt;/strong&gt;
    &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coffeeUri, HttpMethod.GET, null, ptr&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req, String.class&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;简单定制resttemplate-advanced-resttemplate-demo&quot;&gt;简单定制RestTemplate （advanced-resttemplate-demo）&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;RestTemplate ⽀支持的 HTTP 库
    &lt;ul&gt;
      &lt;li&gt;默认实现：SimpleClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;通用接口：ClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;Apache HttpComponents：HttpComponentsClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;Netty: Netty4ClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;OkHttp: OkHttp3ClientHttpRequestFactory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定制主要是在做什么
    &lt;ul&gt;
      &lt;li&gt;连接管理
        &lt;ul&gt;
          &lt;li&gt;PoolingHttpClientConnectionManager&lt;/li&gt;
          &lt;li&gt;KeepAlive 策略&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;超时设定&lt;strong&gt;不能无限制等待&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;connectTimeout / readTimeout&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SSL校验
        &lt;ul&gt;
          &lt;li&gt;证书检查策略&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;4.5.7&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ConnectionKeepAliveStrategy来源于此&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在工具类中实现对最长存活时间的注解&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class CustomConnectionKeepAliveStrategy implements ConnectionKeepAliveStrategy {
  private final long DEFAULT_SECONDS = 30;
  @Override
  public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) {
    return Arrays.asList(httpResponse.getHeaders(HTTP.CONN_KEEP_ALIVE))
    .stream()
    .filter(h -&amp;gt; StringUtils.equalsIgnoreCase(h.getName(), &quot;timeout&quot;)
    &amp;amp;&amp;amp; StringUtils.isNumeric(h.getValue()))
    .findFirst()
    .map(h -&amp;gt; NumberUtils.toLong(h.getValue(), DEFAULT_SECONDS))
    .orElse(DEFAULT_SECONDS) * 1000;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用stream方法对上下文做出修改，获取HttpResponse的keepLive的响应头，对timeout这个属性，如果这个属性的parameter的属性是数字就取出来，转换为Long类型，如果转换失败就是用默认值来代替，复杂化的写法详见&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;../.m2/repository/org/apache/httpcomponents/httpclient/4.5.7/httpclient-4.5.7.jar!/org/apache/http/impl/client/DefaultConnectionKeepAliveStrategy.class&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在主程序中模拟web来访问资源&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
@Slf4j
public class CustomerServiceApplication implements ApplicationRunner {
	@Autowired
	private RestTemplate restTemplate;

	public static void main(String[] args) {
		new SpringApplicationBuilder()//构建运行池 不启动 Tomcat
				.sources(CustomerServiceApplication.class)
				.bannerMode(Banner.Mode.OFF)
				.web(WebApplicationType.NONE)
				.run(args);
	}
  ...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码意思是使用restTemplate，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.web(WebApplicationType.NONE)&lt;/code&gt;表示不默认启动一个服务器，因为启动web服务的同时会启动Tomcat，这个操作就是将其关闭。&lt;/p&gt;

&lt;p&gt;以下代码接上面代码&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public HttpComponentsClientHttpRequestFactory requestFactory() {//配置连接池
  PoolingHttpClientConnectionManager connectionManager =
      new PoolingHttpClientConnectionManager(30, TimeUnit.SECONDS);
  connectionManager.setMaxTotal(200);//最大连接数
  connectionManager.setDefaultMaxPerRoute(20);

  CloseableHttpClient httpClient = HttpClients.custom()//定制 HttpClient
      .setConnectionManager(connectionManager)//connectionManager 来自前面设置的
      .evictIdleConnections(30, TimeUnit.SECONDS)
      .disableAutomaticRetries()//不希望自动重试 比如打款操作 HttpClient 是为了模仿网页中的请求设计的
      // 有 Keep-Alive 认里面的值，没有的话永久有效
      //.setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE)
      // 换成自定义的
      .setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())
      .build();

  HttpComponentsClientHttpRequestFactory requestFactory =//利用HttpClient创建了requestFactory
      new HttpComponentsClientHttpRequestFactory(httpClient);

  return requestFactory;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码的作用是设置连接池，定制HttpClient，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.disableAutomaticRetries()&lt;/code&gt; 不希望自动重试 比如打款操作 HttpClient 是为了模仿网页中的请求设计,如果自动重试有些操作会发生错误；修改默认的KeepLive时间&lt;/p&gt;

&lt;p&gt;以下代码接上面代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	@Bean
	public RestTemplate restTemplate(RestTemplateBuilder builder) {
//		return new RestTemplate();

		return builder
      .setConnectTimeout(Duration.ofMillis(100))//连接超时100毫秒
      .setReadTimeout(Duration.ofMillis(500))
      .requestFactory(this::requestFactory)
      .build();
	}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码的意思是设置连接超时时间100毫秒，readTimeout是500毫秒，传入requestFactory&lt;strong&gt;java8中使用::来访问类的构造方法，对象方法，静态方法&lt;a href=&quot;https://blog.csdn.net/kegaofei/article/details/80582356&quot; target=&quot;_blank&quot;&gt;::java8详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下代码接上面&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  URI uri = UriComponentsBuilder
      .fromUriString(&quot;http://localhost:8080/coffee/?name={name}&quot;)
      .build(&quot;mocha&quot;);
  RequestEntity&amp;lt;Void&amp;gt; req = RequestEntity.get(uri)
      .accept(MediaType.APPLICATION_XML)
      .build();
  ResponseEntity&amp;lt;String&amp;gt; resp = restTemplate.exchange(req, String.class);
  log.info(&quot;Response Status: {}, Response Headers: {}&quot;, resp.getStatusCode(), resp.getHeaders().toString());
  log.info(&quot;Coffee: {}&quot;, resp.getBody());
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码的意思是UriComponentsBuilder建立一个根据name查找coffee的请求了，使用的是GET方法，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestEntity&amp;lt;Void&amp;gt;&lt;/code&gt;是在GET请求的情况下才是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Void&lt;/code&gt;如果是POST就不能为空，通过构造&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestEntity&lt;/code&gt;并且显示返回值也就是accept头是xml类型穿件请求，之后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restTemplate.exchange&lt;/code&gt;获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ResponseEntity&lt;/code&gt;返货的响应体是String类型的&lt;/p&gt;

&lt;p&gt;对于返回的是List类型的响应体如一次性要返回所有的Coffee对象需要使用专门的包装&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTypeReference&lt;/code&gt;详细代码如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;String coffeeUri = &quot;http://localhost:8080/coffee/&quot;;
Coffee request = Coffee.builder()
    .name(&quot;Americano&quot;)
    .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.00))
    .build();
Coffee response = restTemplate.postForObject(coffeeUri, request, Coffee.class);
log.info(&quot;New Coffee: {}&quot;, response);

ParameterizedTypeReference&amp;lt;List&amp;lt;Coffee&amp;gt;&amp;gt; ptr =
    new ParameterizedTypeReference&amp;lt;List&amp;lt;Coffee&amp;gt;&amp;gt;() {};
ResponseEntity&amp;lt;List&amp;lt;Coffee&amp;gt;&amp;gt; list = restTemplate
    .exchange(coffeeUri, HttpMethod.GET, null, ptr);
list.getBody().forEach(c -&amp;gt; log.info(&quot;Coffee: {}&quot;, c));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;通过webclient访问web资源&quot;&gt;通过WebClient访问Web资源&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;WebClient:⼀个以 Reactive ⽅方式处理理 HTTP 请求的非阻塞式的客户端，在RestTemplate 中能够实现的也能在WebClient中实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持的底层 HTTP 库&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Reactor Netty - ReactorClientHttpConnector&lt;/li&gt;
      &lt;li&gt;Jetty ReactiveStream HttpClient - JettyClientHttpConnector&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;创建WebClient库
    &lt;ul&gt;
      &lt;li&gt;WebClient.create()&lt;/li&gt;
      &lt;li&gt;WebClient.builder()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发起请求
    &lt;ul&gt;
      &lt;li&gt;get() / post() / put() / delete() / patch()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;获得结果
    &lt;ul&gt;
      &lt;li&gt;retrieve() / exchange()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理理 HTTP Status
    &lt;ul&gt;
      &lt;li&gt;onStatus()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;应答正⽂
    &lt;ul&gt;
      &lt;li&gt;bodyToMono() / bodyToFlux()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;导入pom文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;主程序&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public WebClient webClient(WebClient.Builder builder) {
  return builder.baseUrl(&quot;http://localhost:8080&quot;).build();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上是为了注册一个端口&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具体在主程序中的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  CountDownLatch cdl = new CountDownLatch(2);

  webClient.get()
    .uri(&quot;/coffee/{id}&quot;, 1)
    .accept(MediaType.APPLICATION_JSON_UTF8)
    .retrieve()//获得结果 类似于exchange
    .bodyToMono(Coffee.class)//转换为Mono型对象Mone&amp;lt;Coffee&amp;gt;
    .doOnError(t -&amp;gt; log.error(&quot;Error: &quot;, t))
    .doFinally(s -&amp;gt; cdl.countDown())//主线程等待异步线程处理
    .subscribeOn(Schedulers.single())
    .subscribe(c -&amp;gt; log.info(&quot;Coffee 1: {}&quot;, c));

  Mono&amp;lt;Coffee&amp;gt; americano = Mono.just(
      Coffee.builder()
        .name(&quot;americano&quot;)
        .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.00))
        .build()
  );
  webClient.post()
    .uri(&quot;/coffee/&quot;)
    .body(americano, Coffee.class)//post请求构造的正文就是之前Mono
    .retrieve()
    .bodyToMono(Coffee.class)
    .doFinally(s -&amp;gt; cdl.countDown())
    .subscribeOn(Schedulers.single())
    .subscribe(c -&amp;gt; log.info(&quot;Coffee Created: {}&quot;, c));

  cdl.await();

  webClient.get()
    .uri(&quot;/coffee/&quot;)
    .retrieve()
    .bodyToFlux(Coffee.class)//返回的是List类型 Flux表示多个对象 获得Flux&amp;lt;Coffee&amp;gt;
    .toStream()// Stream&amp;lt;Coffee&amp;gt;
    .forEach(c -&amp;gt; log.info(&quot;Coffee in List: {}&quot;, c));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码释义：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt;是一个计数器,作用大致就是数量达到了某个点之后计数结束，才能继续往下走。可以用作流程控制之类的作用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;countDown.await()&lt;/code&gt;代表需要在countDown计数完成之后才执行其后的代码，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;countDown.countDown()&lt;/code&gt;方法执行表示计数器加1，直到计数器中数字符合预设的数字之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await()&lt;/code&gt;方法才不会阻塞。&lt;/li&gt;
  &lt;li&gt;subscribeOn常见用法见02中subscribeOn详细信息的连接。&lt;/li&gt;
  &lt;li&gt;以上代码表示get一个请求，post一个请求，这两个的顺序是可变的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;WebClient使用场景：如果你用WebFlux，那请求处理过程中需要访问其他HTTP服务就可以用WebClient。再通用一点，你希望通过异步线程来访问HTTP时，就可以考虑用WebClient。Reactor可以简化你的多线程代码。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;chapter-7-web开发进阶&quot;&gt;Chapter 7 Web开发进阶&lt;/h1&gt;

&lt;h2 id=&quot;设计好的-restful-web-service&quot;&gt;设计好的 RESTful Web Service&lt;/h2&gt;

&lt;h3 id=&quot;识别资源&quot;&gt;识别资源&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;找到领域名词
    &lt;ul&gt;
      &lt;li&gt;能⽤ CRUD 操作的名词eg.Coffee&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将资源组织为集合(即集合资源)eg.Order&lt;/li&gt;
  &lt;li&gt;将资源合并为复合资源eg.CoffeeOrder&lt;/li&gt;
  &lt;li&gt;计算或处理理函数
    &lt;h3 id=&quot;选择合适的资源粒度&quot;&gt;选择合适的资源粒度&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;站在服务端的⻆角度，要考虑
    &lt;ul&gt;
      &lt;li&gt;⽹络效率&lt;/li&gt;
      &lt;li&gt;表述的多少：一次网络交互中处理多少东西&lt;/li&gt;
      &lt;li&gt;客户端的易用程度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;站在客户端的⻆角度，要考虑
    &lt;ul&gt;
      &lt;li&gt;可缓存性&lt;/li&gt;
      &lt;li&gt;修改频率：客户端多久变一次&lt;/li&gt;
      &lt;li&gt;可变性：eg.用户注册时间不会变&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设计-uri&quot;&gt;设计 URI&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用域及子域对资源进行合理的分组或划分&lt;/li&gt;
  &lt;li&gt;在 URI 的路径部分使⽤斜杠分隔符 ( / ) 来表示资源之间的层次关系&lt;/li&gt;
  &lt;li&gt;在 URI 的路径部分使⽤逗号 ( , ) 和分号 ( ; ) 来表示⾮层次元素，并不是所有库都支持&lt;/li&gt;
  &lt;li&gt;使用连字符 ( - ) 和下划线 ( _ ) 来改善⻓路径中名称的可读性&lt;/li&gt;
  &lt;li&gt;在 URI 的查询部分使⽤用“与”符号 ( &amp;amp; ) 来分隔参数，queryString&lt;/li&gt;
  &lt;li&gt;在 URI 中避免出现文件扩展名 ( 例例如 .php，.aspx 和 .jsp )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;选择合适的-http-法和返回码&quot;&gt;选择合适的 HTTP ⽅法和返回码&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;认识Http方法
&lt;img src=&quot;/img/jave-spring/chapter7-restful.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安全：不会改变资源内容
幂等：不管请求多少次，结果都是一样的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;URI 和Http结合的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/jave-spring/chapter7-restful-uri.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Http状态码
&lt;img src=&quot;/img/jave-spring/chapter7-httpstatuscode.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设计资源的表述json-xml-html&quot;&gt;设计资源的表述(json xml html)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JSON
    &lt;ul&gt;
      &lt;li&gt;MappingJackson2HttpMessageConverter&lt;/li&gt;
      &lt;li&gt;GsonHttpMessageConverter&lt;/li&gt;
      &lt;li&gt;JsonbHttpMessageConverter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XML
    &lt;ul&gt;
      &lt;li&gt;MappingJackson2XmlHttpMessageConverter&lt;/li&gt;
      &lt;li&gt;Jaxb2RootElementHttpMessageConverter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;ProtoBuf
    &lt;ul&gt;
      &lt;li&gt;ProtobufHttpMessageConverter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hateoas&quot;&gt;HATEOAS&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Richardson 成熟度模型
    &lt;ul&gt;
      &lt;li&gt;Level 3 - Hypermedia Controls&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HATEOAS
    &lt;ul&gt;
      &lt;li&gt;Hybermedia As The Engine Of Application State&lt;/li&gt;
      &lt;li&gt;REST 统⼀接口的必要组成部分&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hateoas-vs-wsdl&quot;&gt;HATEOAS v.s. WSDL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HATEOAS
    &lt;ul&gt;
      &lt;li&gt;表述中的超链接会提供服务所需的各种 REST 接口信息&lt;/li&gt;
      &lt;li&gt;无需事先约定如何访问服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;传统的服务契约
    &lt;ul&gt;
      &lt;li&gt;必须事先约定服务的地址与格式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用超链接类型&quot;&gt;常用超链接类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jave-spring/chapter7-hyper-type.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使-spring-data-rest-实现简单的超媒体服务&quot;&gt;使⽤ Spring Data REST 实现简单的超媒体服务&lt;/h2&gt;

&lt;h3 id=&quot;认识halhypertext-application-language&quot;&gt;认识HAL(Hypertext Application Language)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HAL 是⼀种简单的json格式，为 API 中的资源提供简单一致的链接&lt;/li&gt;
  &lt;li&gt;HAL 模型
    &lt;ul&gt;
      &lt;li&gt;链接&lt;/li&gt;
      &lt;li&gt;内嵌资源&lt;/li&gt;
      &lt;li&gt;状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-data-rest&quot;&gt;Spring Data REST&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Boot 依赖
    &lt;ul&gt;
      &lt;li&gt;spring-boot-starter-data-rest&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用注解与类
    &lt;ul&gt;
      &lt;li&gt;@RepositoryRestResource&lt;/li&gt;
      &lt;li&gt;Resource&lt;T&gt;&lt;/T&gt;&lt;/li&gt;
      &lt;li&gt;PagedResource&lt;T&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案例-chapter-8hateoas-waiter-service&quot;&gt;案例 Chapter 8/hateoas-waiter-service&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;启动服务之后可以通过超媒体的方式对内容进行查询
pom文件导入jpa和data rest&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-rest&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;启动服务之后用客户端访问服务-案例-chapter-8hateoas-customer-service&quot;&gt;启动服务之后用客户端访问服务 案例 Chapter 8/hateoas-customer-service&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;配置 Jackson JSON
    &lt;ul&gt;
      &lt;li&gt;注册 HAL 支持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;操作超链接
    &lt;ul&gt;
      &lt;li&gt;找到需要的 Link&lt;/li&gt;
      &lt;li&gt;访问超链接 restTemplate 或者 WebClient(不同link的POST, GET等)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;pom文件 导入web 和 data rest&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-rest&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Runner文件中这里的实现完全可以通过Postman自己操作&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private static final URI ROOT_URI = URI.create(&quot;http://localhost:8080/&quot;);
...

private Link getLink(URI uri, String rel) {
  ResponseEntity&amp;lt;Resources&amp;lt;Link&amp;gt;&amp;gt; rootResp = restTemplate.exchange(uri,
    HttpMethod.GET, 
    null,
    new ParameterizedTypeReference&amp;lt;Resources&amp;lt;Link&amp;gt;&amp;gt;() {});
  Link link = rootResp.getBody().getLink(rel);
  log.info(&quot;Link: {}&quot;, link);
  return link;
}

private void readCoffeeMenu(Link coffeeLink) {
  ResponseEntity&amp;lt;PagedResources&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt;&amp;gt; coffeeResp = restTemplate.exchange(coffeeLink.getTemplate().expand(),
    HttpMethod.GET, 
    null,
    new ParameterizedTypeReference&amp;lt;PagedResources&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt;&amp;gt;() {});
  log.info(&quot;Menu Response: {}&quot;, coffeeResp.getBody());
}

private Resource&amp;lt;Coffee&amp;gt; addCoffee(Link link) {
  Coffee americano = Coffee.builder()
          .name(&quot;americano&quot;)
          .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.0))
          .build();
  RequestEntity&amp;lt;Coffee&amp;gt; req =
          RequestEntity.post(link.getTemplate().expand()).body(americano);
  ResponseEntity&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt; resp =
          restTemplate.exchange(req,
                  new ParameterizedTypeReference&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt;() {});
  log.info(&quot;add Coffee Response: {}&quot;, resp);
  return resp.getBody();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;getLink 方法是发起一个Get请求，返回是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resources&amp;lt;Link&amp;gt;&lt;/code&gt;类型的，在通过getBody再去做getLink操作获得，假设原来的rel是coffees就会获得rel的link&lt;/li&gt;
  &lt;li&gt;readCoffeeMenu返回的是带有分页信息的Resources，每个内嵌的信息都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resource&amp;lt;Coffee&amp;gt;&lt;/code&gt;之后在拿这个信息做addCoffee&lt;/li&gt;
  &lt;li&gt;addCoffee传入添加coffee的link&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;添加订单&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private void addOrder(Link link, Resource&amp;lt;Coffee&amp;gt; coffee) {
  CoffeeOrder newOrder = CoffeeOrder.builder()
          .customer(&quot;Li Lei&quot;)
          .state(OrderState.INIT)
          .build();
  RequestEntity&amp;lt;?&amp;gt; req =
          RequestEntity.post(link.getTemplate().expand()).body(newOrder);
  ResponseEntity&amp;lt;Resource&amp;lt;CoffeeOrder&amp;gt;&amp;gt; resp =
          restTemplate.exchange(req,
                  new ParameterizedTypeReference&amp;lt;Resource&amp;lt;CoffeeOrder&amp;gt;&amp;gt;() {});
  log.info(&quot;add Order Response: {}&quot;, resp);

  Resource&amp;lt;CoffeeOrder&amp;gt; order = resp.getBody();
  Link items = order.getLink(&quot;items&quot;);
  req = RequestEntity.post(items.getTemplate().expand()).body(coffee.getLink(&quot;self&quot;));
  ResponseEntity&amp;lt;String&amp;gt; itemResp = restTemplate.exchange(req, String.class);
  log.info(&quot;add Order Items Response: {}&quot;, itemResp);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码addOrder使用先构造了一个coffeeOrder的对象，并将刚刚创建的coffeeOrder传入到由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestEntity.post&lt;/code&gt;的URI中，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restTemplate.exchange&lt;/code&gt;，通过对coffeeOrder中的items链接做post，传入的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resource&amp;lt;Coffee&amp;gt;&lt;/code&gt;表示的是取得原先的创建的coffee的链接(&lt;strong&gt;这里还是不太明白，详见62&lt;/strong&gt;)。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用String作为返回值类型查询到创建的订单中有多少coffee订单&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private void queryOrders(Link link) {
  ResponseEntity&amp;lt;String&amp;gt; resp = restTemplate.getForEntity(link.getTemplate().expand(), String.class);
  log.info(&quot;query Order Response: {}&quot;, resp);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;run中的主逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void run(ApplicationArguments args) throws Exception {
  Link coffeeLink = getLink(ROOT_URI,&quot;coffees&quot;);
  readCoffeeMenu(coffeeLink);
  Resource&amp;lt;Coffee&amp;gt; americano = addCoffee(coffeeLink);

  Link orderLink = getLink(ROOT_URI, &quot;coffeeOrders&quot;);
  addOrder(orderLink, americano);
  queryOrders(orderLink);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;分布式环境中解决session&quot;&gt;分布式环境中解决Session&lt;/h2&gt;

&lt;h3 id=&quot;常见的会话解决方案&quot;&gt;常见的会话解决方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;粘性会话 Sticky Session&lt;/li&gt;
  &lt;li&gt;会话复制 Session Replication&lt;/li&gt;
  &lt;li&gt;集中会话 Centralized Session
前两种不推荐，第三中使用redis集中存储&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;认识-spring-session&quot;&gt;认识 Spring Session&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Session
    &lt;ul&gt;
      &lt;li&gt;简化集群中的⽤户会话管理&lt;/li&gt;
      &lt;li&gt;⽆需绑定容器特定解决⽅案&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;支持的存储
    &lt;ul&gt;
      &lt;li&gt;Redis&lt;/li&gt;
      &lt;li&gt;MongoDB&lt;/li&gt;
      &lt;li&gt;JDBC&lt;/li&gt;
      &lt;li&gt;Hazelcast&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;定制 HttpSession&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过定制的 HttpServletRequest 返回定制的 HttpSession(屏蔽后端差异)
    &lt;ul&gt;
      &lt;li&gt;SessionRepositoryRequestWrapper&lt;/li&gt;
      &lt;li&gt;SessionRepositoryFilter&lt;/li&gt;
      &lt;li&gt;DelegatingFilterProxy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于-redis-的-httpsession&quot;&gt;基于 Redis 的 HttpSession&lt;/h3&gt;
&lt;p&gt;引⼊入依赖&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;spring-session-data-redis
基本配置&lt;/li&gt;
  &lt;li&gt;@EnableRedisHttpSession&lt;/li&gt;
  &lt;li&gt;提供 RedisConnectionFactory&lt;/li&gt;
  &lt;li&gt;实现 AbstractHttpSessionApplicationInitializer
    &lt;ul&gt;
      &lt;li&gt;配置 DelegatingFilterProxy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-boot-对-spring-session-的支持&quot;&gt;Spring Boot 对 Spring Session 的支持&lt;/h3&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;spring.session.store-type=redis&lt;/li&gt;
  &lt;li&gt;spring.session.timeout=
    &lt;ul&gt;
      &lt;li&gt;server.servlet.session.timeout=&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;spring.session.redis.flush-mode=on-save&lt;/li&gt;
  &lt;li&gt;spring.session.redis.namespace=spring:session&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实例&quot;&gt;实例&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-session-core&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;启动redis&lt;/li&gt;
  &lt;li&gt;带有相同SessionId的内容能显示相同属性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;使用webflux代替springmvc&quot;&gt;使用WebFlux代替SpringMVC&lt;/h2&gt;

&lt;h3 id=&quot;什么是-webflux&quot;&gt;什么是 WebFlux&lt;/h3&gt;
&lt;p&gt;⽤用于构建基于 Reactive 技术栈之上的 Web 应⽤用程序
基于 Reactive Streams API ，运⾏行行在⾮非阻塞服务器器上&lt;/p&gt;

&lt;h3 id=&quot;为什么会有-webflux&quot;&gt;为什么会有 WebFlux&lt;/h3&gt;
&lt;p&gt;对于⾮阻塞 Web 应用的需要 
函数式编程&lt;/p&gt;

&lt;h3 id=&quot;关于-webflux-的性能&quot;&gt;关于 WebFlux 的性能&lt;/h3&gt;
&lt;p&gt;请求的耗时并不会有很⼤的改善
仅需少量固定数量的线程和较少的内存即可实现扩展&lt;/p&gt;

&lt;h3 id=&quot;web-mvc-vs-web-flux&quot;&gt;Web MVC v.s. Web Flux&lt;/h3&gt;
&lt;p&gt;已有 Spring MVC 应⽤，运⾏正常，就别改了 
依赖了大量阻塞式持久化 API 和⽹络 API，建议使⽤ Spring MVC 
已经使⽤了⾮阻塞技术栈，可以考虑使⽤WebFlux
想要使⽤ Java 8 Lambda 结合轻量级函数式框架，可以考虑 WebFlux&lt;/p&gt;

&lt;h3 id=&quot;webflux-中的编程模型&quot;&gt;WebFlux 中的编程模型&lt;/h3&gt;
&lt;p&gt;两种编程模型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基于注解的控制器 &lt;strong&gt;课程中主要讨论的内容&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;函数式 Endpoints&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于注解的控制器&quot;&gt;基于注解的控制器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;常⽤用注解
    &lt;ul&gt;
      &lt;li&gt;@Controller&lt;/li&gt;
      &lt;li&gt;@RequestMapping 及其等价注解&lt;/li&gt;
      &lt;li&gt;@RequestBody / @ResponseBody&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;返回值
    &lt;ul&gt;
      &lt;li&gt;Mono&lt;T&gt; / Flux&lt;T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 09 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/12/09/Spring03/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/09/Spring03/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>RestTemplate</category>
        
        <category>RESTful API</category>
        
        <category>Spring MVC</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Pandas </title>
        <description>
</description>
        <pubDate>Mon, 29 Nov 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/11/29/Pandas/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/11/29/Pandas/</guid>
        
        <category>Python</category>
        
        <category>Pandas</category>
        
        <category>Numpy</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记02 数据库操作进阶以及MVC实战相关 </title>
        <description>&lt;h1 id=&quot;chapter-4-数据访问进阶&quot;&gt;Chapter 4 数据访问进阶&lt;/h1&gt;

&lt;h2 id=&quot;project-reactor&quot;&gt;Project Reactor&lt;/h2&gt;

&lt;p&gt;“在计算机中，响应式编程或反应式编程(英语:Reactive Programming)是⼀一种⾯面向数据流和变化传播的编程范式。这 意味着可以在编程语⾔言中很⽅方便便地表达静态或动态的数据流， ⽽而相关的计算模型会⾃自动将变化的值通过数据流进⾏行行传播。”&lt;/p&gt;

&lt;p&gt;实现上下文的语句简洁性，如果需要不停的判断CallBack是很麻烦的&lt;/p&gt;

&lt;h3 id=&quot;基本知识&quot;&gt;基本知识&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Operators - Publisher / Subscriber 发布和订阅
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Nothing Happens Until You subscribe()&lt;/strong&gt; 只有subscribe才会执行&lt;/li&gt;
      &lt;li&gt;Flux [ 0..N ] - onNext()、onComplete()、onError()&lt;/li&gt;
      &lt;li&gt;Mono [ 0..1 ] - onNext()、onComplete()、onError()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Flux 和 Mono都是通过lambda去处理的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Backpressure 缓压力上游生产速度快，下游subscribe跟不上
    &lt;ul&gt;
      &lt;li&gt;Subscription&lt;/li&gt;
      &lt;li&gt;onRequest()每次请求多少元素、onCancel()取消订阅过程、onDispose()终止订阅过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程调度 Schedulers
    &lt;ul&gt;
      &lt;li&gt;immediate() 现在在哪个线程上就使用这个线程/ single() 可复用线程 / newSingle() 新启一个线程&lt;/li&gt;
      &lt;li&gt;elastic() 缓存的线程池上操作60s后会回收/ parallel() 创建和CPU线程相同数量的线程，不会被回收 / newParallel() 新建一个线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;错误处理
    &lt;ul&gt;
      &lt;li&gt;onError / onErrorReturn 错误之后返回特定值/ onErrorResume 用一段Lambda来做处理&lt;/li&gt;
      &lt;li&gt;doOnError / doFinally&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tonydz0523/article/details/107861620&quot; target=&quot;_blank&quot;&gt; Schedule，subscribeOn和publishOn详细例子&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;实际案例&quot;&gt;实际案例&lt;/h3&gt;

&lt;p&gt;pom文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;reactor-core&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主程序&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  Flux.range(1, 6)
      .doOnRequest(n -&amp;gt; log.info(&quot;Request {} number&quot;, n)) // 注意顺序造成的区别
      .doOnComplete(() -&amp;gt; log.info(&quot;Publisher COMPLETE 1&quot;))
    //.publishOn(Schedulers.elastic())
      .map(i -&amp;gt; {
        log.info(&quot;Publish {}, {}&quot;, Thread.currentThread(), i);
        return 10 / (i - 3);
//					return i;
      })
      .doOnComplete(() -&amp;gt; log.info(&quot;Publisher COMPLETE 2&quot;))
//				.subscribeOn(Schedulers.single())
//				.onErrorResume(e -&amp;gt; {
//					log.error(&quot;Exception {}&quot;, e.toString());
//					return Mono.just(-1);
//				})
//				.onErrorReturn(-1)
      .subscribe(i -&amp;gt; log.info(&quot;Subscribe {}: {}&quot;, Thread.currentThread(), i),
          e -&amp;gt; log.error(&quot;error {}&quot;, e.toString()),
          () -&amp;gt; log.info(&quot;Subscriber COMPLETE&quot;)//,
//						s -&amp;gt; s.request(4)
      );
  Thread.sleep(2000);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先创建了Flux 1到6的序列，在每次请求Request 答应了每次请求多少的日志，在打印结束之后打印一个Publisher COMPLETE 1，map可以实现元素转换，
打印当前线程。第二个doOnComplete是打印在哪个线程上面，之后有一个subscribe动作，显示&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public final Disposable subscribe(@Nullable Consumer&amp;lt;? super T&amp;gt; consumer, @Nullable Consumer&amp;lt;? super Throwable&amp;gt; errorConsumer, @Nullable Runnable completeConsumer) {
  return this.subscribe(consumer, errorConsumer, completeConsumer, (Consumer)null);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示在消费，错误和完成之后做怎样的处理，在源码中也有&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public final Disposable subscribe(@Nullable Consumer&amp;lt;? super T&amp;gt; consumer, @Nullable Consumer&amp;lt;? super Throwable&amp;gt; errorConsumer, @Nullable Runnable completeConsumer, @Nullable Consumer&amp;lt;? super Subscription&amp;gt; subscriptionConsumer) {
    return (Disposable)this.subscribeWith(new LambdaSubscriber(consumer, errorConsumer, completeConsumer, subscriptionConsumer));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;多了一个在backPressure中做处理的元素。&lt;/p&gt;

&lt;p&gt;取消了以上的代码的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.publishOn(Schedulers.elastic())&lt;/code&gt;就表示在elastic线程池中执行，打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.subscribeOn(Schedulers.single())&lt;/code&gt;中的代码，就会使订阅在single线程上&lt;/p&gt;

&lt;p&gt;对于错误的返回，在map中写入错误，取消掉onErrorReturn的注释，里面传入的是发生错误时返回的默认值。如果希望有代码处理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onErrorResume&lt;/code&gt;简单打印。&lt;/p&gt;

&lt;p&gt;怎样做backPresure
取消注释中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s -&amp;gt; s.request(4)&lt;/code&gt;每次取回四个，所以public没有onComplete，注意这里需要将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.publishOn(...)&lt;/code&gt;挪到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flux.range(...)&lt;/code&gt;的第一个位置，否则会直接先抓出最多的可publish个数再到指定线程里面操作，打印的结果就不是原来的4个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在没进行subscribe之前是不会对其内容有任何操作，以map为例，其实只是onAsmably封装，没有实际触发&lt;/p&gt;

&lt;p&gt;这里只是简单介绍了如何使用reactive的响应式风格，具体的理解和其中的属性的作用可以看这篇文章
&lt;a href=&quot;https://developer.ibm.com/zh/articles/j-cn-with-reactor-response-encode/&quot; target=&quot;_blank&quot;&gt;java响应式&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;reactive-对redis的支持&quot;&gt;Reactive 对redis的支持&lt;/h3&gt;
&lt;p&gt;Reactive其实也支持RDBC但是可能现在功能不是很完善
Jedis客户端不支持Reactive方式，如果要用redis最好使用Lettuce客户端&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ReactiveRedisConnection&lt;/li&gt;
  &lt;li&gt;ReactiveRedisConnectionFactory&lt;/li&gt;
  &lt;li&gt;ReactiveRedisTemplate
    &lt;ul&gt;
      &lt;li&gt;opsForXxx()
和直接使用不同的是这里返回的是Mono或者Flux&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pom文件自动生成可以在start.spring里点击reactive.redis支持&lt;/li&gt;
  &lt;li&gt;在配置model的时候不再需要JPA支持也就是@Table等，有@Data和@Builder即可&lt;/li&gt;
  &lt;li&gt;需要自己在主程序中定义一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reactiveRedisTemplate&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveStringRedisTemplate&lt;/code&gt;类型的，SpringBoot自动的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object Object&lt;/code&gt;类型的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisTemplate&lt;/code&gt;，&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
ReactiveStringRedisTemplate reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
    return new ReactiveStringRedisTemplate(factory);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisConnectionFactory&lt;/code&gt;中只有Lettuce实现，其中需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisConnection&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisClusterConnection&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;aop打印数据访问层&quot;&gt;AOP打印数据访问层&lt;/h2&gt;

&lt;p&gt;applicationContext概念在Web章节说明
&lt;img src=&quot;/img/java-spring/chapter4-aop.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;

&lt;p&gt;AOP中对于事务的增强，定义是在@EnableTranscationManagement中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxyTargetClass&lt;/code&gt;制定了代理的形式，是Cglib还是基于接口，但是没有实现细节，实现是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProxyTransactionConfiguration&lt;/code&gt;中实现的
其中定义了一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TransactionIntersepter&lt;/code&gt;是一个拦截器，implement了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MethodInterceptor&lt;/code&gt;是实现Spring Around类型的Advice&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@FunctionalInterface
public interface MethodInterceptor extends Interceptor {
  Object invoke(MethodInvocation var1) throws Throwable;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现了一个invoke，但是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TransactionIntersepter&lt;/code&gt;中执行这个invoke方法是执行了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeWithinTransaction&lt;/code&gt;中实现了事务性的代码，这个方法是在不使用trasactionManager的基础上实现了事务的封装。&lt;/p&gt;

&lt;h3 id=&quot;实践&quot;&gt;实践&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;常用注解
    &lt;ul&gt;
      &lt;li&gt;@EnableAspectJAutoProxy 对有@Aspect注解的类做支持&lt;/li&gt;
      &lt;li&gt;@Aspect 声明为一个切面 &lt;strong&gt;光写@Aspect还不能变成一个Bean要么使用JavaConfig要么增加@Component注解&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;@Pointcut&lt;/li&gt;
      &lt;li&gt;@Before 在方法执行前执行&lt;/li&gt;
      &lt;li&gt;@After 方法执行之后执行 / @AfterReturning 方法执行成功之后执行/ @AfterThrowing 方法执行失败之后执行&lt;/li&gt;
      &lt;li&gt;@Around 环绕通知 有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProceedingJoinPoint&lt;/code&gt;参数，其中有一个proceed方法可回调原有目标对象的方法&lt;/li&gt;
      &lt;li&gt;@Order 切面的执行顺序，数字越小优先级就越高&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Spring 官方文档中的定义，在写@Pointcut中的正则表达的时候可以看。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Pointcut常用的正则表达
    &lt;ul&gt;
      &lt;li&gt;@Pointcut(“execution(* geektime.spring.springbucks.repository..*(..))”)&lt;/li&gt;
      &lt;li&gt;execution用于匹配是连接点执行的方法&lt;/li&gt;
      &lt;li&gt;
        &lt;ul&gt;
          &lt;li&gt;表示任意返回方法的类型&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;geektime.spring.springbucks.repository是全限定类名&lt;/li&gt;
      &lt;li&gt;全限定类名之后可以接类中的方法名&lt;/li&gt;
      &lt;li&gt;(..)表示匹配任意参数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何打印SQL
    &lt;ul&gt;
      &lt;li&gt;HikariCP P6SQL，https://github.com/p6spy/p6spy&lt;/li&gt;
      &lt;li&gt;Druid  https://github.com/alibaba/druid/wiki/Druid中使⽤用log4j2进⾏日志输出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;拦截器的demo讲解&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;pom文件中&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;p6spy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;p6spy&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;使用p6spy后不能使用Spring自己的数据库，转而使用插入p6spy作为数据库的增强具体实现在integrating p6spy中，&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver
spring.datasource.url=jdbc:p6spy:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;在resources文件夹下配置一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spy.properties&lt;/code&gt;的文件根据&lt;a href=&quot;https://p6spy.readthedocs.io/en/latest/configandusage.html&quot; target=&quot;_blank&quot;&gt;属性文档&lt;/a&gt;
中的内容来配置&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;# 单行日志
logMessageFormat=com.p6spy.engine.spy.appender.SingleLineFormat
# 使用Slf4J记录sql
appender=com.p6spy.engine.spy.appender.Slf4JLogger
# 是否开启慢SQL记录
outagedetection=true
# 慢SQL记录标准，单位秒
outagedetectioninterval=2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;配置modal文件
因为会产生lombok产生的id字段不匹配现象，最好配置@EqualsAndHashCode&lt;strong&gt;使用@Data时同时加上@EqualsAndHashCode(callSuper=true)注解。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对Repository做增强&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect // 说明是切面
@Component // 定义为Bean
@Slf4j
public class PerformanceAspect {
//    @Around(&quot;execution(* geektime.spring.springbucks.repository..*(..))&quot;)
    @Around(&quot;repositoryOps()&quot;)
    public Object logPerformance(ProceedingJoinPoint pjp) throws Throwable {
        long startTime = System.currentTimeMillis();
        String name = &quot;-&quot;;
        String result = &quot;Y&quot;; // 正确返回 Y
        try {
            name = pjp.getSignature().toShortString();//获得对象的方法
            return pjp.proceed(); //调用对象
        } catch (Throwable t) {
            result = &quot;N&quot;; // 错误返回N
            throw t;
        } finally {
            long endTime = System.currentTimeMillis();
            log.info(&quot;{};{};{}ms&quot;, name, result, endTime - startTime); // 显示Repository执行耗时
        }
    }

    @Pointcut(&quot;execution(* geektime.spring.springbucks.repository..*(..))&quot;)
    private void repositoryOps() {
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要记得在主程序上写@EnableAspectjAutoProxy在最主要的案例中因为run方法过长直接分为两个方法来执行了&lt;/p&gt;

&lt;h1 id=&quot;chapter5-spring-mvc实战&quot;&gt;Chapter5 Spring MVC实战&lt;/h1&gt;

&lt;h2 id=&quot;spring-mvc核心内容就是&quot;&gt;Spring MVC核心内容就是&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DispatcherServlet是一个入口
    &lt;ul&gt;
      &lt;li&gt;Controller 每一个请求的处理逻辑&lt;/li&gt;
      &lt;li&gt;xxxResolver 各种解析器
        &lt;ul&gt;
          &lt;li&gt;ViewResolver&lt;/li&gt;
          &lt;li&gt;HandlerExceptionResolver&lt;/li&gt;
          &lt;li&gt;MultipartResolver&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HandlerMapping 处理请求怎样映射&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring MVC中的常用注解
    &lt;ul&gt;
      &lt;li&gt;@Controller 定义一个控制器
        &lt;ul&gt;
          &lt;li&gt;@RestController &lt;strong&gt;@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;@RequestMapping 定义controller处理哪些请求，指定url的path，也可以指定http method或指定消费哪些content-type内容&lt;strong&gt;可以定义在方法上面也可以定义在类上&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;@GetMapping / @PostMapping&lt;/li&gt;
          &lt;li&gt;@PutMapping / @DeleteMapping&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;requestMapping使用事项，在定义在类上的时候&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestMapping(&quot;/coffee&quot;)&lt;/code&gt;就表示这个类中定义的路径的基础就是/coffee/&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;用 @Controller时&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@GetMapping(&quot;/&quot;)
@ResponseBody
public List&amp;lt;Coffee&amp;gt; getAll() {
    return coffeeService.getAllCoffee();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;以上的代码定义在类中，定义的getAll方法直接作为结果返回到responsebody中&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;另一种使用@RestController的格式&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(&quot;/&quot;)
@ResponseStatus(HttpStatus.CREATED)
public CoffeeOrder create(@RequestBody NewOrderRequest newOrder) {
    log.info(&quot;Receive new Order {}&quot;, newOrder);
    Coffee[] coffeeList = coffeeService.getCoffeeByName(newOrder.getItems())
            .toArray(new Coffee[] {});// 调用实例，做成数组
    return orderService.createOrder(newOrder.getCustomer(), coffeeList);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;@RequestBody 对应请求的报文  / @ResponseBody 响应的报文/ @ResponseStatus 指定请求码 @ResponseState可以用在方法前或者类前有不同参数。
&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ResponseStatus(HttpStatus.CREATED)&lt;/code&gt;用在方法前表示请求码注解中有两个参数，value属性设置异常的状态码，reaseon是异常的描述。&lt;/strong&gt;
&lt;a href=&quot;https://blog.51cto.com/4837471/2327327&quot; target=&quot;_blank&quot;&gt;常用的HttpStatus状态&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上面使用了@PostMapping的案例来说，定义了@RequestBody 是NewOrderRequest这个是自己定义的一个类，做了一个实例&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Getter
@Setter
@ToString
public class NewOrderRequest {
    private String customer;
    private List&amp;lt;String&amp;gt; items;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;postman-的-web请求&quot;&gt;postman 的 web请求&lt;/h3&gt;
&lt;h3 id=&quot;application-context-spring-的应用程序上下文&quot;&gt;Application context Spring 的应用程序上下文&lt;/h3&gt;
&lt;p&gt;管理组件的生命周期，依赖注入，上下文的接口BeanFactory等。基于注解的配置。一般不会用BeanFactory。对于BeanFactoryPostProcessor和BeanPostProcessor的扩展点会在低版本Spring实现高版本的Spring配置时会学到。&lt;/p&gt;
&lt;h3 id=&quot;web上下文层次&quot;&gt;Web上下文层次&lt;/h3&gt;
&lt;p&gt;Servlet WebApplicationContext(controllers viewResolver handler mapping)中的继承Root WebApplicationContext(services, repository)中的内容，如果做AOP增强记得要写在Root WebApplicationContext中！&lt;/p&gt;

&lt;h3 id=&quot;web层上下文&quot;&gt;web层上下文&lt;/h3&gt;
&lt;p&gt;ContextHierarchy首先定义了情景，父子上下文增强。是在课程40的内容，主要演示了在父子上下文中是否定义切面&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先定义切面&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Aspect
@Slf4j
public class FooAspect {
    @AfterReturning(&quot;bean(testBean*)&quot;)
    public void printAfter() {
        log.info(&quot;after hello()&quot;);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示拦截以testBean打头的bean，在return之后打印。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义TestBean表示传入一个context就知道是在哪里使用了这个Bean&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@AllArgsConstructor
@Slf4j
public class TestBean {
    private String context;

    public void hello() {
        log.info(&quot;hello &quot; + context);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@AllArgsConstructor
使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数
@NoArgsConstructor
使用后创建一个无参构造函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义配置类和切面&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Configuration
@EnableAspectJAutoProxy
public class FooConfig {
  @Bean
  public TestBean testBeanX() {
      return new TestBean(&quot;foo&quot;);
  }

  @Bean
  public TestBean testBeanY() {
      return new TestBean(&quot;foo&quot;);
  }

  @Bean
  public FooAspect fooAspect() {
    //实现切面
      return new FooAspect();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方法的主类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  ApplicationContext fooContext = new AnnotationConfigApplicationContext(FooConfig.class);
  ClassPathXmlApplicationContext barContext = new ClassPathXmlApplicationContext(
      new String[] {&quot;applicationContext.xml&quot;}, fooContext);//读入自定义的barContext这个里面定义了一个textBeanX 并且 申明fooContext是上级context
  TestBean bean = fooContext.getBean(&quot;testBeanX&quot;, TestBean.class);// 检查输出是否增强
  bean.hello();

  log.info(&quot;=============&quot;);

  bean = barContext.getBean(&quot;testBeanX&quot;, TestBean.class);
  bean.hello();

  bean = barContext.getBean(&quot;testBeanY&quot;, TestBean.class);
  bean.hello();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显示的结果是，在foo(父)上下文中增强过的Bean在子context调用的时候仍能增强，但是子context中没有声明增强的xml文件不能增强，同理如果在foo中删除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fooAspect&lt;/code&gt;这个方法就不能增强。如果要同时增强父子，可以开启AOP增强&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aop:aspectj-autoproxy&lt;/code&gt;表示在写入xml的地方也开启了增强。&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc的请求处理机制&quot;&gt;Spring MVC的请求处理机制&lt;/h2&gt;
&lt;p&gt;⼀个请求的⼤致处理流程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;绑定一些 Attribute
    &lt;ul&gt;
      &lt;li&gt;WebApplicationContext / LocaleResolver / ThemeResolver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理理 Multipart
    &lt;ul&gt;
      &lt;li&gt;如果是，则将请求转为 MultipartHttpServletRequest&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Handler 处理理
    &lt;ul&gt;
      &lt;li&gt;如果找到对应 Handler，执行 Controller 及前后置处理器逻辑&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何定义一个controller&quot;&gt;如何定义一个Controller&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;@Controller&lt;/li&gt;
  &lt;li&gt;@RequestMapping
    &lt;ul&gt;
      &lt;li&gt;path / method 指定映射路路径与⽅方法&lt;/li&gt;
      &lt;li&gt;params / headers 限定映射范围 一般在使用@RequestParam的时候不需要加上这个，但是如果是严格的路径一定要加上限制的params或者headers
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GetMapping(path = &quot;/&quot;, params=&quot;!name&quot;)&lt;/code&gt;表示，使用get请求，在url中没有其他string的url&lt;/li&gt;
      &lt;li&gt;consumes 只接受特定content-type的内容  / produces 只接受特定的响应格式特定的accept头,consumes和produces可以多个获得。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些快捷⽅方式
    &lt;ul&gt;
      &lt;li&gt;@RestController @Controller和@ResponseBody结合&lt;/li&gt;
      &lt;li&gt;@GetMapping / @PostMapping / @PutMapping / @DeleteMapping / @PatchMapping&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定义处理方法
    &lt;ul&gt;
      &lt;li&gt;@RequestBody 请求正文/ @ResponseBody 响应正文将java对象转化为json格式/ @ResponseStatus 响应的Http返回码&lt;/li&gt;
      &lt;li&gt;表示url路径上的变量@PathVariable / @RequestParam使用特定格式的响应标注参数不能为空 / @RequestHeader uri路径上的变量&lt;/li&gt;
      &lt;li&gt;HttpEntity 参数中可接受的/ ResponseEntity 响应中的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各种定义的具体处理形式可以从以下两个文档中找到对应的&lt;a href=&quot;https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-arguments&quot; target=&quot;_blank&quot;&gt; 发送&lt;/a&gt;和&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-return-types&quot; target=&quot;_blank&quot;&gt;响应&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对@ResponseBody的作用可以看&lt;a href=&quot;https://www.cnblogs.com/qiankun-site/p/5774325.html&quot; target=&quot;_blank&quot;&gt;@ResponseBody作用&lt;/a&gt;将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先需要了解的是@RequestBody可以这样定义,该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；
&lt;strong&gt;@RequestBody的作用是修改content-type不是application/x-www-form-urlcoded编码的内容&lt;a href=&quot;https://blog.csdn.net/qq_38408785/article/details/89887748&quot; target=&quot;_blank&quot;&gt; @RequestBody作用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@GetMappig(&quot;/insert&quot;)
@ResponseBody
public Map&amp;lt;String, Object&amp;gt; requestParam(
  @RequestParam(&quot;int_val&quot;) Integer intVal,
  @RequestParam(&quot;long_val&quot;) Long longVal,
  @RequestParam(&quot;str_val&quot;, required=false) String strVal// 这里设置了required为false表示可以设置为空值
){
  Map&amp;lt;String, Object&amp;gt; paramsMap = new HashMap&amp;lt;&amp;gt;();
  paramsMap.put(&quot;intVal&quot;,intVal);
  paramsMap.put(&quot;longVal&quot;,longVal);
  paramsMap.put(&quot;strVal&quot;,strVal);

  return paramsMap;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这之中post和get请求都是需要在实现的时候多加注意的。多种传递参数的方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;无注解的&lt;/li&gt;
  &lt;li&gt;@RequestParam 前后端参数映射的关系&lt;/li&gt;
  &lt;li&gt;数组传递&lt;/li&gt;
  &lt;li&gt;JSON传递&lt;/li&gt;
  &lt;li&gt;URL传递参数的方式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GetMapping(&quot;/{id}&quot;)&lt;/code&gt;之后在方法需要传入的变量中dingyi&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public User get(@PathVariable(&quot;id&quot;) Long id){...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;定义类型转换&quot;&gt;定义类型转换&lt;/h2&gt;
&lt;p&gt;⾃己实现 WebMvcConfigurer
Spring Boot 在 WebMvcAutoConfiguration 中实现了一个 添加⾃自定义的 Converter: 作为一个一对一转换器，从一种类型转化到另外一种类型接口定义
添加自定义的 Formatter&lt;/p&gt;

&lt;h3 id=&quot;formatter-使用样例&quot;&gt;Formatter 使用样例&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
public class MoneyFormatter implements Formatter&amp;lt;Money&amp;gt; {
  /**
    * 处理 CNY 10.00 / 10.00 形式的字符串
    * 校验不太严密，仅作演示
    */
  @Override
  public Money parse(String text, Locale locale) throws ParseException {
    if (NumberUtils.isParsable(text)) {
        return Money.of(CurrencyUnit.of(&quot;CNY&quot;), NumberUtils.createBigDecimal(text));
    } else if (StringUtils.isNotEmpty(text)) {
        String[] split = StringUtils.split(text, &quot; &quot;);
        if (split != null &amp;amp;&amp;amp; split.length == 2 &amp;amp;&amp;amp; NumberUtils.isParsable(split[1])) {
            return Money.of(CurrencyUnit.of(split[0]),
                    NumberUtils.createBigDecimal(split[1]));
        } else {
            throw new ParseException(text, 0);
        }
    }
    throw new ParseException(text, 0);
  }

  @Override
  public String print(Money money, Locale locale) {
      if (money == null) {
          return null;
      }
      return money.getCurrencyUnit().getCode() + &quot; &quot; + money.getAmount();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码定义，首先通过@Component自动注册为Bean，对输入的内容做BigDecimal转换，之后通过判断输入的是否为空或者是CNY 10 还是直接输入10 作为 金钱单位，这里不是很精确。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Locale&lt;/code&gt;是国际化的常用单位，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NumberUtils.isParsable&lt;/code&gt;的原理是逐个字符判断是否为数字，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NumberUtils&lt;/code&gt;还有其他用法如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCreatable&lt;/code&gt;是判断字符串能否转化为Java可识别的数字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意pom引入Apatch的commons.lang&lt;/strong&gt;
&lt;strong&gt;throw:一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常&lt;/strong&gt;
&lt;strong&gt;throws:当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理&lt;/strong&gt;
&lt;strong&gt;如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;定义校验&quot;&gt;定义校验&lt;/h2&gt;
&lt;p&gt;通过 Validator 对绑定结果进行校验
Hibernate Validator
@Valid 注解 
通过返回BindingResult实现最后结果。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addCoffeeWithoutBindingResult(@Valid NewCoffeeRequest newCoffee) {
    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;没有加上@RequestBody 是因为会将请求正文变成对象传入， consumes表示处理的数据形式，这里是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APPLICATION_FORM_URLENCODED_VALUE&lt;/code&gt;表示处理表单，因为path对应多个controller所以要写consumes;这里的NewCoffeeRequest是帮助在读入数据之前对数据的检查可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.validation.constraints.NotNull&lt;/code&gt;甚至里面可以使用正则表达。其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.validation.constraints.NotEmpty&lt;/code&gt;和NotNull区别是NotEmpty还要保证输入的不为空字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要mediaType对应的类型APPLICATION_JSON_UTF8_VALUE是application/json;charset=UTF-8&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,
                        BindingResult result) {
    if (result.hasErrors()) {
        // 这里先简单处理一下，后续讲到异常处理时会改
        log.warn(&quot;Binding Errors: {}&quot;, result);
        return null;
    }
    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于出现的异常通过BindingResult实现转换，错误返回null，详细内容需要看错误处理章节。&lt;/p&gt;
&lt;h2 id=&quot;multipart-上传-文件上传&quot;&gt;Multipart 上传 文件上传&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;配置 MultipartResolver
    &lt;ul&gt;
      &lt;li&gt;Spring Boot ⾃动配置 MultipartAutoConfiguration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;支持类型 multipart/form-data&lt;/li&gt;
  &lt;li&gt;MultipartFile 类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public List&amp;lt;Coffee&amp;gt; batchAddCoffee(@RequestParam(&quot;file&quot;) MultipartFile file) {
  List&amp;lt;Coffee&amp;gt; coffees = new ArrayList&amp;lt;&amp;gt;();
  if (!file.isEmpty()) {
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new InputStreamReader(file.getInputStream()));
      String str;
      while ((str = reader.readLine()) != null) {
        String[] arr = StringUtils.split(str, &quot; &quot;);
        if (arr != null &amp;amp;&amp;amp; arr.length == 2) {
          coffees.add(coffeeService.saveCoffee(arr[0],
                  Money.of(CurrencyUnit.of(&quot;CNY&quot;),
                          NumberUtils.createBigDecimal(arr[1]))));
        }
      }
    } catch (IOException e) {
        log.error(&quot;exception&quot;, e);
    } finally {
        IOUtils.closeQuietly(reader);
    }
  }
  return coffees;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解释，通过@RequestParam获得file，通过BufferedReader，再通过空格分开，最后再对reader做一个关闭。在postman中操作的时候需要选择文件上传。&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc-视图解析相关&quot;&gt;Spring MVC 视图解析相关&lt;/h2&gt;

&lt;h3 id=&quot;视图解析的基础实现&quot;&gt;视图解析的基础实现&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ViewResolver 与 View 接⼝
    &lt;ul&gt;
      &lt;li&gt;AbstractCachingViewResolver&lt;/li&gt;
      &lt;li&gt;UrlBasedViewResolver&lt;/li&gt;
      &lt;li&gt;FreeMarkerViewResolver&lt;/li&gt;
      &lt;li&gt;ContentNegotiatingViewResolver 可以接受的返回类型选择合适的响应&lt;/li&gt;
      &lt;li&gt;InternalResourceViewResolver 放在解析链最后的解析器 处理JSP JSTL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dispatcherservlet-中的视图解析逻辑&quot;&gt;DispatcherServlet 中的视图解析逻辑&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;initStrategies()
    &lt;ul&gt;
      &lt;li&gt;initViewResolvers() 初始化了了对应 ViewResolver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;doDispatch()
    &lt;ul&gt;
      &lt;li&gt;processDispatchResult()
        &lt;ul&gt;
          &lt;li&gt;没有返回视图的话，尝试 RequestToViewNameTranslator&lt;/li&gt;
          &lt;li&gt;resolveViewName() 解析 View 对象&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使⽤用 @ResponseBody 的情况
    &lt;ul&gt;
      &lt;li&gt;在 HandlerAdapter.handle() 的中完成了了 Response 输出
        &lt;ul&gt;
          &lt;li&gt;RequestMappingHandlerAdapter.invokeHandlerMethod()
            &lt;ul&gt;
              &lt;li&gt;HandlerMethodReturnValueHandlerComposite.handleReturnValue()
                &lt;ul&gt;
                  &lt;li&gt;RequestResponseBodyMethodProcessor.handleReturnValue()&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;重定向&quot;&gt;重定向&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;redirect: 客户端发起，url有变化，而且会丢失request信息&lt;/li&gt;
  &lt;li&gt;forward：服务端发起，浏览器url无变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-mvc-常用视图&quot;&gt;Spring MVC 常用视图&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Jackson-based JSON / XML&lt;/li&gt;
  &lt;li&gt;Thymeleaf &amp;amp; FreeMarke
&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-view&quot; target=&quot;_blank&quot;&gt;常见视图官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置message-converter&quot;&gt;配置Message Converter&lt;/h3&gt;

&lt;p&gt;通过WebMvcCOnfigurer 中的 ConfigureMessageConverters() 在 Spring Boot 自动查找 HttpMessageConverters 进行注册&lt;/p&gt;

&lt;h3 id=&quot;spring-boot-对-jackson-的支持&quot;&gt;Spring Boot 对 Jackson 的⽀支持&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JacksonAutoConfiguration
    &lt;ul&gt;
      &lt;li&gt;Spring Boot 通过 @JsonComponent 注册 JSON 序列列化组件，作用于JackJson模块上也就是在例子的主程序中定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hibernate5Module&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Jackson2ObjectMapperBuilderCustomizer 定义返回类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JacksonHttpMessageConvertersConfiguration
    &lt;ul&gt;
      &lt;li&gt;增加 jackson-dataformat-xml 以支持 XML 序列列化
这个通过JacksonHttpMessageConvertersConfiguration实现的就是通过给响应序列化和反序列化对请求和响应内容做精简，同时也能对Hibernate做优化，比如在Termianl中需要显示响应信息可以通过Jacksonjson实现缩进&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;!-- 增加Jackson的Hibernate类型支持 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jackson-datatype-hibernate5&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.9.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 增加Ja ckson XML支持 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.fasterxml.jackson.dataformat&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jackson-dataformat-xml&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在之后的需要对数据进行序列化和反序列化&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//序列化
@JsonComponent
public class MoneySerializer extends StdSerializer&amp;lt;Money&amp;gt; {
  protected MoneySerializer() {
      super(Money.class);
  }

  @Override
  public void serialize(Money money, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
      jsonGenerator.writeNumber(money.getAmount());
  }
}

// 反序列化
@JsonComponent
public class MoneyDeserializer extends StdDeserializer&amp;lt;Money&amp;gt; {
    protected MoneyDeserializer() {
        super(Money.class);
    }

    @Override
    public Money deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        return Money.of(CurrencyUnit.of(&quot;CNY&quot;), p.getDecimalValue());
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在最终的实现格式是在主程序中&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public Hibernate5Module hibernate5Module() {
  return new Hibernate5Module();
}

@Bean
public Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer() {//作用接口的内部匿名实现类
  return builder -&amp;gt; builder.indentOutput(true);//实现缩进
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hibernate5Module&lt;/code&gt;是JackJson的模块，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jackson2ObjectMapperBuilderCustomizer&lt;/code&gt;是用来实现缩进的
在controller中需要修改的地方是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path=&quot;/&quot;, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addCoffeeWithoutBinding(@Valid  @RequestBody NewCoffeeRequest coffeeRequest){
  return coffeeService.saveCoffee(coffeeRequest.getName(), coffeeRequest.getPrice());
}
...
@GetMapping(path = &quot;/{id}&quot;)
@ResponseBody
public Coffee getById(@PathVariable Long id){
  return coffeeService.getCoffee(id);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getById方法可以返回json对象，并且是对这个懒加载对象的方式的的文件格式没有要求，因为没有加上consumer。&lt;/p&gt;

&lt;h2 id=&quot;spring-常见模板引擎&quot;&gt;Spring 常见模板引擎&lt;/h2&gt;
&lt;h3 id=&quot;添加-thymeleaf-依赖&quot;&gt;添加 Thymeleaf 依赖&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使⽤用 Thymeleaf
    &lt;ul&gt;
      &lt;li&gt;org.springframework.boot:spring-boot-starter-thymeleaf&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Boot 的⾃自动配置
    &lt;ul&gt;
      &lt;li&gt;ThymeleafAutoConfiguration&lt;/li&gt;
      &lt;li&gt;ThymeleafViewResolver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thymeleaf-的一些默认配置&quot;&gt;Thymeleaf 的⼀一些默认配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;spring.thymeleaf.cache=true  模板默认是加载一次后不会再加载了，如果开发环境中需要加载，所以，在开发时需要设置为false
&lt;strong&gt;提醒：如果是噻idea中，编辑的地方是src的source模块下，但是实际应用的目录是在target下的&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.check-template=true  是否校验模板&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.check-template-location=true 是否要检查模板位置&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.enabled=true&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.encoding=UTF-8&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.mode=HTML&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.servlet.content-type=text/html&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.prefix=classpath:/templates/ 模板前缀&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.suffix=.html 模板后缀&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thymeleaf使用案例&quot;&gt;Thymeleaf使用案例&lt;/h3&gt;
&lt;p&gt;controller的修改，不再只用@RestController而是使用@Controller，并且给每个方法都增加了@ResponseBody注解&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结，Thymeleaf已经不太适用于做大前端的服务项目，例如静态资源等可以通过Nginx来代替做静态资源缓存&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;静态资源与缓存spring中其实不太建议使用静态资源缓存了&quot;&gt;静态资源与缓存（spring中其实不太建议使用静态资源缓存了）&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;核⼼心逻辑
    &lt;ul&gt;
      &lt;li&gt;WebMvcConfigurer.addResourceHandlers()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常⽤用配置
    &lt;ul&gt;
      &lt;li&gt;spring.mvc.static-path-pattern=/**&lt;/li&gt;
      &lt;li&gt;spring.resources.static-locations=classpath:/META-INF/ 
resources/,classpath:/resources/,classpath:/static/,classpath:/public/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存配置常⽤用配置(默认时间单位都是秒)
    &lt;ul&gt;
      &lt;li&gt;ResourceProperties.Cache&lt;/li&gt;
      &lt;li&gt;spring.resources.cache.cachecontrol.max-age=时间 最大缓存时间默认单位是秒&lt;/li&gt;
      &lt;li&gt;spring.resources.cache.cachecontrol.no-cache=true/false&lt;/li&gt;
      &lt;li&gt;spring.resources.cache.cachecontrol.s-max-age=时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不建议使用缓存在controller中使用，可以在拦截器中使用缓存&lt;/p&gt;

&lt;h2 id=&quot;spring中的异常处理机制&quot;&gt;Spring中的异常处理机制&lt;/h2&gt;

&lt;h3 id=&quot;核心接口&quot;&gt;核心接口&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HandlerExceptionResolver
    &lt;h3 id=&quot;实现类&quot;&gt;实现类&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;SimpleMappingExceptionResolver&lt;/li&gt;
  &lt;li&gt;DefaultHandlerExceptionResolver&lt;/li&gt;
  &lt;li&gt;ResponseStatusExceptionResolver&lt;/li&gt;
  &lt;li&gt;ExceptionHandlerExceptionResolver&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;异常处理方法&quot;&gt;异常处理方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@ExceptionHandler
    &lt;h3 id=&quot;添加位置&quot;&gt;添加位置&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;@Controller / @RestController&lt;/li&gt;
  &lt;li&gt;@ControllerAdvice / @RestControllerAdvice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在BindingResult 中的处理方式 和@ControllAdvice中的不同，在postman中的反应形式不同。&lt;/p&gt;

&lt;p&gt;BindingResult中需要定义一个@ResponseBody&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@ResponseStatus(HttpStatus.BAD_REQUEST)
@Getter
@AllArgsConstructor//使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数
public class FormValidationException extends RuntimeException {
  private BindingResult result;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个是在 BindingResult中定义result最后的返回类上的throw的new方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormValidationException&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(paht = &quot;/&quot;, consumer = MediaType.APPLICATION_JSON_UTF8_VALUE)
@ResponseStatus(HttpStatus.CREATED)
@ResponseBody
public Coffee addCoffee(@Valid NewCoffeeRequest newCoffeeRequest,
                        BindingResult result) {
  if (result.hasErrors()) {
    log.warn(&quot;Binding Errors: {}&quot;, result);
    throw new FormValidationException(result);
  }
  return coffeeService.saveCoffee(newCoffeeRequest.getName(), newCoffeeRequest.getPrice(), newCoffeeRequest.getFormCode())
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是要在@ControllerAdvice上定义错误处理函数可以见以下案例&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@RestControllerAdvice
public class GlobalControllerAdvice {
  @ExceptionHandler(ValidationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public Map&amp;lt;String, String&amp;gt; validationExceptionHandler(ValidationException exception) {
    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;message&quot;, exception.getMessage());
    return map;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相对应的定义的Controller中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValidationException&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addJsonCoffee(@Valid @RequestBody NewCoffeeRequest newCoffee,BindingResult result) {
  if (result.hasErrors()) {
      log.warn(&quot;Binding Errors: {}&quot;, result);
      throw new ValidationException(result.toString());
  }
  return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;详细的@ControllerAdvice的用法如下&lt;a href=&quot;https://www.cnblogs.com/lenve/p/10748453.html&quot; target=&quot;_blank&quot;&gt;@ControllerAdvisor&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/yanggb/p/10859907.html&quot; target=&quot;_blank&quot;&gt;@ControllerAdvisor&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc-切入点&quot;&gt;Spring MVC 切入点&lt;/h2&gt;

&lt;h3 id=&quot;spring-mvc-的拦截器器&quot;&gt;Spring MVC 的拦截器器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HandlerInteceptor
    &lt;ul&gt;
      &lt;li&gt;boolean preHandle() 预处理 返回布尔 false就终止&lt;/li&gt;
      &lt;li&gt;void postHandle() 后处理&lt;/li&gt;
      &lt;li&gt;void afterCompletion() 后处理之后的完成方法
postHandle 和 afterCompletion区别是视图呈现的区别&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;针对 @ResponseBody 和 ResponseEntity 的情况
    &lt;ul&gt;
      &lt;li&gt;ResponseBodyAdvice&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;针对异步请求的接⼝&lt;strong&gt;异步方法不会执行postHandle或者afterCompletion&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;AsyncHandlerInterceptor
        &lt;ul&gt;
          &lt;li&gt;void afterConcurrentHandlingStarted()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;拦截器的配置方法&quot;&gt;拦截器的配置方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;常规方法
    &lt;ul&gt;
      &lt;li&gt;WebMvcConfigurer.addInterceptors()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Boot 中的配置
    &lt;ul&gt;
      &lt;li&gt;创建⼀个带 @Configuration 的 WebMvcConfigurer 配置类&lt;/li&gt;
      &lt;li&gt;不能带 @EnableWebMvc(想彻底⾃己控制 MVC 配置除外)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;主程序中继承WebMvcConfigurer来实现addInterceptors方法注册PerformanceInteceptor&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class WaiterServiceApplication implements WebMvcConfigurer {
  @Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(new PerformanceInteceptor())
				.addPathPatterns(&quot;/coffee/**&quot;).addPathPatterns(&quot;/order/**&quot;);
	}
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码表示要拦截“/coffee/”所有请求的调用，以及“/order/”相关的拦截器&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;之后写入实例performanceIntercepter实例化拦截器&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class PerformanceInteceptor implements HandlerInterceptor {
  private ThreadLocal&amp;lt;StopWatch&amp;gt; stopWatch = new ThreadLocal&amp;lt;&amp;gt;();

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    StopWatch sw = new StopWatch();
    stopWatch.set(sw);
    sw.start();
    return true;
  }

  @Override
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    stopWatch.get().stop();
    stopWatch.get().start();
  }

  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    StopWatch sw = stopWatch.get();
    sw.stop();
    String method = handler.getClass().getSimpleName();
    if (handler instanceof HandlerMethod) {
      String beanType = ((HandlerMethod) handler).getBeanType().getName();
      String methodName = ((HandlerMethod) handler).getMethod().getName();
      method = beanType + &quot;.&quot; + methodName;
    }
    log.info(&quot;{};{};{};{};{}ms;{}ms;{}ms&quot;,
      request.getRequestURI(),
      method,
      response.getStatus(),
      ex == null ? &quot;-&quot; : ex.getClass().getSimpleName(),
      sw.getTotalTimeMillis(), 
      sw.getTotalTimeMillis() - sw.getLastTaskTimeMillis(),
      sw.getLastTaskTimeMillis());
    stopWatch.remove();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解释:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。&lt;/li&gt;
  &lt;li&gt;StopWatch是SpringMVC中常见的记录时间的工具&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler.getClass().getSimpleName();&lt;/code&gt;获得的是hanlder方法名也就是哪个controller来处理&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log.info&lt;/code&gt;中的内容作用是：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.getRequestURI()&lt;/code&gt;获得的是哪个URI的请求，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method&lt;/code&gt;使用的是哪个handler的哪个方法做的处理，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response.getStatus()&lt;/code&gt;获得HttpStatus，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex == null ? &quot;-&quot; : ex.getClass().getSimpleName(),&lt;/code&gt;如果有异常将异常类名打出，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sw.getTotalTimeMillis() - sw.getLastTaskTimeMillis(),&lt;/code&gt;用总耗时减去上一个节点的记录时间表示prehandle 到 posthandle的时间, 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sw.getLastTaskTimeMillis()&lt;/code&gt;posthandle 到 afterCompletion之间的耗时&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 04 Nov 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/11/04/Spring02/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/11/04/Spring02/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>WebFlux</category>
        
        <category>Project Reactor</category>
        
        <category>Spring MVC</category>
        
        <category>NoSql</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Docker教程 </title>
        <description>&lt;p&gt;Docker&lt;/p&gt;
&lt;h1 id=&quot;查看&quot;&gt;查看&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;docker ps 查看正在运行的容器&lt;/li&gt;
  &lt;li&gt;docker ps -a 查看所有容器
    &lt;h1 id=&quot;创建并启动&quot;&gt;创建并启动&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;docker run 参数-i 保持docker运行 常于-t 一起使用
    &lt;ul&gt;
      &lt;li&gt;-t将容器分配入伪终端&lt;/li&gt;
      &lt;li&gt;-d以守护后台方式维护容器 以docker exec 进入容器 退出后容器不会关闭&lt;/li&gt;
      &lt;li&gt;-it 交互式容器 -id守护式容器&lt;/li&gt;
      &lt;li&gt;—name为容器创建名字&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;删除镜像 docker rmi 镜像名&lt;/li&gt;
  &lt;li&gt;删除容器 docker rm 容器名&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;镜像&quot;&gt;镜像&lt;/h1&gt;

&lt;h2 id=&quot;查看本地所有镜像&quot;&gt;查看本地所有镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker images
    &lt;ul&gt;
      &lt;li&gt;docker images -p // 查看镜像id&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;查找所需镜像&quot;&gt;查找所需镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker search 查找镜像名 如redis&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;拉取镜像&quot;&gt;拉取镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker pull 镜像名&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;删除镜像&quot;&gt;删除镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker rmi 镜像id&lt;/li&gt;
  &lt;li&gt;docker rmi ‘docker images -q’删除本地所有镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;容器的启动&quot;&gt;容器的启动&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;docker run&lt;/li&gt;
  &lt;li&gt;docker start/stop &lt;容器器名&gt;&lt;/容器器名&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker ps &lt;容器器名&gt; docker logs &lt;容器器名&gt;&lt;/容器器名&gt;&lt;/容器器名&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run 的常⽤用选项 
&lt;strong&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG…]&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;-d，后台运⾏行行容器器&lt;/li&gt;
      &lt;li&gt;-e，设置环境变量量&lt;/li&gt;
      &lt;li&gt;–expose / -p 宿主端⼝:容器器端⼝&lt;/li&gt;
      &lt;li&gt;–name，指定容器器名称&lt;/li&gt;
      &lt;li&gt;–link，链接不不同容器&lt;/li&gt;
      &lt;li&gt;-v 宿主⽬目录:容器器⽬目录，挂载磁盘卷&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;exec 容器id进入容器 退出时不会关闭
eg. docker exec -it Rea /bin/bash 进入容器&lt;/li&gt;
  &lt;li&gt;exit 之后不会关闭&lt;/li&gt;
  &lt;li&gt;docker start 容器名&lt;/li&gt;
  &lt;li&gt;docker run 创建并启动容器 eg. docker run -it –name=RRea redis:latest /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;docker-删除容器&quot;&gt;docker 删除容器&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;docker rm ’docker ps -aq’ 删除所有容器
开启中的容器不能删除&lt;/li&gt;
  &lt;li&gt;docker stop 容器名 停止&lt;/li&gt;
  &lt;li&gt;docker inspect 容器名 查看容器信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;容器的数据卷-一个文件和根目录&quot;&gt;容器的数据卷 （一个文件和根目录）&lt;/h1&gt;

&lt;h2 id=&quot;数据卷解决的问题-&quot;&gt;数据卷解决的问题 ：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;容器删除后 里面的文件还存在吗？ 不在&lt;/li&gt;
  &lt;li&gt;docker容器可以和外部机器交换文件吗？ 不能&lt;/li&gt;
  &lt;li&gt;两个容器之间怎么交互数据？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数据卷概念&quot;&gt;数据卷概念：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;数据卷是宿主机中的一个目录或者文件 
（宿主机目录挂载容器）&lt;/li&gt;
  &lt;li&gt;当容器目录和数据卷目录绑定后修改会立即同步&lt;/li&gt;
  &lt;li&gt;一个数据卷可以被多个容器挂载&lt;/li&gt;
  &lt;li&gt;一个容器可以挂载多个数据卷&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;配置数据卷&quot;&gt;配置数据卷&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;docker run  … -v 宿主机目录（文件）：容器内目录（文件）…
注意事项： 目录必须是绝对路径 ；如果目录不存在会自动创建；可以挂载多个数据卷
eg. docker run -it –name=c1 -v /root/data/:/root/data_container centos:7  创建 centos 镜像文件 并挂载数据卷&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据卷容器&quot;&gt;数据卷容器&lt;/h2&gt;
&lt;p&gt;通过一个容器挂载两个容器 同时挂载一个数据卷 ：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建启动c3数据卷容器&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;docker run -it —name=c3数据卷名 -v /数据卷目录 centos:7 /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;创建启动c1,c2 容器—volumes-from 设置参数&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;docker run -it —name=c1 —volumes-from c3 cenos:7 /bin/bash&lt;/li&gt;
  &lt;li&gt;docker run -it —name=c2 —volumes-from c3 cenos:7 /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;docker-部署&quot;&gt;docker 部署&lt;/h1&gt;
&lt;h2 id=&quot;通过外部mysql客户端操作mysql&quot;&gt;通过外部MySQL客户端操作MySQL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;问题：外部容器无法访问容器 但是宿主机和外部同&lt;/li&gt;
  &lt;li&gt;端口映射：外部机器访问宿主机端口从而访问容器端口&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;$ docker run -id \
 -p 3307:3306 \ 
 --name=c_mysql \
 -v $PWD/conf:/etc/mysql/conf.d \
 -v $PWD/logs:/logs \
 -v $PWD/data:/var/lib/mysql \
 -e MYSQL_ROOT_PASSWORD=123456 \
 mysql:5.6
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-p 3307:3306 将容器的3306映射到宿主机的3307&lt;/li&gt;
  &lt;li&gt;-v $PWD/conf:/etc/mysql/conf.d 将当前主机下的conf/my.cnf挂载到容器&lt;/li&gt;
  &lt;li&gt;-v $PWD/logs:/logs 将日志目录匹配&lt;/li&gt;
  &lt;li&gt;-v $PWD/data:/var/lib/mysql 数据目录同步 即使容器坏掉 依然能够使用data&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-e MYSQL_ROOT_PASSWORD=123456 配置 root用户的环境变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;进入容器：docker exec -it c_mysql /bin/bash&lt;/li&gt;
  &lt;li&gt;登录mysql ：mysql -uroot -p123456
在mysql界面上的命令
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create database db1;&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show databases; &lt;/code&gt;需要有 &lt;strong&gt;;&lt;/strong&gt; 符号
外部登录MySQL 直接在 navicate 上登录MySQL 并输入 端口号 取得一个映射 注意此处是3307 root和密码输入即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;部署mongodb&quot;&gt;部署MongoDB&lt;/h3&gt;

&lt;p&gt;获取镜像&lt;/p&gt;

&lt;p&gt;运行 MongoDB 镜像 https://hub.docker.com/_/mongo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker pull mongo
docker run --name mongo -p 27017:27017 -v ~/docker-
data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin
-e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过  Docker 启动 MongoDB&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;登录到 MongoDB 容器中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec -it mongo bash&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过 Shell 连接 MongoDB &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongo -u admin -p admin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置tomcat&quot;&gt;配置Tomcat&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;搜索 和 拉取 tomcat镜像docker search tomcat   docker pull tomcat&lt;/li&gt;
  &lt;li&gt;创建容器 映射端口&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mkdir ~/tomcat
cd ~/tomcat
docker run -id --name=c_tomcat \
-p 8080:8080 \
-v $PWD:/usr/local/tomcat/webapps \
tomcat
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数介绍：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-p 8080:8080 容器端口映射到主机端口&lt;/li&gt;
  &lt;li&gt;-v $PWD:/usr/local/tomcat/webapps 将主机的当前目录 挂载到 容器的webapps 上 
 简单配置方式
 $mkdir test
$ cd test
$ vim index.html 编写一个简单HTML页面
在网页的地址栏输入 分配的地址:8080/test/index.html
在日后的使用时 直接将页面放入Tomcat目录中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nignx-部署&quot;&gt;Nignx 部署&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;查找和下载 docker search nginx 
Docker pull nignx&lt;/li&gt;
  &lt;li&gt;mkdir ~/nginx&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd ~/nginx
mkdir conf
cd conf
vim nginx.conf
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写入以下文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    keepalive_timeout  65;
    #gzip  on;
    include /etc/nginx/conf.d/*.conf;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意 以下操作一定要推到nginx目录里面操作&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker run -id --name=容器名称 \
-p 宿主机端口:容器端口 \
-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \
-v $PWD/logs:/var/log/nginx \
-v $PWD/html:/usr/share/nginx/html \
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nginx:版本号
参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录&lt;/li&gt;
  &lt;li&gt;-v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eg:docker run -id –name=c_nginx -p 8000:80 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/var/log/nginx -v $PWD/html:/usr/share/nginx/html nginx
在HTML目录下创建文件 之后直接在 地址号：端口号 就能看见配置的 文件&lt;/p&gt;

&lt;h3 id=&quot;redis-部署&quot;&gt;redis 部署&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -id –name=c_redis -p 6379:6379  redis:5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;elasticsearch-部署&quot;&gt;elasticsearch 部署&lt;/h3&gt;
&lt;p&gt;https://www.cnblogs.com/powerbear/p/11298135.html&lt;/p&gt;

&lt;p&gt;如果是要和kibana联合使用需要开一个内部网络&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker network create esnet&lt;/code&gt;之后查看镜像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker images&lt;/code&gt;之后开始运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name elasticsearch  -p 9200:9200 -p 9300:9300  --network esnet -e &quot;discovery.type=single-node&quot; 镜像号&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt;表示设置初始堆内存和最大内存 也可以调整虚拟机内存如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e S_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;&lt;/code&gt;
打开localhost:9200如果是一段一下内容表示成功。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
&quot;name&quot; : &quot;39042254f345&quot;,
&quot;cluster_name&quot; : &quot;docker-cluster&quot;,
&quot;cluster_uuid&quot; : &quot;gO3NL-XwRWq3siqb8uNahw&quot;,
&quot;version&quot; : {
  &quot;number&quot; : &quot;7.4.2&quot;,
  &quot;build_flavor&quot; : &quot;default&quot;,
  &quot;build_type&quot; : &quot;docker&quot;,
  &quot;build_hash&quot; : &quot;2f90bbf7b93631e52bafb59b3b049cb44ec25e96&quot;,
  &quot;build_date&quot; : &quot;2019-10-28T20:40:44.881551Z&quot;,
  &quot;build_snapshot&quot; : false,
  &quot;lucene_version&quot; : &quot;8.2.0&quot;,
  &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
  &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
},
&quot;tagline&quot; : &quot;You Know, for Search&quot;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;elasticsearch 可视化插件elasticsearch-head 详细启动见https://www.cnblogs.com/afeige/p/10771140.html 在本机中使用如下命令打开这个插件，注意端口9100是对的，在网页上输入localhost:9100后可以看到集群情况
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -d -p 9100:9100 docker.io/mobz/elasticsearch-head:5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此后有了用户名和密码的设计，所有密码是fiona@1999用户名是对应的应用&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Enter password for [elastic]:
Reenter password for [elastic]:
Enter password for [apm_system]:
Reenter password for [apm_system]:
Enter password for [kibana]:
Reenter password for [kibana]:
Enter password for [logstash_system]:
Reenter password for [logstash_system]:
Enter password for [beats_system]:
Reenter password for [beats_system]:
Enter password for [remote_monitoring_user]:
Reenter password for [remote_monitoring_user]:
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker-快速启动kibana&quot;&gt;docker 快速启动kibana&lt;/h3&gt;
&lt;p&gt;一、拉取镜像
二、启动容器:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name kibana -e ELASTICSEARCH_URL=http://0.0.0.0:9200 -p 5601:5601 -d kibana:7.4.2&lt;/code&gt;
三、访问kibana:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:5601&lt;/code&gt;
四、可能遇到的问题&lt;/p&gt;

&lt;h1 id=&quot;docker-转镜像&quot;&gt;Docker 转镜像&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;容器转镜像（目录挂载不进入）
docker commit 容器 id 镜像名称 ：版本号&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;镜像转压缩文件
    &lt;ul&gt;
      &lt;li&gt;docker save -o 压缩文件名 镜像名：版本号&lt;/li&gt;
      &lt;li&gt;docker load -i 压缩文件名称  （还原压缩文件）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;docker file 
制作镜像的文件 是文本文件 包含一条一条指令每一层指令构成一个镜像
    &lt;ul&gt;
      &lt;li&gt;案例
        &lt;ul&gt;
          &lt;li&gt;docker run -it –name=c11 centos:7
&lt;strong&gt;官方路径在/root下 不能用vim&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;自定义centos&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;默认路径在/usr&lt;/li&gt;
  &lt;li&gt;能使用 vim&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;解决
    &lt;ol&gt;
      &lt;li&gt;父镜像 FROM centos:7&lt;/li&gt;
      &lt;li&gt;作者信息 MAINTAINER jojo&lt;a href=&quot;mailto:jijojo@1212&quot;&gt;jijojo@1212&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;执行安装vim命令 RUN yum install -y vim&lt;/li&gt;
      &lt;li&gt;工作路径 WORKDIR /usr&lt;/li&gt;
      &lt;li&gt;启动执行命令 CMD /bin/bash&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker build -f(docker file 的文件路径) ./centos_dockerfile -t(设置新的镜像名字) jojoscenos&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;部署 spring boot项目&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;docker服务编排&lt;/li&gt;
      &lt;li&gt;Compose： 按照业务规则批量管理容器&lt;/li&gt;
      &lt;li&gt;docker compose 分布式部署工具 完整生命周期&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安装：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-&lt;/code&gt;uname -s&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;uname -m&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; -o /usr/local/bin/docker-compose&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;配置权限 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod +x /usr/local/bin/docker-compose&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看版本信息 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose -version&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;卸载&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm /usr/local/bin/docker-compose&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用docker搭建nginx和springboot项目&quot;&gt;用docker搭建nginx和springboot项目&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mkdir ~/docker-compose
cd ~/docker-compose
vim docker-compose.yml
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写配置文件  （键值对有空格 写的时候有高亮）&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;version: '3'
services:
 nginx:
  image: nginx
  ports:
   - 80:80
  links:
   - app
  volumes:
   - ./nginx/conf.d:/etc/nginx/conf.d
 app:
  image: app
  expose:
   - &quot;8080&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建./nginx/conf.d目录 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkdir -p ./nginx/conf.d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在./nginx/conf.d目录下 编写itheima.conf文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;server {
    listen 80;
    access_log off;
    location / {
        proxy_pass http://app:8080;
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打开 consul &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name consul -d -p 8500:8500 -p 8600:8600/udp consul&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Nov 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/11/02/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/11/02/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
        
        <category>Docker</category>
        
        <category>redis</category>
        
        <category>mysql</category>
        
        <category>mongodb</category>
        
        <category>NoSql</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记01 基础知识和数据库 </title>
        <description>&lt;p&gt;React项目做到一半，实在是不想再去复现大段CSS代码，开始复习一下Java的Spring boot全家桶在极客时间上的课，毕竟不能靠着firebase过一辈子。所有的代码可以在&lt;a href=&quot;https://github.com/geektime-geekbang/geektime-spring-family&quot; target=&quot;_blank&quot;&gt;github仓库&lt;/a&gt;上找到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;写在前面： 插件安装lombok，在本地启动docker环境在redis和MongoDB时会比较简单。&lt;/em&gt;&lt;/strong&gt;
需要预先了解的知识： java8中的lambda和stream
例如对以下代码的解读&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private String getJoinedOrderId(List&amp;lt;CoffeeOrder&amp;gt; list) {
		return list.stream().map(o -&amp;gt; o.getId().toString())
				.collect(Collectors.joining(&quot;,&quot;));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在list这个表中形成stream类型为集合创建串行流，map 方法用于映射每个元素到对应的结果；Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串，在这里是对字符串做拼接。&lt;/p&gt;

&lt;h1 id=&quot;chapter1&quot;&gt;Chapter1&lt;/h1&gt;

&lt;h2 id=&quot;配置单源数据&quot;&gt;配置单源数据&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Spring 框架的基本配置是可以通过 https://start.spring.io/ 这个网页帮助自动配置的。&lt;/li&gt;
  &lt;li&gt;数据的启动方式是通过在这个界面勾选依赖，实现自动配置。&lt;/li&gt;
  &lt;li&gt;配置的演示：
    &lt;ul&gt;
      &lt;li&gt;引入对应数据库驱动 —H2&lt;/li&gt;
      &lt;li&gt;引入JDBC依赖 — spring-boot-starter-jdbc&lt;/li&gt;
      &lt;li&gt;获得DataSource Bean 打印信息&lt;/li&gt;
      &lt;li&gt;通过/acturator/beans 查看Bean&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring boot 根据数据源会自动配置数据库，对于所需要的Bean在不使用Springboot的情况下需要自己手写以下内容:
    &lt;ul&gt;
      &lt;li&gt;数据源相关Datasource 根据选择的连接池实现&lt;/li&gt;
      &lt;li&gt;事务相关&lt;/li&gt;
      &lt;li&gt;PlatformTransactionManager(DataSource TransactionManager)&lt;/li&gt;
      &lt;li&gt;Transaction Template&lt;/li&gt;
      &lt;li&gt;操作相关 JdbcTemplate&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据源相关配置属性
&lt;img src=&quot;/img/java-spring/spring-boot-chapter1-datasourcs.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;配置多源数据&quot;&gt;配置多源数据&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;配置数据源分开&lt;/li&gt;
  &lt;li&gt;关注每次使用的数据源
    &lt;ul&gt;
      &lt;li&gt;有多个DataSource时系统如何判断&lt;/li&gt;
      &lt;li&gt;对应的（事务，ORM）如何选择DataSource&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;和Spring Boot 协同工作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置@Primary类型的Bean&lt;/li&gt;
  &lt;li&gt;排除Spring Boot 自动配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;好用的数据连接池&quot;&gt;好用的数据连接池&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;HikariCP
HikariCP 来源于日本，高性能JDBC数据库连接池，tomcat在连接取放比较占有优势，使用了JavaAssist生成，是一种字节码级别的优势，同时有大量的小改进使用了FastStatementList 代替了 ArrayList, 无锁集合 ConcurrentBag以及代理类的优化，积少成多的优化。
怎样在代码中使用：
    &lt;ul&gt;
      &lt;li&gt;Spring Boot2.x中是默认使用HikariCP只要配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.hikari.*&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;在Spring Boot 1.x中默认是Tomcat 连接池，需要移除pom文件中 Tomcat-jdbc依赖，在Spring Boot的 application.properties当中配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.type=com.zaxxer.hikari.HikariDataSource&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在DataSourceConfiguration中是怎样配置的，源码中的实现方式是在上下文中配置了HikariDataSource而且上下文没有配置DataSource的Bean，而且Spring.datasource的属性配置的是Hikari，详细信息见
&lt;a href=&quot;https://github.com/brettwooldridge/HikariCP&quot; target=&quot;_blank&quot;&gt;HikariCP网址 &lt;/a&gt;
常用的HikariCP参数配置是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.datasource.hikari.maximumPoolSize=10
spring.datasource.hikari.minimumIdle=10
spring.datasource.hikari.idleTimeout=600000
spring.datasource.hikari.connectionTimeout=30000
spring.datasource.hikari.maxLifetime=1800000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Druid 是阿里巴巴
详细监控，Sql注入等&lt;a href=&quot;github.com/alibaba/druid&quot; target=&quot;_blank&quot;&gt;Druid官网&lt;/a&gt;文档齐全
扩展点很多。
    &lt;ul&gt;
      &lt;li&gt;使用方式：直接配置druid-spring-boot-starter&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;Filter 配置
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.datasource.druid.filters=stat,config,wall,log4j (全部使⽤用默认值)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;密码加密
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   spring.datasource.password=&amp;lt;加密密码&amp;gt; spring.datasource.druid.filter.config.enabled=true
   spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key=&amp;lt;public-key&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;SQL 防止注入
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   spring.datasource.druid.filter.wall.enabled=true spring.datasource.druid.filter.wall.db-type=h2 spring.datasource.druid.filter.wall.config.delete-allow=false spring.datasource.druid.filter.wall.config.drop-table-allow=false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;对Druid 扩展点的补充，在Druid的扩展点中有大部分的是extend FilterEventAdapter实现的，在FilterEventAdapter中每一个方法的前后都定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_connectBefore()&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_connectBefore()&lt;/code&gt;两个方法在每次实际建连接的前和后都会实现这两个方法，在自己扩展时可以自己扩展这些方法。查看源码是一种责任链的方式实现的 &lt;strong&gt;注意，如果使用Druid作为连接池，一定要在pom文件中将Hikari排除，排除方式是:&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
  &amp;lt;exclusions&amp;gt;
    &amp;lt;exclusion&amp;gt;
      &amp;lt;artifactId&amp;gt;HikariCP&amp;lt;/artifactId&amp;gt;
      &amp;lt;groupId&amp;gt;com.zaxxer&amp;lt;/groupId&amp;gt;
    &amp;lt;/exclusion&amp;gt;
  &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时引入&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;对于druid的扩展&quot;&gt;对于Druid的扩展&lt;/h3&gt;
&lt;h4 id=&quot;慢sql配置找到执行比较慢的sql语句&quot;&gt;慢SQL配置：找到执行比较慢的SQL语句&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;系统属性配置(默认监控执行超过3秒的语句)：
    &lt;ul&gt;
      &lt;li&gt;druid.stat.logSlowSql=true&lt;/li&gt;
      &lt;li&gt;druid.stat.slowSqlMillis=3000&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Boot
    &lt;ul&gt;
      &lt;li&gt;spring.datasource.druid.filter.stat.enabled=true&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.filter.stat.log-slow-sql=true&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.filter.stat.slow-sql-millis=3000&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;演示慢SQL&lt;/strong&gt;
pom文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;exclusions&amp;gt;
  &amp;lt;exclusion&amp;gt;
    &amp;lt;artifactId&amp;gt;HikariCP&amp;lt;/artifactId&amp;gt;
    &amp;lt;groupId&amp;gt;com.zaxxer&amp;lt;/groupId&amp;gt;
  &amp;lt;/exclusion&amp;gt;
&amp;lt;/exclusions&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;
&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;schema.sql文件中插入FOO表，和一个记录&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64));
INSERT INTO FOO (ID, BAR) VALUES (1, 'AAA');
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在application.properties中配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.druid.filter.stat.log-slow-sql=true&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.druid.filter.stat.slow-sql-millis=3000&lt;/code&gt;两个内容就会在terminal中知道哪里出了问题。&lt;/p&gt;

&lt;h4 id=&quot;druid一些注意事项&quot;&gt;Druid一些注意事项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;没特殊情况，不不要在⽣生产环境打开监控的 Servlet&lt;/li&gt;
  &lt;li&gt;没有连接泄露露可能的情况下，不要开启 removeAbandoned 对性能有影响&lt;/li&gt;
  &lt;li&gt;testXxx 的使⽤用需要注意
    &lt;ul&gt;
      &lt;li&gt;spring.datasource.druid.test-on-borrow=true在取连接的时候校验连接&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.test-on-return=true在放回连接的时候校验连接&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.test-while-idle=true在连接有一段时间不用时再去检查
建议使用test-while-idle毕竟每次检查开销会很大。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;务必配置合理理的超时时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;数据库连接池使用考量点：可靠性，性能，功能，可扩展性！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何通过spring-jdbc访问数据库&quot;&gt;如何通过Spring JDBC访问数据库&lt;/h2&gt;

&lt;h3 id=&quot;spring-jdbc操作类&quot;&gt;Spring Jdbc操作类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;core，JdbcTemplate 等相关核⼼心接⼝和类&lt;/li&gt;
  &lt;li&gt;datasource，数据源相关的辅助类&lt;/li&gt;
  &lt;li&gt;object，将基本的 JDBC 操作封装成对象&lt;/li&gt;
  &lt;li&gt;support，错误码等其他辅助⼯工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用的bean注解&quot;&gt;常用的Bean注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@Component 通用注解，用来定义通用的Bean&lt;/li&gt;
  &lt;li&gt;@Repository 如果是Dao数据操作的仓库&lt;/li&gt;
  &lt;li&gt;@Service 业务的服务&lt;/li&gt;
  &lt;li&gt;@Controller SpringMVC使用这个注解
    &lt;ul&gt;
      &lt;li&gt;@RestController Restful Service提供的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;简单的jdbc操作jdbctemplate&quot;&gt;简单的JDBC操作&lt;strong&gt;JdbcTemplate&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;query&lt;/li&gt;
  &lt;li&gt;queryForObject&lt;/li&gt;
  &lt;li&gt;queryForList&lt;/li&gt;
  &lt;li&gt;update&lt;/li&gt;
  &lt;li&gt;execute&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;例子讲解&quot;&gt;例子讲解&lt;/h3&gt;
&lt;p&gt;在geektime/spring/data/simplejdbcdemo/FooDao.java中可以看到实际的使用方式&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void insertData() {
  Arrays.asList(&quot;b&quot;, &quot;c&quot;).forEach(bar -&amp;gt; {
      jdbcTemplate.update(&quot;INSERT INTO FOO (BAR) VALUES (?)&quot;, bar);
  });

  HashMap&amp;lt;String, String&amp;gt; row = new HashMap&amp;lt;&amp;gt;();
  row.put(&quot;BAR&quot;, &quot;d&quot;);
  Number id = simpleJdbcInsert.executeAndReturnKey(row);
  log.info(&quot;ID of d: {}&quot;, id.longValue());
}

public void listData() {
  log.info(&quot;Count: {}&quot;,
          jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM FOO&quot;, Long.class));

  List&amp;lt;String&amp;gt; list = jdbcTemplate.queryForList(&quot;SELECT BAR FROM FOO&quot;, String.class);
  list.forEach(s -&amp;gt; log.info(&quot;Bar: {}&quot;, s));//取出对象 因为是单值用String就好

  List&amp;lt;Foo&amp;gt; fooList = jdbcTemplate.query(&quot;SELECT * FROM FOO&quot;, new RowMapper&amp;lt;Foo&amp;gt;() {
    //希望取出的是对象列表使用mapRow
      @Override
      public Foo mapRow(ResultSet rs, int rowNum) throws SQLException {
          return Foo.builder()
                  .id(rs.getLong(1))
                  .bar(rs.getString(2))
                  .build();
      }
  });
  fooList.forEach(f -&amp;gt; log.info(&quot;Foo: {}&quot;, f));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;ResultSet是专门针对数据库内容的数据类型，是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据的更新等。
以上代码中调用的getXXX方法可以实现数据的获取&lt;/li&gt;
  &lt;li&gt;如果想要取到对象列表使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RowMapper&amp;lt;Foo&amp;gt;()&lt;/code&gt;来实现&lt;/li&gt;
  &lt;li&gt;simpleJdbcTemplate是提供的一种辅助类，在运行代码中制定了
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
@Autowired
public SimpleJdbcInsert simpleJdbcInsert(JdbcTemplate jdbcTemplate) {
 return new SimpleJdbcInsert(jdbcTemplate)
         .withTableName(&quot;FOO&quot;).usingGeneratedKeyColumns(&quot;ID&quot;);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;表示指定了simpleJdbcInsert是和自定义的FOO表关联，这个表有一个生成的主键列名是ID，在DAO应用时是&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Number id = simpleJdbcInsert.executeAndReturnKey(row);
log.info(&quot;ID of d: {}&quot;, id.longValue());
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;取回插入时的主键。&lt;/p&gt;

&lt;h3 id=&quot;sql批处理20201027不是很懂&quot;&gt;SQL批处理（2020/10/27不是很懂）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JdbcTemplate&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;batchUpdate
    &lt;ul&gt;
      &lt;li&gt;BatchPreparedStatementSetter
&lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;batchUpdate
    &lt;ul&gt;
      &lt;li&gt;SqlParameterSourceUtils.createBatch&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;批处理样例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void batchInsert() {
  jdbcTemplate.batchUpdate(&quot;INSERT INTO FOO (BAR) VALUES (?)&quot;,
    new BatchPreparedStatementSetter() {
      @Override
      public void setValues(PreparedStatement ps, int i) throws SQLException {
          ps.setString(1, &quot;b-&quot; + i);
      }

      @Override
      public int getBatchSize() {
          return 2;
      }
  });

  List&amp;lt;Foo&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  list.add(Foo.builder().id(100L).bar(&quot;b-100&quot;).build());
  list.add(Foo.builder().id(101L).bar(&quot;b-101&quot;).build());
  namedParameterJdbcTemplate
    .batchUpdate(&quot;INSERT INTO FOO (ID, BAR) VALUES (:id, :bar)&quot;,
      SqlParameterSourceUtils.createBatch(list));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BatchPreparedStatementSetter&lt;/code&gt;应用类，每一次都给ps设置了不同值，注意在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;namedParameterJdbcTemplate&lt;/code&gt;中sql语句不是？而是名称&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:id等&lt;/code&gt;，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SqlParameterSourceUtils.createBatch&lt;/code&gt;对list中的值做映射&lt;/p&gt;

&lt;h2 id=&quot;spring-的事务抽象&quot;&gt;Spring 的事务抽象&lt;/h2&gt;
&lt;p&gt;一致的事务模型，首先要了解的就是事务抽象的核心接口。
&lt;img src=&quot;/img/java-spring/chapter1-transaction.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/java-spring/chapter1-transaction1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;request_new-和-nested&quot;&gt;REQUEST_NEW 和 NESTED&lt;/h3&gt;
&lt;p&gt;REQUEST_NEW: 始终启动一个新的事务，两个事务没有关联。
NESTED：在原事务内启动一个内嵌事务，两个事务有关联，外部事务回滚，内嵌事务也会回滚。
使用方式和测试两个是否会回滚的代码如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
@Transactional(rollbackFor = RollbackException.class, propagation = Propagation.REQUIRES_NEW)//可以写为NESTED
public void insertThenRollback() throws RollbackException {
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('BBB')&quot;);
    throw new RollbackException();
}

@Override
@Transactional(rollbackFor = RuntimeException.class)
public void invokeInsertThenRollback() {
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('AAA')&quot;);
    try {
        fooService.insertThenRollback();
    } catch (RollbackException e) {
        log.error(&quot;RollbackException&quot;, e);
    }
//        throw new RuntimeException();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;编程式事务-programatic-transaction&quot;&gt;编程式事务 Programatic Transaction&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;TransactionTemplate
    &lt;ul&gt;
      &lt;li&gt;TransactionCallback 事务有返回&lt;/li&gt;
      &lt;li&gt;TransactionCallbackWithoutResult 事务无返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用方式：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
@Slf4j
public class ProgrammaticTransactionDemoApplication implements CommandLineRunner {
	@Autowired
	private TransactionTemplate transactionTemplate;
	@Autowired
	private JdbcTemplate jdbcTemplate;

	public static void main(String[] args) {
		SpringApplication.run(ProgrammaticTransactionDemoApplication.class, args);
	}

  @Override
    public void run(String... args) throws Exception {
      log.info(&quot;COUNT BEFORE TRANSACTION: {}&quot;, getCount());
      transactionTemplate.execute(new TransactionCallbackWithoutResult() { //没有返回值
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
          jdbcTemplate.execute(&quot;INSERT INTO FOO (ID, BAR) VALUES (1, 'aaa')&quot;);
          log.info(&quot;COUNT IN TRANSACTION: {}&quot;, getCount());
          transactionStatus.setRollbackOnly();
        }
      });
      log.info(&quot;COUNT AFTER TRANSACTION: {}&quot;, getCount());
    }

    private long getCount() {
      return (long) jdbcTemplate.queryForList(&quot;SELECT COUNT(*) AS CNT FROM FOO&quot;)
          .get(0).get(&quot;CNT&quot;);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在每次执行语句前获得count数，之后再执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setRollbackOnly&lt;/code&gt;表示只能回滚，这就是transactionTemplate的简单执行方式。
简单看transactionTemplate，继承 DefaultTransactionDefinition,其中execute方法会接受TransactionCallbackWithoutResult或者TransactionCallback&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PlatformTransactionManager
    &lt;ul&gt;
      &lt;li&gt;可以传⼊入TransactionDefinition进⾏行行定义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;申明式事务-declarative-transaction&quot;&gt;申明式事务 Declarative Transaction&lt;/h3&gt;

&lt;p&gt;基于注解的配置方式:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;开启事务注解的⽅方式
    &lt;ul&gt;
      &lt;li&gt;@EnableTransactionManagement  开启事务注解支持&lt;/li&gt;
      &lt;li&gt;
        &lt;tx:annotation-driven /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些配置
    &lt;ul&gt;
      &lt;li&gt;proxyTargetClass  当前的AOP是基于接口还是类&lt;/li&gt;
      &lt;li&gt;mode 对AOP mode选择&lt;/li&gt;
      &lt;li&gt;order 对事务AOP拦截顺序，默认是最低的优先级，自己的AOP拦截可以在事务启动后执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@Transactional 开启事务注解支持之后对其进行配置
    &lt;ul&gt;
      &lt;li&gt;transactionManager 一般是DatasourceTransactionManager&lt;/li&gt;
      &lt;li&gt;propagation 传播性&lt;/li&gt;
      &lt;li&gt;isolation 隔离型&lt;/li&gt;
      &lt;li&gt;timeout&lt;/li&gt;
      &lt;li&gt;readOnly&lt;/li&gt;
      &lt;li&gt;怎么判断回滚&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;案例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
@Transactional
public void insertRecord() {//使用事务性
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('AAA')&quot;);
}

@Override
@Transactional(rollbackFor = RollbackException.class)
public void insertThenRollback() throws RollbackException {//回滚
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('BBB')&quot;);
    throw new RollbackException();
}

@Override
public void invokeInsertThenRollback() throws RollbackException {// 调用了会回滚到方法，但是结果没有显示回滚
    insertThenRollback();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上案例的结果就是，在第三个方法中，类内部调用了代理的AOP所以不遵循事务性，虽然invokeInsertThenRollback调用了一个带有事务的方法，但是invokeInsertThenRollback本身没有事务在调用insertThenRollback没有事务的支持。&lt;/p&gt;
&lt;h4 id=&quot;事务的本质&quot;&gt;事务的本质&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Spring申明式事务本质上是通过AOP做了增强类功能&lt;/li&gt;
  &lt;li&gt;Spring的AOP本质上就是为类做了代理
    &lt;ul&gt;
      &lt;li&gt;看似在调用自己写的类，实际上是调用背后的增强类
以上问题的解决方法是访问增强之后的代理类方法，而非访问自身方法。
&lt;strong&gt;解决方案&lt;/strong&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Autowird FooService fooservice;//注入需要的service
...
@Override
public void invokeInsertThenRollback() throws RollbackException {// 调用了会回滚到方法
fooserivce.insertThenRollback();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;以上就可以使一个不带事务的执行方法执行事务性了&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-jdbc异常的抽象&quot;&gt;Spring JDBC异常的抽象&lt;/h2&gt;
&lt;p&gt;Spring会将各种异常转换为DataAccessException,通过 SQLErrorCodeSQLExceptionTranslator 解析错误码&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ErrorCode 定义
    &lt;ul&gt;
      &lt;li&gt;org/springframework/jdbc/support/sql-error-codes.xml 看到主要的定义错误&lt;/li&gt;
      &lt;li&gt;Classpath 下的 sql-error-codes.xml自定义错误写在哪里&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自定义错误码（在resource文件夹下）：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;property name=&quot;customTranslations&quot;&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.jdbc.support.CustomSQLErrorCodesTranslation&quot;&amp;gt;
        &amp;lt;property name=&quot;errorCodes&quot; value=&quot;23001,23505&quot; /&amp;gt;
        &amp;lt;property name=&quot;exceptionClass&quot;
                  value=&quot;geektime.spring.data.errorcodedemo.CustomDuplicatedKeyException&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;自定义了错误实现的代码，以及发生错误的时候调用那个地方的错误处理模块&lt;/p&gt;

&lt;h3 id=&quot;第一章小结&quot;&gt;第一章小结&lt;/h3&gt;
&lt;h4 id=&quot;常用的注解&quot;&gt;常用的注解&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Java Config相关注解
    &lt;ul&gt;
      &lt;li&gt;@Configuration 表示是配置类&lt;/li&gt;
      &lt;li&gt;@ImportResource 表示xml配置文件&lt;/li&gt;
      &lt;li&gt;@ComponentScan 告知Spring容器去扫描哪些package下的bean这样的配置&lt;/li&gt;
      &lt;li&gt;@Bean 返回可以作为SpringApplicationContext中的Bean&lt;/li&gt;
      &lt;li&gt;@Configurationroperties 绑定配置，在Hikari中有使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定义相关的注解
    &lt;ul&gt;
      &lt;li&gt;@Component/@Repository/@Service,所有的JavaBean 都可以通过@Component来定义，@Repository表示在数据访问层的Bean，@Service服务层的Bean&lt;/li&gt;
      &lt;li&gt;@Controller/@RestController表示web层的Bean,@
RestController是加上了ResponseBody加到@Controller上就是@RestController&lt;/li&gt;
      &lt;li&gt;@RequestMapping类下的方法是在哪些URL上做映射&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注入相关的注解
    &lt;ul&gt;
      &lt;li&gt;@Autowired上下文中多个类型的Bean查找注入&lt;/li&gt;
      &lt;li&gt;@Qualifier上下文中有多个同类型的Bean，Autowired会产生歧义&lt;/li&gt;
      &lt;li&gt;@Resource 根据名字进行注入&lt;/li&gt;
      &lt;li&gt;@Value在Bean中注入常量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;actuator实现的endpoint问题&quot;&gt;Actuator实现的endpoint问题&lt;/h4&gt;
&lt;p&gt;常用的endpoint
一般只发布了health和info如果想要看更多的endpoint需要配置，生产环境需谨慎。&lt;/p&gt;

&lt;p&gt;application.properties中写入
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;management.endpoints.web.exposure.include=*&lt;/code&gt;表示发布所有endpoint&lt;/p&gt;

&lt;h4 id=&quot;多数据源分库分表读写分离是什么关系&quot;&gt;多数据源，分库分表，读写分离是什么关系&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;系统需要访问完全不一样的数据库，&lt;/li&gt;
  &lt;li&gt;系统需要访问一个同一个库的主库（读写）和备库（读）&lt;/li&gt;
  &lt;li&gt;系统需要访问一个做了分库分表的数据库 &lt;strong&gt;使用数据库中间件帮助简化开发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter2-or-mapping实践&quot;&gt;Chapter2 O/R Mapping实践&lt;/h1&gt;
&lt;h2 id=&quot;认识spring-data-jpa&quot;&gt;认识Spring Data JPA&lt;/h2&gt;
&lt;p&gt;对象和与关系之间的不匹配
&lt;img src=&quot;/img/java-spring/chapter2-unmatch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hibernate-和-jpa-java-persistence-api&quot;&gt;Hibernate 和 JPA (java persistence API)&lt;/h3&gt;
&lt;p&gt;JPA 为对象关系映射提供了一种基于POJO的持久化模型，在保留留底层存储特性的同时，提供相对⼀一致的、基于 Spring 的编程模型 主要模块。
Hibernate为JPA提供了一种操作方式。&lt;/p&gt;
&lt;h3 id=&quot;spring-data&quot;&gt;Spring Data&lt;/h3&gt;
&lt;p&gt;在主要的一层抽象中&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Data JPA&lt;/li&gt;
  &lt;li&gt;Spring Data MongoDb
…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;定义-jpa-实体对象&quot;&gt;定义 JPA 实体对象&lt;/h2&gt;
&lt;h3 id=&quot;常用-jpa-注解&quot;&gt;常⽤用 JPA 注解&lt;/h3&gt;
&lt;p&gt;实体&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Entity（表示为实体）、@MappedSuperclass（多个实体类，有父类）&lt;/li&gt;
  &lt;li&gt;@Table(name)（实体表关联）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主键&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Id
    &lt;ul&gt;
      &lt;li&gt;@GeneratedValue(strategy, generator) 自增策略
&lt;strong&gt;JPA提供的四种标准用法为TABLE，SEQUENCE，IDENTITY，AUTO。&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;TABLE：使用一个特定的数据库表格来保存主键。&lt;/li&gt;
          &lt;li&gt;SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。&lt;/li&gt;
          &lt;li&gt;IDENTITY：主键由数据库自动生成（主要是自动增长型）&lt;/li&gt;
          &lt;li&gt;AUTO：主键由程序控制。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;@SequenceGenerator(name, sequenceName) 序列化自增是怎样自增&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;映射&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Column(name, nullable, length, insertable, updatable)定义属性和表可以通过name改名字，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertable&lt;/code&gt;只能在插入时一次性插入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updatable&lt;/code&gt;能够更新&lt;/li&gt;
  &lt;li&gt;@JoinTable(name)、@JoinColumn(name)关联时候实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@OneToOne、@OneToMany、 @ManyToOne、@ManyToMany&lt;/li&gt;
  &lt;li&gt;@OrderBy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/aishangtaxuefeihong/p/6580630.html&quot; target=&quot;_blank&quot;&gt;Hibernate的一些用法&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;project-lombok&quot;&gt;Project Lombok&lt;/h3&gt;

&lt;p&gt;Project Lombok 能够⾃自动嵌⼊入 IDE 和构建⼯工具，提升开发效率
常⽤用功能&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Getter / @Setter 写get set方法&lt;/li&gt;
  &lt;li&gt;@ToString 写toString&lt;/li&gt;
  &lt;li&gt;@NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor 构造方法相关&lt;/li&gt;
  &lt;li&gt;@Data 混合注解 get set 和toString&lt;/li&gt;
  &lt;li&gt;@Builder 生成builder方法&lt;/li&gt;
  &lt;li&gt;@Slf4j / @CommonsLog / @Log4j2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线上咖啡馆实战项目&quot;&gt;线上咖啡馆实战项目&lt;/h2&gt;
&lt;p&gt;数据库相关&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将菜单放入缓存中redis&lt;/li&gt;
  &lt;li&gt;waiter和barista（咖啡师）做交互rabitMQ
&lt;img src=&quot;/img/java-spring/chapter2-logic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实体关系
&lt;img src=&quot;/img/java-spring/chapter2-entity.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;订单状态，已支付但是还没有开始制作可以取消掉订单，没支付也可以取消掉订单。&lt;/p&gt;

&lt;h3 id=&quot;pom文件&quot;&gt;pom文件&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.joda&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;joda-money&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.jadira.usertype&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;usertype.core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;6.0.1.GA&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;实体类定义&quot;&gt;实体类定义&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;菜单&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_MENU&quot;)
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Coffee implements Serializable {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    @Column
    @Type(type = &quot;org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyAmount&quot;,
            parameters = {@org.hibernate.annotations.Parameter(name = &quot;currencyCode&quot;, value = &quot;CNY&quot;)})
    private Money price;
    @Column(updatable = false)
    @CreationTimestamp
    private Date createTime;
    @UpdateTimestamp
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主键是id，但是注意price上加上了Type表示用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentMoneyAmount&lt;/code&gt;做映射，里面有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currencyCode&lt;/code&gt;指定是人民币；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@CreationTimestamp&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@UpdateTimestamp&lt;/code&gt;在createTime上表明是不能修改的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@org.hibernate.annotations.Parameter&lt;/code&gt;是一个Parameter对象是对内容的一种包装，其中要包括String类型的name和value，这是对传入的@Type映射的参数名的显示
&lt;strong&gt;在java中有专门的joda money包来对金钱类做处理，在处理金额方面时要小心&lt;/strong&gt;一般的money类会被映射为decimal类型。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentMoneyAmount&lt;/code&gt;中包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentMoneyMinorAmount&lt;/code&gt;在数据存储时不会变为decimal而是bigint同时，数据由100.43变为10043&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;订单表&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_ORDER&quot;)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CoffeeOrder implements Serializable {
    @Id
    @GeneratedValue
    private Long id;
    private String customer;
    @ManyToMany
    @JoinTable(name = &quot;T_ORDER_COFFEE&quot;)
    private List&amp;lt;Coffee&amp;gt; items;
    @Column(nullable = false)
    private Integer state;
    @Column(updatable = false)
    @CreationTimestamp
    private Date createTime;
    @UpdateTimestamp
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个表中使用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ManyToMany&lt;/code&gt;表示是多对多，咖啡和订单的关系是通过T_ORDER_COFFEE映射表实现的&lt;/p&gt;

&lt;p&gt;创建父类标签MappedSuperClass因为会有重复定义的模块例如时间和id等，使用MappedSuperClass和各个实体搭配的使用。&lt;/p&gt;

&lt;p&gt;BaseEntity作为父类&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@MappedSuperclass
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BaseEntity implements Serializable {
    @Id
    @GeneratedValue
    private Long id;
    @Column(updatable = false)
    @CreationTimestamp
    private Date createTime;
    @UpdateTimestamp
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子类的coffee表&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_MENU&quot;)
@Builder
@Data
@ToString(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class Coffee extends BaseEntity implements Serializable {
    private String name;
    @Type(type = &quot;org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyAmount&quot;,// 做映射
            parameters = {@org.hibernate.annotations.Parameter(name = &quot;currencyCode&quot;, value = &quot;CNY&quot;)})
    private Money price;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;需要注意，在子类的属性定义中如果使用toString时只会有当前的属性需要额外加上@ToString(callSuper=true)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;在entity中使用枚举&quot;&gt;在entity中使用枚举&lt;/h4&gt;
&lt;p&gt;在订单表中使用枚举&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_ORDER&quot;)
@Data
@ToString(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CoffeeOrder extends BaseEntity implements Serializable {
    private String customer;
    @ManyToMany
    @JoinTable(name = &quot;T_ORDER_COFFEE&quot;)
    @OrderBy(&quot;id&quot;)
    private List&amp;lt;Coffee&amp;gt; items;//设置list是一个顾客会点多个订单
    @Enumerated
    @Column(nullable = false)
    private OrderState state;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;枚举的使用是在OrderState这个地方，另外定义了一个枚举java文件显示了订单的不同状态，但是在数据库中是以数字形式存在的&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enumerated&lt;/code&gt;在hibernate都是把Enum类型的字段映射成基本类型的字段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.jpa.hibernate.ddl-auto=create-drop //每次运行时创建表结构 结束删除
spring.jpa.properties.hibernate.show_sql=true //打印每一条的SQL
spring.jpa.properties.hibernate.format_sql=true // 格式化输出
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Hibernate表结构创建，原先是用schema.sql帮助创建，现在使用Hibernate，这样的好处是不论什么类型的数据库都可以创建&lt;/p&gt;

&lt;h2 id=&quot;通过spring-date-jpa操作数据库&quot;&gt;通过Spring Date JPA操作数据库&lt;/h2&gt;
&lt;p&gt;通过Repository定义一个interface不需要实现，在Java Config上加上@EnableJpaRepostory注解&lt;/p&gt;
&lt;h3 id=&quot;repositoryt-id-接指定实体对象和id&quot;&gt;Repository&amp;lt;T, ID&amp;gt; 接⼝指定实体对象和id&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CrudRepository&amp;lt;T, ID&amp;gt;  基本接口，后面两个都是继承子结构&lt;/li&gt;
  &lt;li&gt;PagingAndSortingRepository&amp;lt;T, ID&amp;gt;&lt;/li&gt;
  &lt;li&gt;JpaRepository&amp;lt;T, ID&amp;gt;扩展了PagingAndSortingRepository加上了findAll等方法，同时extends了QueryByExampleExecutor作为一个Example&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;定义查询&quot;&gt;定义查询&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;find…By… / read…By… / query…By… / get…By…&lt;/li&gt;
  &lt;li&gt;count…By…&lt;/li&gt;
  &lt;li&gt;…OrderBy…[Asc / Desc]&lt;/li&gt;
  &lt;li&gt;And / Or / IgnoreCase&lt;/li&gt;
  &lt;li&gt;Top / First / Distinct&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;分页查询&quot;&gt;分页查询&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;PagingAndSortingRepository&amp;lt;T, ID&amp;gt;&lt;/li&gt;
  &lt;li&gt;Pageable / Sort&lt;/li&gt;
  &lt;li&gt;Slice&lt;T&gt; / Page&lt;T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crud&quot;&gt;CRUD&lt;/h3&gt;
&lt;h4 id=&quot;保存实体&quot;&gt;保存实体&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Coffee latte = Coffee.builder().name(&quot;latte&quot;)
				.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0))
				.build();
coffeeRepository.save(latte);
log.info(&quot;Coffee: {}&quot;, latte);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;coffee表中利用lombok的builder创建的builder对象，指定名字为latte，指定Money类型是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Money.of&lt;/code&gt;，指定了是人民币的30.0，通过builder的build()方法就能创建实例。通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coffeeRepository.save(latte)&lt;/code&gt;就能保存。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CoffeeOrder order = CoffeeOrder.builder()
				.customer(&quot;Li Lei&quot;)
				.items(Collections.singletonList(espresso))
				.state(OrderState.INIT)
				.build();
orderRepository.save(order);
log.info(&quot;Order: {}&quot;, order);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;items在表定义中就是出入list。&lt;/p&gt;
&lt;h4 id=&quot;查询实体&quot;&gt;查询实体&lt;/h4&gt;
&lt;p&gt;创建一个BaseRepository，通用repostory：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@NoRepositoryBean//说明这个baseRepository 不需要加入Bean
public interface BaseRepository&amp;lt;T, Long&amp;gt; extends PagingAndSortingRepository&amp;lt;T, Long&amp;gt; {
    List&amp;lt;T&amp;gt; findTop3ByOrderByUpdateTimeDescIdAsc();//有第一个By 一定要加
    //按照updateTime是降序排序，按照id升序
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;@NoRepositoryBean//说明这个baseRepository 不需要加入Bean&lt;/strong&gt;
为什么&lt;strong&gt;findTop3ByOrderByUpdateTimeDescIdAsc&lt;/strong&gt;中要加上findTop3By，虽然没有传入方法但是一定要传入By进去！！！
子Repository继承格式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public interface CoffeeOrderRepository extends BaseRepository&amp;lt;CoffeeOrder, Long&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;repostory是怎样从接口-变成bean的&quot;&gt;Repostory是怎样从接口 变成Bean的&lt;/h3&gt;
&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;通过mybatis操作数据库&quot;&gt;通过Mybatis操作数据库&lt;/h2&gt;
&lt;p&gt;强调sql映射关系，什么时候使用Mybatis？
当sql语句比较复杂使用Mybatis，因为Mybatis是直接写入SQL语句的。
Mybatis官方支持&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;config
    &lt;ul&gt;
      &lt;li&gt;mybatis.mapper-locations = classpath&lt;em&gt;:mapper/**/&lt;/em&gt;.xml 在所有classpath目录下所有的xml文件都是mybatis映射文件&lt;/li&gt;
      &lt;li&gt;mybatis.type-aliases-package = 类型别名的包名&lt;/li&gt;
      &lt;li&gt;mybatis.type-handlers-package = TypeHandler扫描包名 类型转换时的辅助类，是类型转换的前缀&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mybatis.type-handlers-package=geektime.spring.data.mybatisdemo.handler&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;mybatis.configuration.map-underscore-to-camel-case = true 下划线转驼峰&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mapper 的定义与扫描
    &lt;ul&gt;
      &lt;li&gt;@MapperScan 配置扫描位置&lt;/li&gt;
      &lt;li&gt;@Mapper 定义接⼝&lt;/li&gt;
      &lt;li&gt;映射的定义—— XML 与注解&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mybatis基本用法&quot;&gt;Mybatis基本用法&lt;/h3&gt;
&lt;p&gt;MoneyTypeHandler对Money类型和Long之间做转换，&lt;strong&gt;注意要继承BaseTypeHandler接口&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void setNonNullParameter(PreparedStatement ps, int i, Money parameter, JdbcType jdbcType) throws SQLException {
    ps.setLong(i, parameter.getAmountMinorLong());// 防止数据库注入  PreparedStatement 数据库中存储的是bigint类型 在此处转换为minorlong
}

@Override
public Money getNullableResult(ResultSet rs, String columnName) throws SQLException {//从数据库中取数据 利用ResultSet类型取
    return parseMoney(rs.getLong(columnName));
}

@Override
public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return parseMoney(rs.getLong(columnIndex));
}

@Override
public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return parseMoney(cs.getLong(columnIndex));
}
// 获得金额 转换为Money类型
private Money parseMoney(Long value) {
    return Money.of(CurrencyUnit.of(&quot;CNY&quot;), value / 100.0);
}//of 指定人民币类型
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主程序中的代码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MapperScan(&quot;geektime.spring.data.mybatisdemo.mapper&quot;)// 扫描mapper映射&lt;/code&gt;对应的是一个Mapper&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Mapper // @MapperScan 定义到此处
public interface CoffeeMapper {
    @Insert(&quot;insert into t_coffee (name, price, create_time, update_time)&quot;
            + &quot;values (#{name}, #{price}, now(), now())&quot;)
    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)
      // Save 1 Coffee: Coffee(id=1, name=espresso, price=CNY 20.00, createTime=null, updateTime=null)
    int save(Coffee coffee);// 返回影响的条数 而不是其他

    @Select(&quot;select * from t_coffee where id = #{id}&quot;)
    @Results({
            @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;),
            @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),
            // map-underscore-to-camel-case = true 可以实现一样的效果
            // @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;),
    })
    Coffee findById(@Param(&quot;id&quot;) Long id);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中定义了save 和findById方法，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Option 设置自增主键&lt;/li&gt;
  &lt;li&gt;@Insert @Update @Delete方法返回的都是受更新的影响条数&lt;/li&gt;
  &lt;li&gt;@Param 对@Select 语句中的传入名#{id}赋值&lt;/li&gt;
  &lt;li&gt;@Results 结果集映射 id指定的column是id，id=true说明是主键；property是下划线到驼峰的映射，因为在定义的modal中就是驼峰的但是实际的数据库中使用的是下划线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主程序：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@MapperScan(&quot;geektime.spring.data.mybatisdemo.mapper&quot;)// 扫描mapper映射
public class MybatisDemoApplication implements ApplicationRunner {
	@Autowired
	private CoffeeMapper coffeeMapper;
	public static void main(String[] args) {
		SpringApplication.run(MybatisDemoApplication.class, args);
	}
	@Override
	public void run(ApplicationArguments args) throws Exception {
		Coffee c = Coffee.builder().name(&quot;espresso&quot;)
				.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)).build();
		int count = coffeeMapper.save(c);
		log.info(&quot;Save {} Coffee: {}&quot;, count, c);

		c = Coffee.builder().name(&quot;latte&quot;)
				.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.0)).build();
		count = coffeeMapper.save(c);
		log.info(&quot;Save {} Coffee: {}&quot;, count, c);
//		c = Coffee.builder().name(&quot;sd&quot;).price(Money.of(CurrencyUnit.of))

		c = coffeeMapper.findById(c.getId());
		log.info(&quot;Find Coffee: {}&quot;, c);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上程序定义了在数据库中insert两个，再通过id取出数据，insert的时候没有写时间但是可以在获得数据的时候看到时间因为这两个是数据库自动写入的。&lt;/p&gt;

&lt;h3 id=&quot;让mybatis更好用的工具&quot;&gt;让Mybatis更好用的工具&lt;/h3&gt;
&lt;h4 id=&quot;mybatis-generator&quot;&gt;Mybatis Generator&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://mybatis.org/generator/quickstart.html&quot; target=&quot;_blank&quot;&gt;详细介绍&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;怎样运行mybatis-generator&quot;&gt;怎样运行Mybatis Generator？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;命令行：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java -jar mybatis-generator-core-x.x.x.jar -configfile generatorConfig.xml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Maven Plugin(mybatis-generator-maven-plugin)：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn mybatis-generator:generate&lt;/code&gt;或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${basedir}/src/main/resources/generatorConfig.xml&lt;/code&gt;
    &lt;h5 id=&quot;配置-mybatis-generator&quot;&gt;配置 MyBatis Generator&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;jdbcConnection&lt;/li&gt;
  &lt;li&gt;javaModelGenerator&lt;/li&gt;
  &lt;li&gt;sqlMapGenerator&lt;/li&gt;
  &lt;li&gt;javaClientGenerator (ANNOTATEDMAPPER / XMLMAPPER / MIXEDMAPPER)&lt;/li&gt;
  &lt;li&gt;table&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;生成时可以使用的插件类似于lombok&quot;&gt;生成时可以使用的插件（类似于Lombok）&lt;/h5&gt;
&lt;p&gt;内置插件都在 org.mybatis.generator.plugins 包中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FluentBuilderMethodsPlugin&lt;/li&gt;
  &lt;li&gt;ToStringPlugin&lt;/li&gt;
  &lt;li&gt;SerializablePlugin&lt;/li&gt;
  &lt;li&gt;RowBoundsPlugin&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;使用生成的对象&quot;&gt;使用生成的对象&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;简单操作，直接使⽤⽣成的 xxxMapper 的⽅方法&lt;/li&gt;
  &lt;li&gt;复杂查询，使⽤⽣成的 xxxExample 对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;使用样例&quot;&gt;使用样例&lt;/h5&gt;
&lt;p&gt;pom&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.3.7&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;详见21，主要是通过xml文件帮助写入的。&lt;/p&gt;

&lt;h3 id=&quot;mybatis生成工具pagehelper&quot;&gt;mybatis生成工具PageHelper&lt;/h3&gt;
&lt;p&gt;支持多种数据库分页
详细使用见官网&lt;a href=&quot;https://pagehelper.github.io/&quot; target=&quot;_blank&quot;&gt;PageHelper&lt;/a&gt;
很详细的页面信息的取得！&lt;/p&gt;

&lt;h3 id=&quot;springbuck项目进度&quot;&gt;SpringBuck项目进度&lt;/h3&gt;
&lt;p&gt;通过JPA来实现数据加载&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先了解Example的使用
Example表示在数据使用时对查找的精确匹配程度，是一种模糊查询器。
使用格式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public Optional&amp;lt;Coffee&amp;gt; findOneCoffee(String name) {
    ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher(&quot;name&quot;, exact().ignoreCase());
    Optional&amp;lt;Coffee&amp;gt; coffee = coffeeRepository.findOne(
            Example.of(Coffee.builder().name(name).build(), matcher));
    log.info(&quot;Coffee Found: {}&quot;, coffee);
    return coffee;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到模糊查询的格式是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Example.of(probe, match)&lt;/code&gt;其中probe是实体类，包含用于查询的参数，另一个matcher是比对规则，用于设置比对语句。看到里面的ExampleMatcher使用对象首先实例化&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExampleMatcher matcher = ExampleMatcher.matchig()&lt;/code&gt;具体化怎样查询&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.withMatcher(&quot;name&quot;, exact().ignoreCase()&lt;/code&gt;在name这个property，是精确查询，忽略大小写。&lt;/p&gt;

&lt;p&gt;调用coffeeRepos的findOne方法需要一个Example对象和一个matcher。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在主程序中要保证coffee订单状态是只能从INIT到PAID不能反向。&lt;/strong&gt;
案例中返回的是Optioal主要是为了解决空指针异常，Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;/p&gt;

&lt;h1 id=&quot;chapter3-nosql实践&quot;&gt;Chapter3 NoSql实践&lt;/h1&gt;

&lt;h2 id=&quot;docker开发容器不包括操作系统的细节所以比虚拟机轻量&quot;&gt;docker开发，容器不包括操作系统的细节所以比虚拟机轻量。&lt;/h2&gt;

&lt;p&gt;Docker 使用详见docker使用教程中MongoDB的启动方法&lt;/p&gt;

&lt;h2 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h2&gt;

&lt;h3 id=&quot;mongodbtemplate&quot;&gt;MongoDBTemplate&lt;/h3&gt;

&lt;p&gt;类似于JDBCTemplate Spring Data 提供了MongoDB一套抽象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Data MongoDB
    &lt;ul&gt;
      &lt;li&gt;MongoTemplate&lt;/li&gt;
      &lt;li&gt;Repository 支持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注解
    &lt;ul&gt;
      &lt;li&gt;@Document 对应标定哪个文档&lt;/li&gt;
      &lt;li&gt;@Id&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MongoTemplate
    &lt;ul&gt;
      &lt;li&gt;save / remove&lt;/li&gt;
      &lt;li&gt;Criteria / Query / Update&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在terminal中&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查看有什么数据库&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show dbs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建一个MongoDB的库&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use springbucks&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建有读写权限的⽤户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;db.createUser(
    {
      user: &quot;springbucks&quot;,
      pwd: &quot;springbucks&quot;,
      roles: [
         { role: &quot;readWrite&quot;, db: &quot;springbucks&quot; }
      ]
} )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看用户&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show users&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;在modal中的定义&quot;&gt;在modal中的定义&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Document//标记为文档
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Coffee {
    @Id //这里的Id是import org.springframework.data.annotation.Id;和JPA区分
    private String id;
    private String name;
    private Money price;
    private Date createTime;
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;applicationproperties配置&quot;&gt;application.properties配置&lt;/h3&gt;

&lt;p&gt;定义怎样连接MongoDB&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.data.mongodb.uri=mongodb://springbucks:springbucks@localhost:27017/springbucks&lt;/code&gt;
这个uri的含义是：用到哪个库，用户名密码都是springbucks，访问的是27017的端口使用的是springbucks的库。&lt;/p&gt;

&lt;h3 id=&quot;配置数据类型转换&quot;&gt;配置数据类型转换&lt;/h3&gt;
&lt;p&gt;之前在Mybatis中定义了TypeHandler在MongoDB中同样需要定义Document数据怎样存储Money数据的一种转换，这里使用了MoneyConverter，查看源码，只需要自己定义一个MongoCustomConversions就能在MongoTemplate中使用。
这里定义了一个MoneyReadConverter作用是将document转换为Money对象，在主程序中自定义了一个Bean将这个自定义Converter以列表形式加入。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public MongoCustomConversions mongoCustomConversions() {
  return new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详细的MoneyReadConverter是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import org.bson.Document;
import org.joda.money.CurrencyUnit;
import org.joda.money.Money;
import org.springframework.core.convert.converter.Converter;

public class MoneyReadConverter implements Converter&amp;lt;Document, Money&amp;gt; {
    @Override
    public Money convert(Document source) {
        Document money = (Document) source.get(&quot;money&quot;);
        double amount = Double.parseDouble(money.getString(&quot;amount&quot;));
        String currency = ((Document) money.get(&quot;currency&quot;)).getString(&quot;code&quot;);
        return Money.of(CurrencyUnit.of(currency), amount);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Document中获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Money price&lt;/code&gt;，获得amount，之后获得currency来拼接一个Money对象。这里为什么没有从money到document转换，是因为在序列化时会自动将money对象转化为类似json的bson格式。&lt;/p&gt;

&lt;p&gt;主程序中定义查询条件：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List&amp;lt;Coffee&amp;gt; list = mongoTemplate.find(
    Query.query(Criteria.where(&quot;name&quot;).is(&quot;espresso&quot;)), Coffee.class);
log.info(&quot;Find {} Coffee&quot;, list.size());
list.forEach(c -&amp;gt; log.info(&quot;Coffee {}&quot;, c));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongoTemplate&lt;/code&gt;提供了很多增删改查的方法，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Query.query&lt;/code&gt;用来创建查询，其后可以使用limit和skip等关键字表示限制多少记录和跳过多少记录,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Criteria&lt;/code&gt;定义查询语句，其中可以使用byExample等方法，模糊查询。&lt;/p&gt;

&lt;p&gt;主程序中定义更新操作：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;pdateResult result = mongoTemplate.updateFirst(query(where(&quot;name&quot;).is(&quot;espresso&quot;)),
    new Update().set(&quot;price&quot;, Money.ofMajor(CurrencyUnit.of(&quot;CNY&quot;), 30))
        .currentDate(&quot;updateTime&quot;),
    Coffee.class);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要一个Update对象并设置对象的新值，&lt;strong&gt;注意一定要设置更新时间&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;mongodb-repostory&quot;&gt;MongoDB Repostory&lt;/h3&gt;
&lt;p&gt;pom文件一样，但是主程序上加上了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableMongoRepositories&lt;/code&gt;
之前定义的更新等操作都可以通过Repostory来实现&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;latte.setPrice(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 35.0));
		latte.setUpdateTime(new Date());
		coffeeRepository.save(latte);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对比之前的Update省力&lt;/p&gt;

&lt;h2 id=&quot;redis&quot;&gt;Redis&lt;/h2&gt;
&lt;p&gt;Spring对Redis的支持，通过Spring Data Redis，支持的客户端是Jedis,RedisTemplate和 Repository支持。作为非持久化的存储，可丢失可从数据库中再拿出来。&lt;/p&gt;

&lt;h3 id=&quot;jedis客户端使用事项&quot;&gt;Jedis客户端使用事项&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Jedis 不不是线程安全的&lt;/li&gt;
  &lt;li&gt;通过 JedisPool 获得 Jedis 实例&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接使⽤用 Jedis 中的方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;将所有以redis打头的属性赋值给JedisPoolConfig&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
@ConfigurationProperties(&quot;redis&quot;)
public JedisPoolConfig jedisPoolConfig() {
  return new JedisPoolConfig();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;JedisPool的构造方法构造一个JedisPool，destroyMethod表示在关闭这个Bean时去调用close方法，数据不用的时候就将其放到池中，关闭连接但是保留操作。通过@Value输入目标Jedis需要连接的一个host&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean(destroyMethod = &quot;close&quot;)
public JedisPool jedisPool(@Value(&quot;${redis.host}&quot;) String host) {
  return new JedisPool(jedisPoolConfig(), host);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在pom文件中传入需要的redis客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在application.property中配置redis&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;redis.host=localhost
redis.maxTotal=5
redis.maxIdle=5
redis.testOnBorrow=true

#redis.max-total=3
#redis.max-idle=3
#redis.test-on-borrow=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意这里的max-total 和 maxTotal含义是相同的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在主程序中
使用java中的try-with-resource&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;try (Jedis jedis = jedisPool.getResource()) {
  coffeeService.findAllCoffee().forEach(c -&amp;gt; {
    jedis.hset(&quot;springbucks-menu&quot;,
        c.getName(),
        Long.toString(c.getPrice().getAmountMinorLong()));
  });

  Map&amp;lt;String, String&amp;gt; menu = jedis.hgetAll(&quot;springbucks-menu&quot;);
  log.info(&quot;Menu: {}&quot;, menu);

  String price = jedis.hget(&quot;springbucks-menu&quot;, &quot;espresso&quot;);
  log.info(&quot;espresso - {}&quot;,
      Money.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(price)));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在jedisPool中取到一个jedis实例，不用自己做jedis close 在try结束之后java会帮助关闭。通过jpa的coffeeService获得所有coffee的名字和minorAmount放入到springbucks-menu的一个hash中，hash的key是name，value是金额；通过jedis的hgetAll取出springbucks-menu。用hget取得一个金额找到key为espresso的value再将这个value 转换为money&lt;/p&gt;

&lt;h3 id=&quot;redis-部署模式&quot;&gt;redis 部署模式&lt;/h3&gt;

&lt;h4 id=&quot;哨兵sentine&quot;&gt;哨兵Sentine&lt;/h4&gt;

&lt;p&gt;监控，通知和故障迁移，使用JedisSentinePool&lt;/p&gt;

&lt;h4 id=&quot;集群cluster&quot;&gt;集群Cluster&lt;/h4&gt;

&lt;p&gt;redis Cluster 自动做了数据的分片，所以在部分节点失效的时候还是有可用性的，在单节点也就是没有集群的redis上可以对key进行批量操作，但是在Cluster上就无法做，因为key会分散在不同的集群中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JedisCluster&lt;/strong&gt;
Jedis只能从master读取数据，如果想要读写分离可以定制&lt;/p&gt;

&lt;p&gt;实际案例：
JedisCluster继承BinaryJedisCluster，传入jedis的节点列表通过构造方法创建&lt;/p&gt;

&lt;p&gt;看redis的cluster&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;spring的缓存抽象&quot;&gt;Spring的缓存抽象&lt;/h2&gt;
&lt;p&gt;为不同的缓存提供一层抽象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;为java方法增加缓存，缓存结果执行&lt;/li&gt;
  &lt;li&gt;支持不同的缓存后端ConcurrentMap、EhCache、Caffeine、JCache(JSR-107)&lt;/li&gt;
  &lt;li&gt;接口 org.springframework.cache.Cache，org.springframework.cache.CacheManager&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不同类型缓存使用场景&quot;&gt;不同类型缓存使用场景&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;长久不变的信息（一天都不会变的）接收一定延迟性：界面内部缓存，设置过期时间，自动过期之后再去后端获得。&lt;/li&gt;
  &lt;li&gt;在集群内部要求一致性：分布式缓存 例如redis&lt;/li&gt;
  &lt;li&gt;数据读写比不好（写一次，读一次）： 没必要缓存只有在写一次读10次这样的使用缓存比较好&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于缓存抽象的注解&quot;&gt;基于缓存抽象的注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@EnableCaching开启注解
    &lt;ul&gt;
      &lt;li&gt;@Cacheable 如果方法已经在缓存中就直接去取，如果不在里面就去执行，在执行之后将结果放入缓存&lt;/li&gt;
      &lt;li&gt;@CacheEvict 缓存清理&lt;/li&gt;
      &lt;li&gt;@CachePut 不管方法的执行情况，直接去做缓存的设置&lt;/li&gt;
      &lt;li&gt;@Caching 对以上的内容进行打包，在里面放入多个操作&lt;/li&gt;
      &lt;li&gt;@CacheConfig 对缓存进行设置，缓存名etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缓存抽象在界面中做缓存的例子&quot;&gt;缓存抽象在界面中做缓存的例子&lt;/h3&gt;
&lt;p&gt;相对于redis缓存这里的界面缓存提供了另一种缓存方式&lt;/p&gt;

&lt;p&gt;在service中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Slf4j
@Service
@CacheConfig(cacheNames = &quot;coffee&quot;)//设置缓存名
public class CoffeeService {
  @Autowired
  private CoffeeRepository coffeeRepository;

  @Cacheable
  public List&amp;lt;Coffee&amp;gt; findAllCoffee() {
      return coffeeRepository.findAll();
  }

  @CacheEvict
  public void reloadCoffee() {
  }
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码就是在征程使用findAllCoffee方法的时候使用缓存的形式。在主程序加载的时候加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableCaching(proxyTargetClass = true)&lt;/code&gt;拦截类的执行。这里说明缓存的加载机制是基于AOP的。&lt;/p&gt;

&lt;h3 id=&quot;缓存抽象以redis作为缓存的例子&quot;&gt;缓存抽象以redis作为缓存的例子&lt;/h3&gt;

&lt;p&gt;需要引入pom&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写入application.property&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.cache.type=redis
spring.cache.cache-names=coffee
spring.cache.redis.time-to-live=5000 # 缓存的ttl时间是5秒
spring.cache.redis.cache-null-values=false

spring.redis.host=localhost
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在具体的coffeeService上加上了cacheable注解，&lt;strong&gt;在具体的创建中在start.spring.io里面需要勾选cache的缓存抽象和Nonsql里面的redis来创建&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-data-redis-实现细节&quot;&gt;Spring Data Redis 实现细节&lt;/h3&gt;

&lt;h4 id=&quot;配置连接工厂&quot;&gt;配置连接工厂&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RedisStandaloneConfiguration 单节点&lt;/li&gt;
  &lt;li&gt;RedisSentinelConfiguration 哨兵&lt;/li&gt;
  &lt;li&gt;RedisClusterConfiguration 集群&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要的配置信息是在RedisProperties对应的前缀 prefix 是Spring.redis，与jedis和lettse相关信息都在此处&lt;/p&gt;

&lt;h4 id=&quot;redistemplate&quot;&gt;RedisTemplate&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;设置过期时间&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RedisTemplate&amp;lt;K, V&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;opsForXxx()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;StringRedisTemplate&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;样例&quot;&gt;样例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.redis.host=localhost
spring.redis.lettuce.pool.maxActive=5
spring.redis.lettuce.pool.maxIdle=5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本地docker启动的redis，配置lettuce连接池。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在coffeeService里做了缓存的设置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redisTemplate.opsForHash&lt;/code&gt;到redis里面取到一个hash，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasKey&lt;/code&gt;查看里面有没有这个key也就是传入的name，如果有就获得这个缓存直接返回，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; return Optional.of(hashOperations.get(CACHE, name));&lt;/code&gt;，如果没有就通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; hashOperations.put(CACHE, name, coffee.get());&lt;/code&gt;将这个新的coffee查找出的对象放入缓存，之后再设置过期时间&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Autowired
private RedisTemplate&amp;lt;String, Coffee&amp;gt; redisTemplate;
...
public Optional&amp;lt;Coffee&amp;gt; findOneCoffee(String name) {
    HashOperations&amp;lt;String, String, Coffee&amp;gt; hashOperations = redisTemplate.opsForHash();
    if (redisTemplate.hasKey(CACHE) &amp;amp;&amp;amp; hashOperations.hasKey(CACHE, name)) {
        log.info(&quot;Get coffee {} from Redis.&quot;, name);
        return Optional.of(hashOperations.get(CACHE, name));
    }
    ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher(&quot;name&quot;, exact().ignoreCase());
    Optional&amp;lt;Coffee&amp;gt; coffee = coffeeRepository.findOne(
            Example.of(Coffee.builder().name(name).build(), matcher));
    log.info(&quot;Coffee Found: {}&quot;, coffee);
    if (coffee.isPresent()) {
        log.info(&quot;Put coffee {} to Redis.&quot;, name);
        hashOperations.put(CACHE, name, coffee.get());
        redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);
    }
    return coffee;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在SpringBuckesApplication中设置的是实现方法
RedisTemplate 在SpringBoot中提供了一种Object类型的Template，需要自定义一个需要类型的Template&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public RedisTemplate&amp;lt;String, Coffee&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
  RedisTemplate&amp;lt;String, Coffee&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
  template.setConnectionFactory(redisConnectionFactory);
  return template;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的实现类只能是存入的需要序列化的内容，对于String类型有专门对stringRedisTemplate执行，但是对于其他的散列等类型需要加上Redis的序列化器来实现。在Redis里面就是字符串，需要美化&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostConstruct
public void init(){
  initRedisTemplate();
}
private void initRedisTemplate(){
  RedisSerializer stringSerializer = redisTemplate.getStringSerializer();
  redisTemplate.setKeySerializer(stringSerializer);
  redisTemplate.setHashKeySerializer(stringSerializer);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码是将键和散列数据类型的field修改为使用StringRedisSerializer序列化，在Redis服务器上得到的键值对和散列对象就是以字符串形式存储了。&lt;/p&gt;

&lt;h4 id=&quot;redis-repository&quot;&gt;Redis Repository&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;实体注解
    &lt;ul&gt;
      &lt;li&gt;@RedisHash&lt;/li&gt;
      &lt;li&gt;@Id&lt;/li&gt;
      &lt;li&gt;@Indexed 因为有key value属性需要加上二级索引&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;区分多个Repository
    &lt;ul&gt;
      &lt;li&gt;根据数据上的注解&lt;/li&gt;
      &lt;li&gt;根据继承接口的类型&lt;/li&gt;
      &lt;li&gt;扫描不同的包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对应实现中如果有不同类型，比如Money类型读入到Redis的Byte中，需要继承SpringBoot中的Converter接口，要自己写读写方法，在redis-repository-demo中对应配置了两个converter&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MoneyToBytesConverter 表示将Money转化为byte时往redis中写的时候用的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import org.joda.money.Money;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;

import java.nio.charset.StandardCharsets;

@WritingConverter
public class MoneyToBytesConverter implements Converter&amp;lt;Money, byte[]&amp;gt; {
    @Override
    public byte[] convert(Money source) {
        String value = Long.toString(source.getAmountMinorLong());
        return value.getBytes(StandardCharsets.UTF_8);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;BytesToMoneyConverter 注意注解是@ReadingConverter表示从Redis读的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import org.joda.money.CurrencyUnit;
import org.joda.money.Money;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;

import java.nio.charset.StandardCharsets;

@ReadingConverter
public class BytesToMoneyConverter implements Converter&amp;lt;byte[], Money&amp;gt; {
    @Override
    public Money convert(byte[] source) {
        String value = new String(source, StandardCharsets.UTF_8);
        return Money.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(value));
    }
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;主程序中实现的redis converter 的注册&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public RedisCustomConversions redisCustomConversions() {
  return new RedisCustomConversions(
      Arrays.asList(new MoneyToBytesConverter(), new BytesToMoneyConverter()));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些疑问&quot;&gt;一些疑问&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;为什么有了Redis Template 又要用 Redis Repository?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按ID存了一个数据到Redis里，但又希望能按别的维度来查询时，一种方式就是自己维护二级索引，而RedisRepository可以帮你做这个二级索引，让你根据自己需要来查询。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;redis哨兵和集群模式&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Redis sentinel&lt;/em&gt;&lt;/strong&gt; 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;监控（Monitoring）：Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。&lt;/p&gt;

&lt;p&gt;提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。&lt;/p&gt;

&lt;p&gt;自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;1、保证高可用&lt;/p&gt;

&lt;p&gt;2、监控各个节点&lt;/p&gt;

&lt;p&gt;3、自动故障迁移&lt;/p&gt;

&lt;p&gt;缺点：主从模式，切换需要时间丢数据&lt;/p&gt;

&lt;p&gt;没有解决 master 写的压力&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Redis cluster&lt;/em&gt;&lt;/strong&gt; 从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。&lt;/p&gt;

&lt;p&gt;2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。&lt;/p&gt;

&lt;p&gt;3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。&lt;/p&gt;

&lt;p&gt;4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本&lt;/p&gt;

&lt;p&gt;5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;1、资源隔离性较差，容易出现相互影响的情况。&lt;/p&gt;

&lt;p&gt;2、数据通过异步复制,不保证数据的强一致性&lt;/p&gt;

&lt;h4 id=&quot;一些注意细节&quot;&gt;一些注意细节&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;redis 一定要设计过期时间&lt;/li&gt;
  &lt;li&gt;redis的max-redirect最好是设置为3，设置最大的重定向次数的，RedisCluster里，你把请求发到了某个节点上，它发现这个KEY不在自己这里，就会告诉你重定向到另一个节点上去找。&lt;/li&gt;
  &lt;li&gt;总结一下 &lt;strong&gt;缓存抽象 redisRepository redisTemplate&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;缓存抽象（@Cacheable 等注解），Spring 通过 aop 实现了缓存功能，底层不一定是 redis，也可能是 jvm 缓存，memcached等。&lt;/li&gt;
      &lt;li&gt;redisRepository，类比 mysql 的 repository 操作，如 CrudRepository，帮我们实现了操作缓存的功能&lt;/li&gt;
      &lt;li&gt;redisTemplate，类比 jdbcTemplate，提供更底层的原始命令，由开发自行实现一些功能，更灵活&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/23/Spring01/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/23/Spring01/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>All kind of database</category>
        
        <category>JPA</category>
        
        <category>NoSql</category>
        
        <category>RabitMQ</category>
        
        <category>self-learning</category>
        
        
      </item>
    
  </channel>
</rss>
