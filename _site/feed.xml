<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joy Blog</title>
    <description>季月侣的Blog || About Joy </description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 18 Oct 2020 10:13:22 +0800</pubDate>
    <lastBuildDate>Sun, 18 Oct 2020 10:13:22 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title> React Hooks </title>
        <description>&lt;h2 id=&quot;react-的class-based--和-functional-based-的component&quot;&gt;React 的class-based  和 functional-based 的component&lt;/h2&gt;
&lt;p&gt;在实现时，functional-based可以实现class-based功能，一般情况下lifecycle可以用hook代替&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;命名规则 useXYZ()&lt;/li&gt;
  &lt;li&gt;只在react 16.8以上版本能用
    &lt;h2 id=&quot;开始使用&quot;&gt;开始使用&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用样例通过输入ingredient的载入ingredient的描述和数量并且能点击下面的ingredientlist-删除-ingredient&quot;&gt;使用样例，通过输入ingredient的载入ingredient的描述和数量，并且能点击下面的IngredientList 删除 ingredient&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;导入useState&lt;/strong&gt;,这个相当于class-base中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state = {}&lt;/code&gt;不同之处在于useState可以实现传入各种类型的数据，其中有两个参数，一个是当前state的 snapshot 另一个就是如何更新这个state&lt;/li&gt;
  &lt;li&gt;使用ES6的extract方法实现的state赋值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const [inputState,setInputState]=useState({ title: '', amount: '' });
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;也可以替换成以下的形式
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const [enteredTitle, setEnteredTitle] = useState(&quot;&quot;);
const [enteredAmount, setEnteredAmount] = useState(&quot;&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;怎样use hooks
    &lt;ul&gt;
      &lt;li&gt;必须是在function component或者自定义hook中使用&lt;/li&gt;
      &lt;li&gt;必须在root level使用hook，不能再一个function component中嵌套使用 hook，也不能在if语句中使用hook&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fetch Data from firebase
通过创建新的real time firebase 使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch()&lt;/code&gt;是一种browser能识别的代码表示从http中获取数据。
&lt;strong&gt;小知识点&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;json =&amp;gt; js code &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jsonCode.json()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;js code =&amp;gt; json &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON.stringify(jsCode)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  fetch(&quot;https://react-hook-example-xxxee.firebaseio.com/ingredient.json&quot;,//样例URL
      {
        method: &quot;POST&quot;,
        body: JSON.stringify(ingredient),
        headers: { 'Content-Type': 'application.json' }
      }).then(response =&amp;gt; {
        return response.json()
      }).then(responseData =&amp;gt; {// responseData是response 中的属性名 包含 firebase中赋予的id
        setIngredients(prevIngredients =&amp;gt; [...prevIngredients,
        {
          id: responseData.name,// responseData来源于firebase
          ...ingredient
        }
        ])
      })
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里使用两个then因为return response.json()返回的是一个promise所以对其内部做处理需要再加一个then。第一个then获得的数据如下图
&lt;img src=&quot;/img/react-hook-fetch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;useEffect hook&lt;/strong&gt;
这个hook表示在页面每一次render完成之后再加载的动作，用于消除&lt;strong&gt;side effect&lt;/strong&gt;，没有加入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;依赖，相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentDidUpdate&lt;/code&gt;
传入一个匿名函数以及函数中变量用到的依赖，只有这个依赖改变，才会rerun这个页面。所以加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;表示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentDidMount&lt;/code&gt;所以&lt;strong&gt;&lt;em&gt;一定要加[],哪怕没有依赖也要加&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;注意，如果是因为在props中的传入的function改变，需要加入depend中需要转化格式&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const {propsValue} = props;
...
useEffect = (()=&amp;gt;{...},[propsValue]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;案例分析如何给页面加上一个可搜索的方法&quot;&gt;案例分析，如何给页面加上一个可搜索的方法？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先需要对useEffect 中设置fetch保证每次输入都能匹配数据库中的某个固定字段&lt;/li&gt;
  &lt;li&gt;在数据库（后端）配置这个字段，也就是firebase中在rules中将这个地方加上传入数据库的字段，以下内容表示在ingredient传入时也就是fetch的url最后加上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ingredient.json&lt;/code&gt;中post的title字段为搜索中需要修改的地方。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
&quot;rules&quot;: {
  &quot;.read&quot;: &quot;now &amp;lt; 1605024000000&quot;,  // 2020-11-11
  &quot;.write&quot;: &quot;now &amp;lt; 1605024000000&quot;,  // 2020-11-11
    &quot;ingredients&quot;:{
      &quot;.indexOn&quot;:[&quot;title&quot;]
    }
}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在useEffect中写入需要到数据库中匹配的字段，每次输入的值是通过html中onChange执行的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以下的代码中注意query字段，表示判断输入值是否为空，如果不为空就需要到数据库中取数据。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;useEffect = (() =&amp;gt; {
    const query = enteredFilter.length === 0 ? '' 
    : `?orderBy=&quot;title&quot;&amp;amp;equalTo=&quot;${enteredFilter}&quot;`;//注意不要丢到=号

    fetch(&quot;https://react-hook-example-xxxee.firebaseio.com/ingredient.json&quot; + query)
      .then(response =&amp;gt; {
        return response.json();
      })
      .then(responseData =&amp;gt; {
        const loadResponseData = [];
        for (const key in responseData) {
          loadResponseData.push({
            id: key,
            title: responseData[key].title,
            amount: responseData[key].amount
          });
        }
        onLoadingIngredients(loadResponseData);
      })

  }, [enteredFilter,onLoadingIngredients]);//每次enteredFilter改变就会执行
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;onLoadingIngredients这个依赖&lt;/strong&gt;是调用component时赋给的一个props，已经通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const {propsValue} = props;&lt;/code&gt;取出，表示如果这个component被重新调用就再次调用useEffect,parant component re-render&lt;/p&gt;

&lt;h3 id=&quot;usecallback-hook&quot;&gt;&lt;strong&gt;useCallback hook&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;作用于会导致两个component一直渲染的页面，因为子页面利用父页面传过来的方法作为useEffect的依赖，只要useEffect依赖改变，子页面也就会重新渲染，但是父页面中传入到子页面的方法在被子页面调用之后，在父页面进行了重新渲染，从而带动子页面的渲染形成闭环，useCallback就是保持父页面中的内容没有因为子页面重新渲染而改变，作为一个cache。&lt;/p&gt;

&lt;p&gt;useCallback 用法和useEffect相同，也需要加上依赖参数，如果是useState作为依赖参数则可以忽略不加。&lt;/p&gt;

&lt;h3 id=&quot;useref-hook&quot;&gt;&lt;strong&gt;useRef hook&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;useRef是为了获得最新的state中的数据，在useEffect中setTimeout时希望判断两次输入时间间隔不小于多少秒，而且需要一边输入一边对比，就需要用到useRef。setTimeout内部获得的useState表示在运行到setTimeout时获得的state，但对于一直更新的state需要通过useRef获得。
使用方式如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;先引入useRef  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import {useRef} from 'react'&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;定义一个useRef &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const inputRef = useRef()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在html处定义ref &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input ref={inputRef}/&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在setTimeout处使用ref
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  setTimeout(() =&amp;gt; {
if (enteredFilter === inputRef.current.value) {
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;主要用于解决用户输入时为了不要一直获取用户输入而频繁的render到后端的问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;useeffect的cleanup&quot;&gt;&lt;strong&gt;useEffect的cleanUp&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在上面的例子中，如果用户输入时间过长但是一直匹配到正确结果的情况下，需要clean useEffect的使用，（setTimeout 是在useEffect中的）所以每次depend改变需要re-render时，才执行return，也就是clean
具体使用方式如下: return 一定是一个func，当depend为空也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;时，return发生时间变为component为unmount时。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;useEffect(() =&amp;gt; {
    const timer = setTimeout(() =&amp;gt; {
      if (enteredFilter === inputRef.current.value) {
        ...
      }
    },5000);
    return ()=&amp;gt;{cleanTimeout(timer)};
},[]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;return中执行的就是clean useEffect的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;小知识点&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在代码中的三段表达式：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; A ? B: C&lt;/code&gt;如果C是null则可以写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A &amp;amp;&amp;amp; B&lt;/code&gt;形式&lt;/li&gt;
  &lt;li&gt;在代码中两个setState一起执行不会导致死循环情况，因为state会预先存在batch中，原先的会保留并且在同一个render中执行，两个state同时执行，并且有交叉关系再执行时是没有冲突的。对于两个setState同时执行的情况&lt;a href=&quot;https://github.com/facebook/react/issues/10231#issuecomment-316644950&quot; target=&quot;_blank&quot;&gt;github issue&lt;/a&gt;
具体解释如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;more-on-state-batching--state-update&quot;&gt;more on state batching &amp;amp;&amp;amp; state update&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;setName('Max');
setAge(30);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;in the same synchronous (!) execution cycle (e.g. in the same function) will NOT trigger two component re-render cycles.&lt;/p&gt;

&lt;p&gt;Instead, the component will only re-render once and both state updates will be applied simultaneously.&lt;/p&gt;

&lt;p&gt;Not directly related, but also sometimes misunderstood, is when the new state value is available.&lt;/p&gt;

&lt;p&gt;Consider this code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;console.log(name); // prints name state, e.g. 'Manu'
setName('Max');
console.log(name); // ??? what gets printed? 'Max'?
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You could think that accessing the name state after setName(‘Max’); should yield the new value (e.g. ‘Max’) but this is NOT the case. Keep in mind, that the new state value is &lt;strong&gt;only available in the next component render cycle&lt;/strong&gt; (which gets scheduled by calling setName()).&lt;/p&gt;

&lt;p&gt;Both concepts (batching and when new state is available) behave in the same way for both functional components with hooks as well as class-based components with this.setState()!&lt;/p&gt;

&lt;h3 id=&quot;usereducer&quot;&gt;&lt;strong&gt;useReducer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;类似于reducer的一种方式，因为定义了大量的useState，所以可以将多个reducer整合。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先在component外层定义useReducer，因为每次外层的定义是不会随着component一起render的。useReducer和基础的redux的reducer定义类似。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const ingredientReducer = (currentIngredients, action)=&amp;gt;{
  switch(action.type){
    case &quot;SET&quot;:
      return action.ingredient
    case &quot;ADD&quot;:
      return [...currentIngredients, action.ingredient]
    case &quot;DELETE&quot;:
      return currentIngredients.filter(ing =&amp;gt;ing.id !== action.id)
    default:
      throw new Error(&quot;should not go hear!&quot;)
  }
}

const ExampleComponent = ()=&amp;gt;{...}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;每个action后面跟的就是在调用dispatch时需要传入的参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在component内部导入刚刚定义的reducer
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const ExampleComponent = ()=&amp;gt;{
const [ingredients, dispatch] = useReducer(ingredientReducer,[])
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传入的两个参数第一个是前面定义的array第二个是start state，注意从useReducer中提取的第二个参数，是用来代替setState方法的，名字可以自行定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代替setState，以下是几个state案例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// setIngredients(prevIngredients =&amp;gt; [...prevIngredients,
  // {
  //   id: responseData.name,
  //   ...ingredient
  // }
  // ])
  dispatch({
    type: &quot;ADD&quot;, ingredient: {
      id: responseData.name,
      ...ingredient
    }
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// setIngredients(prevIngredients =&amp;gt; prevIngredients.filter(
//   (ingredient) =&amp;gt; ingredient.id !== ingredientId))
dispatch({type:&quot;DELETE&quot;,id:ingredientId})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const filterIngredientsHandler = useCallback((filterIngredients) =&amp;gt; {
    // setIngredients(filterIngredients)
    dispatch({ type: &quot;SET&quot;, ingredients: filterIngredients });
  }, [])
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;综上，useReducer可以使用的情况是在每个state有不同的使用状态时，或者一个方法组要改多个state时，放在一起定义。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;usecontext&quot;&gt;&lt;strong&gt;useContext&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;用法是将需要层层传递的某个state利用这种形式获得，类似于redux但是是react自带的方法，主要用于function base component中详见react笔记那篇文章。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React, { useState } from 'react';
export const AuthContext = React.createContext({
isAuth: false,
login: () =&amp;gt; {}
})

const AuthContextProvider = (props) =&amp;gt; {
    const [isAuth, setIsAuth] = useState(false);
    const loginHandler = () =&amp;gt; {
        setIsAuth(true)
    }
    return (
        &amp;lt;AuthContext.Provider value=&amp;gt;
            {props.children}
        &amp;lt;/AuthContext.Provider&amp;gt;
    )
}
export default AuthContextProvider;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在index.js中利用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;AuthContextProvider&amp;gt;&lt;/code&gt;包裹住&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;表示所有需要用到AuthContext地方被表示为Provider,在需要用到的是否login的地方写入以下代码（此处是在App主界面），注意定义中先export的并不是default的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthContextProvider&lt;/code&gt;而是包含默认值的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthContext&lt;/code&gt;所以在导入的时候是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{AuthContext}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { AuthContext } from './context/auth-context';   

const App = props =&amp;gt; {
const authContext = useContext(AuthContext);
let content = &amp;lt;Auth /&amp;gt;
if (authContext.isAuth) {
    content = &amp;lt;Ingredients/&amp;gt;
}
return (
    // &amp;lt;AuthContext.Consumer&amp;gt;
    // &amp;lt;Auth /&amp;gt;
    // &amp;lt;/AuthContext.Consumer&amp;gt;
    {content}
    )
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在需要auth的界面中显示&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import {AuthContext} from '../context/auth-context';

const Auth = props =&amp;gt; {
const authContext = useContext(AuthContext);
const loginHandler = () =&amp;gt; {
    authContext.login();//改变login中的state从而在App主界面转换为&amp;lt;Ingredients/&amp;gt;
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;usememo&quot;&gt;&lt;strong&gt;useMemo&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在react笔记中介绍过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;的用法，这里是利用useMemo进行扩展。原来是作用在component定义中，useMemo是直接作用在component调用的时候。传入的是一个方法，作用是保存一些需要花费时间渲染的component，只有在其中有值改变的时候才回去渲染。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const ingredientList = useMemo(() =&amp;gt; {
  return (
    &amp;lt;IngredientList ingredients={ingredients} onRemoveItem={removeIngredientHandler} /&amp;gt;
  )
}, [ingredients])//依赖
...
在render中
{ingredientList}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是用到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;则是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const IngredientList =React.memo(props =&amp;gt; {
  return (...)})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;自制hook&quot;&gt;自制Hook&lt;/h2&gt;
&lt;p&gt;最重要一点需要以use作为开头&lt;/p&gt;

&lt;p&gt;自制的Hook首先是一个匿名方法，对渲染的优先顺序可以使用useCallback来限制&lt;/p&gt;

&lt;h2 id=&quot;将hook作用到实际的开发中&quot;&gt;将hook作用到实际的开发中&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先利用React.lazy()代替原先的自定义懒加载，毕竟原先的代码中包含了class base的component，具体代码见react-axios的那篇文章。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和React.lazy包裹搭配使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Suspend&amp;gt;&lt;/code&gt;，是对route中在没有实现加载时在页面上显示的内容，具体是:
```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;Suspense fallback={&amp;lt;p&amp;gt;Loading…&amp;lt;/p&amp;gt;}&amp;gt;
        {routes}
&amp;lt;/Suspense&amp;gt;
```
包裹住自定义的route，并且将router修改为render跳转而不是component跳转&amp;gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果是要执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentWillMount&lt;/code&gt;表示在component加载之前执行，所以把代码前移，放在return之前。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentWillUnmount&lt;/code&gt;作为放在最后作为页面加载完毕清除缓存的控件可以利用useEffect的return实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/30/ReactHooks/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/ReactHooks/</guid>
        
        <category>react hooks</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> webpack </title>
        <description>&lt;p&gt;&lt;strong&gt;申明 create-react-app已经足够日常使用，webpack配置较为麻烦，实力劝退，而且版本更新换代较快，不建议使用。一口气学完之后感觉像是满口塞了泡菜般的有话说不出&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-it-work&quot;&gt;How it work&lt;/h2&gt;
&lt;p&gt;entry(app.js)Multiple entry points are posible —&amp;gt;&lt;/p&gt;

&lt;p&gt;—&amp;gt; Loaders(babel-loader,css-loader) File type dependent transformations&lt;/p&gt;

&lt;p&gt;—&amp;gt; Plugins(uglify)Global transformations&lt;/p&gt;

&lt;p&gt;—&amp;gt; output(bundle.js) Correctly ordered concatenated output&lt;/p&gt;

&lt;h2 id=&quot;basic-workflow-requirements-create-react-app帮我们做的事情&quot;&gt;Basic Workflow Requirements create-react-app帮我们做的事情&lt;/h2&gt;

&lt;p&gt;compile js code&lt;/p&gt;

&lt;p&gt;handle jsx&lt;/p&gt;

&lt;p&gt;css auto prefix&lt;/p&gt;

&lt;p&gt;support image support&lt;/p&gt;

&lt;p&gt;optimize code&lt;/p&gt;

&lt;h2 id=&quot;创建新的文件夹并在其下运行&quot;&gt;创建新的文件夹并在其下运行&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm init&lt;/code&gt;一路回车&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev webpack webpack-dev-server&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在总目录下建立src目录&lt;/li&gt;
  &lt;li&gt;npm install –save 需要的东西&lt;/li&gt;
  &lt;li&gt;在package.json文件中的script下配置
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;start&quot;:&quot;webpack-dev-server&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack-cli&lt;/code&gt;使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev webpack-cli&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在package.json文件同级创建文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;告知webpack读取这个文件。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/&quot; target=&quot;_blank&quot;&gt;webpack文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;写入webpackconfigjs文件&quot;&gt;写入webpack.config.js文件&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const path= require('path');

module.exports={
    mode: 'devlopment',//设置之后不会自动压缩代码
    entry:'./src/index.js',
    output:{
        // path 的名字表示当前页面的名字
        path:path.resolve(__dirname,'react-webpack'),
        filename: 'bundle.js',
        publicPath: ''
    },
    devtool: 'cheap-module-source-map'
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;加入-babel&quot;&gt;加入 babel&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-2 babel-loader @babel/plugin-proposal-class-properties&lt;/code&gt;需要初始化以上&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在devtool下面加上文件读取的rules
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; module:{
   rules:[
     {
       // test告知以js为结尾都会遵循以下的rule
       test:/\.js$/,
       // loader告知以什么形式加载
       loader:'babel-loader',
       // 不读取哪些内容
       exclude:/node_modules/
     }
   ]
 }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在package.json文件同级加上文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;babel自动读取这个文件，写入json文件
    &lt;ul&gt;
      &lt;li&gt;presets是babel给的browser的屏幕宽度等参数&lt;/li&gt;
      &lt;li&gt;plugins是写入什么形式babel会帮助
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
 &quot;presets&quot;: [
   [
       &quot;@babel/preset-env&quot;,
       {
           &quot;targets&quot;: {
               &quot;browsers&quot;: [
                   &quot;&amp;gt;1%&quot;,
                   &quot;last 2 version&quot;
               ]
           }
       }
   ],
   &quot;@babel/preset-react&quot;
 ],
 &quot;plugins&quot;: [
   &quot;@babel/plugin-proposal-class-properties&quot;
 ]
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;加载读取css文件的控件&quot;&gt;加载读取css文件的控件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev style-loader css-loader file-loader&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;写入能够读取css的rules，在以上定义的modules内&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
  test:/\.css$/,
  exclude:/node_modules/,
  use: [
    {loader: 'style-loader'},
    {loader: 'css-loader', options:{
        importLoaders: 1,
        modules: {
            localIdentName: '[name]__[local]__[hash:base64:5]'
        }
    }}
  ] 
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev postcss-loader&lt;/code&gt; 这个控件可以将react中的css以oldHtml的语法加入到页面中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev autoprefixer&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postcss-loader&lt;/code&gt;控件中options需要载入的控件，这里加载时需要在页面中先定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autoprefixer&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const autoprefixer = require('autoprefixer');&lt;/code&gt;类似于定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;use: [
  { loader: 'style-loader' },
  {
    loader: 'css-loader',
    options: {
      importLoaders: 1,
      modules: {
        localIdentName: '[name]__[local]__[hash:base64:5]'
      }
    }
  },
  {
    loader:'postcss-loader',options:{
      ident:'postcss',
      plugins: ()=&amp;gt;[autoprefixer()]
    }
  }
]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autoprefixer&lt;/code&gt;控件是告知页面是以什么样的形式打开，需要在package.json文件中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;license&quot;&lt;/code&gt;同级中写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;browserslist&quot;: &quot;&amp;gt;1%,last 2 version&quot;&lt;/code&gt;，这里的&lt;strong&gt;browserlist&lt;/strong&gt;对应了&lt;strong&gt;babelrc&lt;/strong&gt;中的&lt;strong&gt;browsers&lt;/strong&gt;属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;页面加载image&quot;&gt;页面加载image&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev url-loader&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入rules&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
  test:/\.(png|jpe?g|gif)$/,
  //loader ?之后的内容表示 照片存储的位置[name]是照片名,[ext]表示扩展名 extension
  loader:'url-loader?limit=8000&amp;amp;name=images/[name].[ext]'
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev html-webpack-plugin&lt;/code&gt;将style写入bundle.js，同时在config文件中定义
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const HtmlWbpackPlugin = require('html-webpack-plugin');
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;方便后面调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在config文件中，module之后定义一个plugins，告诉webpack要以index.html中的语法作为基本语法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;plugins:[
        new HtmlWbpackPlugin({
            template: __dirname + './src/index.html',
            filename: 'index.html',
            inject:'body'
        })
    ]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/30/Webpack/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/Webpack/</guid>
        
        <category>wepack</category>
        
        <category>self-learning</category>
        
        <category>完整工作流</category>
        
        
      </item>
    
      <item>
        <title> Machine Learning math </title>
        <description>&lt;h2 id=&quot;降维-dimensionalily-reduce&quot;&gt;降维 Dimensionalily Reduce&lt;/h2&gt;
&lt;p&gt;首先引入过拟合概念 overfitting ，解决方法有三种，这里具体讲的是PCA降维。&lt;/p&gt;

&lt;h3 id=&quot;pca-降维概念&quot;&gt;PCA 降维概念&lt;/h3&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0ML/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0ML/</guid>
        
        <category>math</category>
        
        <category>self-learning</category>
        
        <category>machine learning</category>
        
        
      </item>
    
      <item>
        <title> Java并发 </title>
        <description>&lt;h2 id=&quot;java开发中绕不开的环节并发编程&quot;&gt;Java开发中绕不开的环节，并发编程&lt;/h2&gt;
&lt;p&gt;新手java开发，已经有一些基于spring开发的经验，但是在实际应用中对Java整个的运行机制还是不了解。主要依赖的课程是b站上&lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd&quot; target=&quot;_blank&quot;&gt;Java 并发&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;thread-和-runnable&quot;&gt;Thread 和 Runnable&lt;/h3&gt;
&lt;p&gt;线程创建方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法1 先有任务对象，再有线程对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Test1{
  public static void main(String[] args){
    Thread t = new Thread(){
      @Override
      public void run(){
        log.debug(&quot;running&quot;);
      }
    };
    t.setName(&quot;t1&quot;);// 给线程设置名字
    t.start();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用lambda简化方法1&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;new Thread(()-&amp;gt;{
  log.debug(&quot;running&quot;);
}, &quot;t1&quot;).start();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方法2 先创建线程对象，在里面执行任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Test2{
  public static void main(String[] args){
   Runnable r = new Runnable(){
     @Override
     public void run(){
       log.debug(&quot;running&quot;);
     }
   };
   Thread t = new Thread(r,&quot;t2&quot;);// t2是给线程设置名字
   t.start();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用lambda简化Runnable&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Runnable r = () -&amp;gt;{
       log.debug(&quot;running&quot;);
   };
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于第一和第二种，Runnable也是实现对run方法的Override。
方法1是线程任务合并，方法2是线程任务分开。
推荐使用方法2，Runnable更容易与线程池等高级API实现结合。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法3 FutureTask
能够接受callable类型参数，任务执行完将内容传给其他线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Test3{
  public static void main(String[] args){
    FutureTask&amp;lt;Integer&amp;gt; task = new FutureTask&amp;lt;&amp;gt;(new Callable&amp;lt;Integer&amp;gt;(){
      @Override
      public Integer call() throws Exception{
        log.debug(&quot;running&quot;);
        Thread.sleep(1000);
        return 100;
      }
    });
    Thread t = new Thread(task,&quot;t3&quot;);// t3是线程名
    t.start();

    task.get();//使用 等待task返回结果
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程交替执行情况&quot;&gt;线程交替执行情况&lt;/h3&gt;
&lt;p&gt;只有在多核cpu才能利用多种Thread&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查看进程方法 linux
    &lt;ul&gt;
      &lt;li&gt;ps -fe 查看所有进程  后面再加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;| grep java&lt;/code&gt;查看java进程&lt;/li&gt;
      &lt;li&gt;ps -fT -p &lt;PID&gt;&lt;/PID&gt;&lt;/li&gt;
      &lt;li&gt;kill &lt;PID&gt;杀死进程&lt;/PID&gt;&lt;/li&gt;
      &lt;li&gt;top 查看进行占用百分比 top -H -p &lt;PID&gt; 查看所有进程中的线程信息&lt;/PID&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java
    &lt;ul&gt;
      &lt;li&gt;jps 查看所有Java进程&lt;/li&gt;
      &lt;li&gt;jstack &lt;PID&gt; 查看线程的 snapshot&lt;/PID&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;jconsole java进程 可以远程监控 针对虚拟机专用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程运行原理&quot;&gt;线程运行原理&lt;/h3&gt;
&lt;p&gt;JVM  java virtual machine stack 给虚拟机分配空间&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;栈帧信息 frame&lt;/p&gt;

    &lt;p&gt;多线程实现， 线程之间栈帧独立&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程上下文切换 Thread Context Switch&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;产生情况&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从使用Cpu时间片用完&lt;/li&gt;
  &lt;li&gt;垃圾回收&lt;/li&gt;
  &lt;li&gt;更高级线程&lt;/li&gt;
  &lt;li&gt;线程自己调用 sleep yield wait join park synchronized lock&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在switch的时候需要保证线程状态，程序计数器Program Counter Register 记住下一条指令地址，频繁 Context Switch 影响 性能&lt;/p&gt;

&lt;h3 id=&quot;线程常见方法&quot;&gt;线程常见方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;start() 启动新线程 start让线程进入就绪转态，里面代码不会立即执行，每个线程对象start方法只能调用一次&lt;/li&gt;
  &lt;li&gt;run() 在构造Thread对象时传入 Runnable参数，在线程启动后会调用Runnable中run方法，可以创建Thread子类对象，来覆盖默认行为。&lt;/li&gt;
  &lt;li&gt;join() 等待线程运行结束&lt;/li&gt;
  &lt;li&gt;join(long n) 等待线程运行结束,最多等待n秒&lt;/li&gt;
  &lt;li&gt;getId() 获取线程长整型的id&lt;/li&gt;
  &lt;li&gt;getName() 获取线程名&lt;/li&gt;
  &lt;li&gt;getPriority() setPriority() 设置线程优先级&lt;/li&gt;
  &lt;li&gt;getState() 线程状态 6种&lt;/li&gt;
  &lt;li&gt;isInterrupted() 判断线程是不是被打断&lt;/li&gt;
  &lt;li&gt;isAlive() 判断线程是否存活&lt;/li&gt;
  &lt;li&gt;interrupt() 打断线程&lt;/li&gt;
  &lt;li&gt;currentThread() static 获取当前线程&lt;/li&gt;
  &lt;li&gt;sleep(long n) static 当前线程休眠&lt;/li&gt;
  &lt;li&gt;yield（） static 提示线程调度器让出当前线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;详细讲解方法&quot;&gt;详细讲解方法&lt;/h4&gt;

&lt;h5 id=&quot;run-和-start&quot;&gt;run 和 start&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;start启动线程&lt;/strong&gt;，再由线程调用自己定义的run方法。只能调用1次的start方法。&lt;/p&gt;

&lt;h5 id=&quot;yield-和-sleep&quot;&gt;yield 和 sleep&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;sleep&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Running到Time Waiting阻塞，在哪个线程里被调用，就在哪个线程里休眠。&lt;/li&gt;
  &lt;li&gt;其他线程可使用interrupt()打断正在睡眠的线程，sleep抛异常。&lt;/li&gt;
  &lt;li&gt;睡眠结束未必会立即执行&lt;/li&gt;
  &lt;li&gt;建议使用TimeUnit 的 sleep 代替 Thread.sleep() 提高可读性
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;TimeUnit.SECONDS.sleep(1);//单位换算
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;yield&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Running 到 Runnable就绪，之后执行其他&lt;strong&gt;同优先级&lt;/strong&gt;线程。&lt;/li&gt;
  &lt;li&gt;具体实现依赖调度器。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;就绪和阻塞区别，分配时间片不会考虑阻塞线程，只会分配给就绪线程，同时sleep有等待时间，而yield没有。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;线程优先级&quot;&gt;线程优先级&lt;/h5&gt;
&lt;p&gt;在thread类中保留的优先级，数字越大优先级越高。优先级会提示哪个优先使用。cpu忙不会太注意优先级。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Thread t = new Thread(task,&quot;t&quot;);
t.setPriority(Thread.MIN_PRIORITY);//最小优先级
t.start();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;案例-防止cpu占用100资源&quot;&gt;案例 防止CPU占用100%资源&lt;/h5&gt;
&lt;p&gt;多用于服务器开发，防止cpu100%占用资源&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;while (true){
  try{
    Thread.sleep(50);
  }catch(){
    ...
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以用wait达到同样效果，sleep适用于无锁、同步场景&lt;/p&gt;

&lt;h5 id=&quot;join-方法&quot;&gt;join 方法&lt;/h5&gt;
&lt;p&gt;等待线程运行结束，&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
        
        <category>java</category>
        
        <category>self-learning</category>
        
        <category>thread learning</category>
        
        
      </item>
    
      <item>
        <title> Redux详解 </title>
        <description>&lt;h3 id=&quot;what-is-state&quot;&gt;what is state?&lt;/h3&gt;
&lt;p&gt;influence what I look in the screen&lt;/p&gt;

&lt;h3 id=&quot;需要了解的action-reducer&quot;&gt;需要了解的Action Reducer&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;reducers: pure function,receive action and update state.&lt;/li&gt;
  &lt;li&gt;action: predefine information package
其实Redux不光可以在React中使用，在只有node的情况下，也可以通过设置初始化的state。
Redux的意义是实现各个component之间参数传递，传统的props如果要传递参数需要写入很多重复代码，Redux相当于一个云数据库，存储了许多state。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redux中主要组成部分&quot;&gt;Redux中主要组成部分&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Reducer 初始化state 绑定action
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const initialState = {
  counter: 0
}
const rootReducer = (state = initialState, action) =&amp;gt; {
  if (action.type === 'INC_COUNTER') {
      return {
          ...state,
          counter: state.counter + 1
      };
  }
  if (action.type === 'ADD_COUNTER') {

      return {
          ...state,
          counter: state.counter + action.value
      };
  }
  return state;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Store 定义需要保存的对象
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const store = createStore();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Subscription 确认所有的绑定的action执行之后的结果
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 不需要manually called  console.log(store.getState)
store.subscribe(() =&amp;gt;{
  console.log('[Subscribtion]', store.getState());// 
})// 每次dispatch的实现都能通过getState获得
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Dispatching action 对每个action实现的具体内容，type是一定要定义的，利用type来绑定reducer中对state执行怎样的操作
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;store.dispatch({ type: 'INC_COUNTER' })
store.dispatch({ type: 'ADD_COUNTER', value: 10 }) // 这里就是传递了value作为参数。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt; reducer通过dispatch定义的action的type对state进行操作，而store是能获得改变之后state的对象，可以通过调用store来获得改变之后的state，subscribe是可以观察到state改变状态的store里的方法。&lt;/p&gt;

&lt;h3 id=&quot;创建react-redux步骤&quot;&gt;创建react-redux步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在index.js中初始化redux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { createStore } from 'redux';&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在主界面中定义redux-base.js
实现代码
首先要加载属于react的redux
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save react-redux&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装时遇到问题 对应最新版本的react-redux安装不支持，需要在package.json中将其版本号换成&lt;strong&gt;5.0.6&lt;/strong&gt;并且对应的react版本应该小于&lt;strong&gt;16.3&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { Provider } from 'react-redux';
const store = createStore(reducer)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在index.js中将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Provider store={store}&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;&lt;/code&gt; 作为Component外层包裹到App中，并且传入定义好的store&lt;/p&gt;

&lt;p&gt;引入connect概念和mapStateToProps()
connect 是高阶组件，但是其引入方式是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import {connect} from 'react-redux';

...

export default connect(mapStateToProps,mapDispatchToProps)(XXX);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mapstatetoprops-和-mapdispatchtoprops&quot;&gt;mapStateToProps 和 mapDispatchToProps&lt;/h3&gt;
&lt;p&gt;整体上redux的参数传入机制是依靠这两个来实现&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;mapStateToProps&lt;/strong&gt; 类似于在class component 中定义初始化state&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;state = {
  counter: 0
} //正常格式

// 处于class component之外的格式
const mapStateToProps = state =&amp;gt; {
    return {
        ctr: state.counter
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;mapDispatchToProps&lt;/strong&gt; 定义获得的state通过什么type的dispatch&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;在class-component中实现的形式&quot;&gt;在class component中实现的形式&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;counterChangedHandler = (action, value) =&amp;gt; {
        switch (action) {
             case 'inc':
                this.setState((prevState) =&amp;gt; { return { counter: prevState.counter + 1 })
      ...
   
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两个的使用顺序是固定的，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect(mapStateToProps,mapDispatchToProps)()&lt;/code&gt;如果没有mapStateToProps则要变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect(null,mapDispatchToProps)()&lt;/code&gt;同理，没有mapDispatchToProps就默认connect中只传入一个参数。&lt;/p&gt;

&lt;h4 id=&quot;在class-component外实现的形式&quot;&gt;在class component外实现的形式&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const mapDispatchToProps = dispatch =&amp;gt; {
    return {
        onIncreamentCounter: () =&amp;gt; dispatch({type:&quot;INCREMENT&quot;}),
        onDecrementCounter:() =&amp;gt;dispatch({type:&quot;DECREMENT&quot;}),
        onAddCounter: () =&amp;gt; dispatch({type:&quot;ADD&quot;, value:5}),
        onSubtractCounter: () =&amp;gt; dispatch({type:&quot;SUBTRACT&quot;, value:5})
        
    };
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;在redux文件中定义的格式&quot;&gt;在redux文件中定义的格式&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const initialState = {
    counter: 0
}

const reducer = (state = initialState, action) =&amp;gt; {
    switch (action.type) {
        case ('INCREMENT'):
            return {
                ...state,
                counter: state.counter + 1
            };
            break;
        case ('DECREMENT'):
            return {
                ...state,
                counter: state.counter - 1
            };
            break;

        case ('ADD'):
            return {
                ...state,
                counter: state.counter + action.value
            };
            break;

        case ('SUBTRACT'):
            return {
                ...state,
                counter: state.counter - action.value
            };
            break;
    }

    return state;
};
export default reducer;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;redux-传参&quot;&gt;redux 传参&lt;/h3&gt;
&lt;p&gt;playload作为参数传递于需要的component和reducer之间，对于需要在dispatch中传入参数的函数，可以通过在定义type属性之后添加进行定义。&lt;/p&gt;

&lt;p&gt;如果想要在不同的class component中动态传参其实需要props的配合以及在dispatch中也放入对应参数来传递state。&lt;/p&gt;

&lt;h3 id=&quot;整合多个reducer&quot;&gt;整合多个reducer&lt;/h3&gt;
&lt;p&gt;首先定义多个reducer为一个模块，在此基础上，在index.js文件中，对其中的引入redux模块代码进行添加
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { createStore, combineReducers } from 'redux';&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在index中写入&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import counterReducer from './store/reducers/counter';
import resultReducer from './store/reducers/result';

const rootReducer = combineReducers({
    ctr:counterReducer,
    res:resultReducer
})
const store = createStore(rootReducer)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示告知react 整合这两个模块，并且将新的rootReducer传入到store中，对应到具体的component中，不同的reducer对应的state也改变了，所以需要再重新加上不同的模块，这里定义state的地方在mapStateToProps中，在原先的state的基础上重新加上.新定义的reducer名。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const mapStateToProps = state =&amp;gt; {
    return {
        ctr: state.ctr.counter,
        storeResult: state.res.results
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;什么情况下使用redux来存储state&quot;&gt;什么情况下使用redux来存储state&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;type : local UI 如 hide/show backdrop 不需要&lt;/li&gt;
  &lt;li&gt;type: persistant state 如 users info 不需要，是存储于server端的&lt;/li&gt;
  &lt;li&gt;client state: 用户是否登录，需要&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;advance-redux&quot;&gt;Advance Redux&lt;/h2&gt;
&lt;p&gt;高级redux&lt;/p&gt;
&lt;h3 id=&quot;add-midware&quot;&gt;Add midware&lt;/h3&gt;
&lt;p&gt;什么是midware 在reducer和action中间的一段代码或者说是function&lt;/p&gt;

&lt;h4 id=&quot;导入midware&quot;&gt;导入midWare&lt;/h4&gt;
&lt;p&gt;在index.js中导入&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { createStore, combineReducers, applyMiddleware } from 'redux';
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并且写入midware的定义方法(定义在index.js中)&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 自己创建midware 监视每次dispatch之后state的值
const logger = store=&amp;gt;{
    return next =&amp;gt;{
        return action =&amp;gt;{
            console.log('[MidWare] Dispatching', action);
            const result =  next(action);
            console.log('[Midware] next state', store.getState())
            return result;
        }
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现midWare注册，在index.js中因为已经导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applyMiddleware&lt;/code&gt;所以在createStore时多传入参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applyMiddleware&lt;/code&gt;。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const store = createStore(rootReducer, applyMiddleware(logger))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applyMiddleware&lt;/code&gt;传入刚刚定义的midWare，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logger&lt;/code&gt;，&lt;strong&gt;其实可以传入多个midWare&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用redux-dev-tools&quot;&gt;使用redux dev tools&lt;/h4&gt;
&lt;p&gt;google安装插件，打开这个github页面&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot; target=&quot;_blank&quot;&gt; redux dev tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;定位到&lt;img src=&quot;/img/advance-redux.jpg&quot; alt=&quot;&quot; /&gt;这个位置，修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rootRedux&lt;/code&gt;
改变为&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
const store = createStore(rootReducer, /* preloadedState, */ composeEnhancers(applyMiddleware(logger )))
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;并且在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import redux&lt;/code&gt;的时候加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt;， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combineReducers&lt;/code&gt;是一个类似用法，将多个enhance聚合。在redux tool中可以看到对应redux数据流。&lt;/p&gt;

&lt;h3 id=&quot;为什么redux需要使用async-code&quot;&gt;为什么redux需要使用async code&lt;/h3&gt;
&lt;p&gt;在action中传入的方法如果需要设置时间属性，比如setTimeout会返回一个Promise，但是redux中不支持使用Promise所以需要在其中调用async&lt;/p&gt;

&lt;h4 id=&quot;开始实现asynchron-code&quot;&gt;开始实现asynchron code&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先修改action.js中的内容，原先的action中使为了防止输入出错，所以const export 的大写字母，但现在可以将其和所有的dispatch整合&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const subtract = (value) =&amp;gt;{
    return {
        type:SUBTRACT,
        value:value
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大写的变量变成方法，在mapDispatchToProps的时候return的dispatch就由只能传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch =&amp;gt; ({type:...})&lt;/code&gt;变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch =&amp;gt;(action.js中定义的各个方法名)&lt;/code&gt;，其实是基本的参数变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;载入&lt;strong&gt;redux thunk&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save redux-thunk&lt;/code&gt;
在createStore的时候再加上一个midWare&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const store = createStore(rootReducer, composeEnhancers(applyMiddleware(logger, thunk)));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在action中使用setTimeout()包裹住一个dispatch，之后通过主界面调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;storeResult&lt;/code&gt;中的方法实现async的dispatch&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const saveResult = ( res ) =&amp;gt; {
    return {
        type: actionTypes.STORE_RESULT,
        result: res
    };
}

export const storeResult = ( res ) =&amp;gt; {
    return dispatch =&amp;gt; {
        setTimeout( () =&amp;gt; {
            dispatch(saveResult(res));
        }, 2000 );
    }
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;使用midware之后怎样修改代码中的逻辑&quot;&gt;使用midWare之后怎样修改代码中的逻辑&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;action&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;reducer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;can run Async code&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;pure Sync code &lt;strong&gt;Only&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;should not prepare the state update too much&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;core redux concept : reducers update the state&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以需要修改逻辑的代码大都放置在reducer中&lt;/p&gt;

&lt;h4 id=&quot;use-action-creators-和-getstate&quot;&gt;use action creators 和 getState&lt;/h4&gt;
&lt;p&gt;在进行dispatch的async中，可以使用getState&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const storeResult = ( res ) =&amp;gt; {
    return (dispatch, getState) =&amp;gt; {
        setTimeout( () =&amp;gt; {
            const oldCounter = getState().ctr.counter;
            dispatch(saveResult(res));
        }, 2000 );
    }
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个可以在进行dispatch之前将原先的state获取，注意加入的getState参数是为了可以获取state，而且要加上对应定义state的reducer在App.js中的注册名。 &lt;strong&gt;注意，不推荐多次使用getState获得redux，尽量使用传参&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用自定义的utility简化reducer中代码&quot;&gt;使用自定义的utility简化reducer中代码&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const updateObject = (oldObject, updatedValues) =&amp;gt; {
    return {
        ...oldObject,
        ...updatedValues
    }
}
// 调用时是
updateObject(state,{counter: state.counter - 1})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;action reducer&lt;/p&gt;

&lt;h3 id=&quot;实际应用redux的注意事项&quot;&gt;实际应用redux的注意事项&lt;/h3&gt;
&lt;p&gt;通过redux来判定页面上哪些内容应该显示，但是有时因为调用的dipatch方法执行没有render快，所以导致时间延迟比如，希望在页面中传入某个在render执行之后就马上执行的dispatch，但是在其后的调用中发现这个dispatch加载比render慢，因为这个dispatch是执行在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentWillMount&lt;/code&gt;中，但是比render慢，所以无法达到要求，可以通过在上一个界面中执行这个dispatch实现相同效果，不会比render慢。&lt;/p&gt;

&lt;h3 id=&quot;saga-使用&quot;&gt;Saga 使用&lt;/h3&gt;
&lt;p&gt;redux-saga是帮助旧版的react的async的action做出监听， handle all side effection on action, don’t directly manipulate the redux store具体的实现步骤如下&lt;/p&gt;
&lt;h3 id=&quot;在store文件夹下创建saga文件夹匹配authjs&quot;&gt;在store文件夹下创建saga文件夹匹配/auth.js&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;创建Generater&lt;/strong&gt;也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function*&lt;/code&gt;，这里是为了在logout时清除localStorage。&lt;/p&gt;

&lt;p&gt;在actions/auth.js的logout中的原始code是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const logout = () =&amp;gt; {
    localStorage.removeItem('token');
    localStorage.removeItem('expirationDate');
    localStorage.removeItem('userId')
    return {
        type: actionTypes.AUTH_LOGOUT,
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在经过saga时变为&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { put } from 'redux-saga/effects'; // dispatch new action 
import axios from 'axios';
export function* logoutSaga(action) {
    // generate
    yield localStorage.removeItem('token');
    yield localStorage.removeItem('expirationDate');
    yield localStorage.removeItem('userId');
    put({ type: actionTypes.AUTH_LOGOUT})
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;put表示dispatch新action，注意这个put如果要dispatch action 中的function时需要加上()表示实现这个function eg.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put(actions.logout())&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;yield表示只有在这一步执行完成之后下一步才开始执行&lt;/li&gt;
  &lt;li&gt;yield + put 想当于 async 的 dispatch&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;此外&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt;还有属性 delay传入的是时间，表示经过多长时间之后才执行yield之后的code，具体使用形式
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield delay(action.expirationTime);&lt;/code&gt;
&lt;strong&gt;delay是millionsecond所以需要注意在axios中expireIn是second&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt;有call 属性，使generator更加可测试，如原先的删除localStorage
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield localStorage.removeItem('userId');&lt;/code&gt;通过 call 可以变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield call ([localStorage, &quot;removeItem&quot;],&quot;userId&quot;)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt;有all 属性使用时减少&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;使用
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;yield takeEvery(actionTypes.AUTH_INITITATE_LOGOUT, logoutSaga);
yield takeEvery(actionTypes.AUTH_CHECK_TIMEOUT, checkoutTimeoutSaga);
yield takeEvery(actionTypes.AUTH_USER, authUserSaga);
yield takeEvery(actionTypes.AUTH_CHECK_STATE, authCheckStateSaga);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在all属性下转换为&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;yield all([
  takeEvery(actionTypes.AUTH_INITITATE_LOGOUT, logoutSaga),
  takeEvery(actionTypes.AUTH_CHECK_TIMEOUT, checkoutTimeoutSaga),
  takeEvery(actionTypes.AUTH_USER, authUserSaga),
  takeEvery(actionTypes.AUTH_CHECK_STATE, authCheckStateSaga)
])
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;可以对几个generator simultanously&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redux-saga/effects&lt;/code&gt;有takeLatest属性，表示只获取最新的saga而不是每一次saga都要检测到。&lt;/li&gt;
  &lt;li&gt;更多API详见&lt;a href=&quot;https://redux-saga.js.org/&quot; target=&quot;_blank&quot;&gt;redux-saga&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置saga&quot;&gt;配置saga&lt;/h3&gt;

&lt;p&gt;将创建好的saga配置入已经弄好的action中，此项目在在index.js中定义了action&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import createSagaMiddleware from 'redux-saga';
import { logoutSaga } from './store/sagas/auth';
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;register saga,在原有的thunk midware基础上加上了sagaMiddleware并且注册了sagaMiddleware的run&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const sagaMiddleware = createSagaMiddleware();
const store = createStore(rootReducer, /* preloadedState, */ composeEnhancers(
    applyMiddleware(thunk, sagaMiddleware)
));
sagaMiddleware.run(logoutSaga)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;监听action&quot;&gt;监听action&lt;/h3&gt;
&lt;p&gt;因为已经出现了logout这样的方法并且执行，可能会出现执行重复的情况，所以利用saga的特性实现对logout这个action的监听。在此之前，将原先的actions/auth.js中的logout中的return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actionType&lt;/code&gt;变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_INITITATE_LOGOUT&lt;/code&gt;，&lt;strong&gt;通过绑定在saga中定义的Generate和action实现的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actionTypes.AUTH_CHECK_TIMEOUT&lt;/code&gt;实现绑定。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建立sagas/index.js文件夹保存对saga的监听&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import {takeEvery} from 'redux-saga/effects'; // listen certain action 

import * as actionTypes from '../actions/actionTypes';
import {logoutSaga} from './auth';

export  function* watchAuth () {
    yield takeEvery(actionTypes.AUTH_INITITATE_LOGOUT, logoutSaga);// 每次执行这个generation都会监听AUTH_INITITATE_LOGOUT
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;每次执行这个generation都会监听&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_INITITATE_LOGOUT&lt;/code&gt;从而实现由AUTH_INITITATE_LOGOUT到AUTH_LOGOUT的绑定。&lt;/p&gt;

&lt;p&gt;同时在index注册时将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sagaMiddleware.run(logoutSaga)&lt;/code&gt;变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sagaMiddleware.run(watchAuth)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，在注册saga的地方可以定义多个sagaMiddleware&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;takeEvery&lt;/code&gt;是能够监听每一次saga执行的控件，每次点击saga&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;什么时候应该使用saga&quot;&gt;什么时候应该使用saga&lt;/h3&gt;
&lt;p&gt;redux本质是创建一个store保存component中共有的数据，定时删除localStorage和从服务器获取数据这样的要求其实是redux的side effect，所以要对这样的方法做处理就引入Saga。&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/21/React-redux/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/21/React-redux/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>saga</category>
        
        <category>redux</category>
        
        
      </item>
    
      <item>
        <title> React 页面设置Spinner、form 表单操作、Authentication </title>
        <description>&lt;h1 id=&quot;实现spinner-也就是页面加载中&quot;&gt;实现Spinner 也就是页面加载中&lt;/h1&gt;
&lt;p&gt;google &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;css spinner&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;实现form传递参数到后端数据库&quot;&gt;实现form传递参数到后端数据库&lt;/h1&gt;

&lt;p&gt;首先实现的form表单，需要了解的知识是，在react中例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input/&amp;gt;&lt;/code&gt;这种HTML参数可以通过传入react object类型获得属性。&lt;/p&gt;

&lt;h3 id=&quot;已经定义了state中能够传入到form表单中的数据类型&quot;&gt;已经定义了state中能够传入到form表单中的数据类型&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;state = {
  orderForm: {
    name: {
        elementType: 'input',
        elementConfig: {
            type: 'text',
            placeholder: 'Your name'
        },
        value: '',
        validation: {
            required: true
        },
        valid: false,
        touched: false// 表示用户有没有点击页面的order按钮
    },
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;其中&lt;strong&gt;elementType&lt;/strong&gt;是表示是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input/&amp;gt;&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;textarea/&amp;gt;&lt;/code&gt;还是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;select&amp;gt;&lt;/code&gt;作为自定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Input/&amp;gt;&lt;/code&gt;中的Html标签。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;elementConfig&lt;/strong&gt;是一个object的数据类型，传入到自定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Input/&amp;gt;&lt;/code&gt;中
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;input 
{...props.elementConfig}
value={props.value}
onChange={props.changed}
/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;这个input里面的value和onChange都是通过form表单中的props传输的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;表单监听的target.value&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;validation&lt;/strong&gt;和&lt;strong&gt;valid&lt;/strong&gt;通过function包裹的输入检查，可以设置长度大小，正则表达等设置&lt;strong&gt;validation&lt;/strong&gt;，同时通过确认其正确性判断是不是正确的输入将&lt;strong&gt;valid&lt;/strong&gt;设置为true。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;touched&lt;/strong&gt;如果用户已经按下确认按钮，需要将其没有输入正确的地方标红。这个touched就是判断用户有没有按下确认提交。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自定义的检查函数&quot;&gt;自定义的检查函数&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;checkValidity(value, rules) {
  // return boolean 确认返回validation
  let isValid = true; // 开始时设置为true
  // 每个情况都要判断是否是isValid 防止因为一个input需要判断多个的情况下始终为true 

  if (rules.required) {
      isValid = value.trim() !== '' &amp;amp;&amp;amp; isValid;//表示非空
  };
  if (rules.minLength) {
      isValid = value.length &amp;gt;= rules.minLength &amp;amp;&amp;amp; isValid;// 表示最小输入长度
  };
  if (rules.maxLength) {
      isValid = value.length &amp;lt;= rules.maxLength &amp;amp;&amp;amp; isValid;// 表示最小输入长度
  };
  return isValid;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;两个传入参数&lt;strong&gt;value,rules&lt;/strong&gt;分别表示用户写入每个item的值和前面的state中定义的validation的类型。&lt;/li&gt;
  &lt;li&gt;这个函数返回的是确认用户是否输入正确，state.valid来源于此。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;在render中实现以及监听函数&quot;&gt;在render中实现以及监听函数&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const formElementsArray = [];
for (let key in this.state.orderForm) {
    // key [&quot;name&quot;, &quot;street&quot;, &quot;zipcode&quot;...]
    formElementsArray.push({
      id: key,
      config: this.state.orderForm[key]// 这里的config所包含的就是name等右边的内容
    })
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码的作用是，给每个需要用户输入的item一个id，也就是这里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formElementsArray.id&lt;/code&gt;，这样做的好处是，一个eventHandler可以监听任意的一种用户修改。&lt;/p&gt;

&lt;p&gt;form 表单定义可以通过以下代码来渲染于页面&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{formElementsArray.map(formElement =&amp;gt; (
    &amp;lt;Input
        key={formElement.id}
        elementType={formElement.config.elementType}
        elementConfig={formElement.config.elementConfig}
        value={formElement.config.value}
        invalid={!formElement.config.valid}
        shouldValidate={formElement.config.validation}// 区分是select还是需要填写的地方
        touched={formElement.config.touched}
        changed={(event) =&amp;gt; this.inputChangeHandler(event, formElement.id)}
    /&amp;gt;
))}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在用户每一次点击一行决定输入时可以通过自定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Input/&amp;gt;&lt;/code&gt;中对应传入的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onChange={props.changed}&lt;/code&gt;绑定一个handler。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;inputChangeHandler = (event, inputIdentifier) =&amp;gt; {
    // 用户每次输入到input中的 内容可以通过event.target.value即使获得
    // 所谓的二次绑定(two way binding)，就是指，onChange指向的函数 绑定event获得用户实时输入的值，同时在onChange中调用这个函数时加上需要确认的identifier
    // console.log(event.target.value);
    //event.target 属性返回哪个 DOM 元素触发了事件。
    const updatedOrderForm = {
        ...this.state.orderForm // 不是深拷贝 state会变化 
        //因为只创建了state.orderForm的clone但是没创建其中 {name:...}等的clone，其实还是都指向一个地方
        // 为了创建深拷贝，对updatedOrderForm中的内容再次拷贝
    };
    const updatedFormElement = {
        ...updatedOrderForm[inputIdentifier]
    };
    updatedFormElement.value = event.target.value;
    updatedFormElement.valid = this.checkValidity(updatedFormElement.value, updatedFormElement.validation);// 判断输入值是否为空
    updatedOrderForm[inputIdentifier] = updatedFormElement;
    updatedFormElement.touched = true;// 表示用户已经输入了某些地方
    let formIsValid = true;
    for (let ele in updatedOrderForm) {
        formIsValid = updatedOrderForm[ele].valid &amp;amp;&amp;amp; formIsValid;
    }
    this.setState({ orderForm: updatedOrderForm, formIsValid: formIsValid });
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;实现authentication&quot;&gt;实现Authentication&lt;/h1&gt;

&lt;p&gt;实际上的auth传输形式，本地用户对server端发送请求，在server接收请求后给本地用户一个token，这个token可以存储于localStorage中，通过token，server可以确认用户信息。&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/20/React-spiner/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/20/React-spiner/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>spinner</category>
        
        
      </item>
    
      <item>
        <title> React burger 页面axios、Router </title>
        <description>&lt;h1 id=&quot;首先了解-axios-和-firebase-是什么&quot;&gt;首先了解 axios 和 firebase 是什么&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;axios 是一种 ajax 传参方式，导入的形式是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save axios&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;firebase 是google开发的数据库，代码中需要和数据库交互的部分放入firebase中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;axios使用的方式可以是&quot;&gt;axios使用的方式可以是&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import axios from 'axios'&lt;/code&gt;之后&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; componentDidMount() {
        axios.get('https://jsonplaceholder.typicode.com/posts')
            .then(response =&amp;gt; {
                const posts = response.data.slice(0, 4);
                const updatePosts = posts.map(post =&amp;gt; {
                    return {
                        ...post,
                        author: 'Max'
                    }
                })
                // console.log(&quot;response&quot;, response)
                this.setState({ posts: updatePosts })
            })
            .catch(error =&amp;gt; {
                console.log(error)
                // this.setState({ error: true })
            })
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码表示，在 component 完成整个页面渲染之后，通过 get 请求获得页面数据&lt;/p&gt;

&lt;p&gt;.then 代表页面进行不是线性的，在等待 axios 执行完成之后再执行 then 中的内容，response 返回的请求体，其中返回的是 get 到的内容。.catch 表示的是获取的错误信息，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{data: Array(100), status: 200, statusText: &quot;OK&quot;, headers: {…}, 
config: {url: &quot;/posts&quot;, method: &quot;get&quot;, headers: {…}, baseURL: &quot;http://jsonplaceholder.typicode.com&quot;, transformRequest: Array(1), …}
data:body: &quot;quia et suscipit↵suscipit recusandae consequuntur expedita et cum↵reprehenderit molestiae ut ut quas totam↵nostrum rerum est autem sunt rem eveniet architecto&quot;
id: 1
title: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;
userId: 1
headers: {cache-control: &quot;max-age=43200&quot;, content-type: &quot;application/json; charset=utf-8&quot;, expires: &quot;-1&quot;, pragma: &quot;no-cache&quot;}
request: XMLHttpRequest {readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …}
status: 200
statusText: &quot;OK&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也可以通过设置create属性的方式对所有的请求设置baseURL这样就可以不用对所有请求都加上同一种url，之后的请求写法就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;axios.get('/post')&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;详细的baseurl使用方式如下&quot;&gt;详细的baseURL使用方式如下&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const instance = axios.create({
    baseURL:'http://jsonplaceholder.typicode.com'
})
instance.defaults.headers.common['Authorization'] = 'AUTH TOKEN from Instance'//给每个header上都会加上一个请求头的默认值
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中的headers.common 给这个请求所有的headers都会加上一个 默认的Authorization&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;headers:
Accept: &quot;application/json, text/plain, */*&quot;
Authorization: &quot;AUTH TOKEN from Instance&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不只是在headers的commons中，在发送post请求时可以指定接收数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;['Content-Type'] = 'application/json';&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;axios拦截器的使用&quot;&gt;axios拦截器的使用&lt;/h4&gt;

&lt;p&gt;拦截器是axios的一种使用方式，表示对获得的response和发出的request做拦截，使用方式是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;axios.interceptors.request.use(request =&amp;gt; {
    console.log(request);
    //Edit request
    return request;//一定要return 否则不能在component中使用
}, error =&amp;gt; {
    console.log(error);
    return Promise.reject(error)
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上代码表示在request中对获得请求头进行处理，不使用return request会导致后面的请求无法收到request所以一定要return。&lt;/p&gt;

&lt;p&gt;对于error的处理是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return Promise.reject(error)&lt;/code&gt;实现，其中Promise是ES6中基本数据类型，会有reject和resolve两个状态，是用来实现异步操作调用的方法。&lt;/p&gt;

&lt;p&gt;为了不使interceptor在内存中堆积，要使用eject 对缓存中的interceptors进行清除。 commponentWillMount 和 componentWillUnmount是开始和结束页面渲染标志。因为用了this.来存储了interceptors所以后面删除。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;componentWillMount () {
            this.reqInterceptor = axios.interceptors.request.use(req =&amp;gt; {
                this.setState({error: null});
                return req;
            });
            this.resInterceptor = axios.interceptors.response.use(res =&amp;gt; res, error =&amp;gt; {
                this.setState({error: error});
            });
        }

componentWillUnmount() {
            axios.interceptors.request.eject(this.reqInterceptor);
            axios.interceptors.response.eject(this.resInterceptor);
        }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用route来实现不同url页面之间相互的传递参数&quot;&gt;使用route来实现不同URL页面之间相互的传递参数。&lt;/h3&gt;

&lt;p&gt;route是react-router-dom中的实现方法，通过在App.js中引入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { BrowserRouter, Route } from 'react-router-dom';&lt;/code&gt;实现。&lt;/p&gt;

&lt;p&gt;在主程序的return中用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;BrowserRouter&amp;gt;&amp;lt;/BrowserRouter&amp;gt;&lt;/code&gt;包裹所有的App.js中需要包裹的代码，在导航的component中需要导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { Route } from 'react-router-dom'&lt;/code&gt;注意如果要真确使用一定要在App.js中同样导入Route。&lt;/p&gt;
&lt;h4 id=&quot;route使用方式&quot;&gt;Route使用方式&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route path=&quot;/&quot; exact render={()=&amp;gt;&amp;lt;h1&amp;gt;home&amp;lt;/h1&amp;gt;}/&amp;gt; 
&amp;lt;Route path=&quot;/&quot;  render={()=&amp;gt;&amp;lt;h1&amp;gt;home1 &amp;lt;/h1&amp;gt;}/&amp;gt; 
&amp;lt;Route path=&quot;/&quot; exact component={Posts}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route&amp;gt;&lt;/code&gt;中属性代表如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;exact: 表示path中的名称不是模糊的，如果没有exact那么所有path中包含”/” 的页面就都会有render之后的页面渲染效果。&lt;/li&gt;
  &lt;li&gt;path: 表示页面到哪里去&lt;/li&gt;
  &lt;li&gt;component: 表示页面render到一个component&lt;/li&gt;
  &lt;li&gt;render: 返回一个方法，可以是jsx语句，如果要传入参数，需要再加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route path=&quot;/auth&quot; component={(props)=&amp;gt;&amp;lt;Auth {...props}/&amp;gt;} /&amp;gt;&lt;/code&gt;保留props&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何防止每次跳转页面不重新加载js&quot;&gt;如何防止每次跳转页面不重新加载js&lt;/h4&gt;

&lt;p&gt;在导航的component中需要导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { Route，Link } from 'react-router-dom'&lt;/code&gt;
使用Link代替&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;html语言，使用
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Link to='/'&amp;gt;&lt;/code&gt;代替了原本的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;href='/'&lt;/code&gt;
使用方式加强版&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Link to=&amp;gt;New Post&amp;lt;/Link&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;将pathname设置为new-post 表示绝对路径，如果想要显示相对路径  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.props.match.url + '/new-post'&lt;/code&gt;表示相对路径&lt;/li&gt;
  &lt;li&gt;hash表示可以跳转到页面的摸个部分&lt;/li&gt;
  &lt;li&gt;search表示可以对这个页面的某个地方实现查找，都是后话了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;这里的知识点就是 如果将参数传入为search形式，在后面怎样读取出来&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先理解for of 概念 也就是一种for each 循环形式
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for (let i of arr){...}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在后面调用的地方使用的是
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const query=new URLSearchParams(this.props.location.search)&lt;/code&gt; 表示通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URLSearchParams&lt;/code&gt;将默认存储在location中的search提取。&lt;/li&gt;
  &lt;li&gt;URLSearchParams暴露一个entries方法可以获得当时传入search中的内容,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quick-sumbit&lt;/code&gt;是key&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;是value，最后会返回两个值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;quick-sumbit&quot;,&quot;true&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原始获得search中内容代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;componentDidMount(){
        const query=new URLSearchParams(this.props.location.search);
        console.log(query)// 显示是一个obj
        for(let param of query.entries()){
            console.log(param);// 暴露出来的 entries方法
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;总结使用方法：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;route首先定义了跳转也买的path，再用指定的Component表示跳转的模块；&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;link表示点击某按键实现页面的跳转，这个按键中的pathname要包括匹配route中的path&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何实现每次加载页面能够获得最近的一个router页面的信息&quot;&gt;如何实现每次加载页面能够获得最近的一个router页面的信息&lt;/h4&gt;

&lt;p&gt;在之前使用了Link，表示component之间不重新渲染页面、不重新加载state后的传参魔法，Link到的component中props中有match等详细参数，表示上一个component的信息，但是对于不在route中的component来说，想要获得离其最近的router中的参数需要调用高阶函数(higher order component)，也就是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export default XX&lt;/code&gt;中对XX进行包裹的函数，其实相当于Aux，通过props.children传递参数，使用方式&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { withRouter } from 'react-router-dom';
...
export default withRouter(post);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样的Link如何进行style将这个Link显示成为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NavLink&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;NavLink
  to=&quot;/&quot;
  exact
  activeClassName=&quot;activeProps&quot;
  activeStyle={
    {
      ...
  }
}
&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就实现了一个页面的默认导航按钮的位置确认&lt;/p&gt;

&lt;h4 id=&quot;动态传入component页面间的参数-pass-routing-params&quot;&gt;动态传入component页面间的参数 Pass routing params&lt;/h4&gt;

&lt;p&gt;实现方式:在Route path 的 位置写上&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route path=&quot;/:id&quot; exact component={FullPost}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示转换为动态id传参，这里的id参数来源是动态显示的，不是固定值，需要绑定不同的值在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Link to={id}&amp;gt;&lt;/code&gt;中的id跟随需求改变。&lt;/p&gt;

&lt;p&gt;在跳转到的component界面显示的内容，之后可能会产生有歧义的现象，因为不同的界面可能会出现&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route path=&quot;/new-post&quot;  component={NewPost}/&amp;gt;
&amp;lt;Route path=&quot;/:id&quot; exact component={FullPost}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样的情况下，可能会认为new-post也是一个id也会产生传参问题，解决方式是在外层包裹上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Switch&amp;gt;&amp;lt;/Switch&lt;/code&gt;，表示只渲染第一个Route。所以对于Route来说 &lt;strong&gt;位置很重要&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用nested-route-表示两个componentrender的时候摆在一个页面上&quot;&gt;使用nested Route 表示两个componentrender的时候摆在一个页面上&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;这里的例子是在主页面上点击某按钮就能显示另一个component中的东西，在主页面要点击的地方加入Route写好对应的path同时注意主页面中不再使用那个Route而且为了防止出现exact不能动态加载的情况不使用exact。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;react小知识，对于两个不同数据类型int string如果只是想比较value可以使用!=而不是!==&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;conditional-redirect&quot;&gt;conditional redirect&lt;/h4&gt;

&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Redirect from=&quot;/new-post&quot; to=&quot;/posts/&quot;&amp;gt;&lt;/code&gt;实现参数传递，表示页面跳转，比如输入结束之后调用axios的post同时跳转到之前的页面可以使用条件式的跳转机制，或者是直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.props.history.replace('/posts')&lt;/code&gt;实现跳转。&lt;/p&gt;

&lt;h4 id=&quot;使用guards&quot;&gt;使用guards&lt;/h4&gt;
&lt;p&gt;在没有authentication情况下使用guard，没有什么组件，使用state和dirty的inline判断来guard&lt;/p&gt;

&lt;h4 id=&quot;使用lazily-load-route&quot;&gt;使用lazily load route&lt;/h4&gt;

&lt;p&gt;在bundle文件中会默认加载所有页面上会渲染到的文件，为了不再一开始就全部加载，导致时间过长，可以使用lazy加载方式，也就是Async异步策略。
写入高阶组件，需要传入的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;importComponet&lt;/code&gt;是一个函数&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React,{Component} from 'react';
const asyncComponent = (importComponet) =&amp;gt;{
    return class extends Component{
        state = {
            component:null
        }
        componentDidMount(){
            importComponet()
            .then(cmp
            =&amp;gt;{
                this.setState({
                  component:cmp.default  
                });
            });
        }
        render() {
            const C = this.state.component;
            return C ?&amp;lt;C {...this.props} /&amp;gt; :null;
        }
    }
}
export default asyncComponent;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用的格式是在一开始加载的页面中，先导入上面定义的asyncComponent方法，之后再通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import()&lt;/code&gt;关键字导入需要异步加载的模块。asyncComponent中传入的是匿名函数，也就是前面定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;importComponet&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import asyncComponent from '../../../hoc/asyncComponent';
const AsyncNewPost = asyncComponent(()=&amp;gt; {
    return import('./NewPost/NewPost');
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import()&lt;/code&gt;中传入的是需要异步加载的模块的相对位置，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import xx from '..//'&lt;/code&gt;的这种位置。&lt;/p&gt;

&lt;p&gt;同时因为加载的AsyncNewPost也是一个component，所以在最后的Route中也是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route path=&quot;/new-post&quot;  component={AsyncNewPost}/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;替换了原先的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route path=&quot;/new-post&quot; component={NewPost} /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;react166以上的lazy加载方式&quot;&gt;react16.6以上的lazy加载方式&lt;/h4&gt;

&lt;p&gt;使用suspend
具体实现方式，在主界面引入Suspense&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React, {Component, Suspense} from 'react'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在定义class之前定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.lazy()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const Posts = React.lazy(()=&amp;gt; import('Posts位置'))
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在主界面render()位置&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route render={()=&amp;gt;(
    &amp;lt;Suspense fallback={&amp;lt;div&amp;gt;Loading&amp;lt;/div&amp;gt;}&amp;gt;
        &amp;lt;Posts/&amp;gt;
    &amp;lt;/Suspense&amp;gt;)}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用nextjs帮助自动配置router&quot;&gt;使用Next.js帮助自动配置router&lt;/h3&gt;
&lt;p&gt;以上的router其实再写的过程中会有冗余感，next.js是一个基于react的路径配置&lt;a href=&quot;https://nextjs.frontendx.cn/docs&quot; target=&quot;_blank&quot;&gt;next.js中文文档&lt;/a&gt;
&lt;a href=&quot;https://nextjs.org/learn/basics/create-nextjs-app&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;修改package.json文件中scripts&lt;/li&gt;
  &lt;li&gt;写入基本代码&lt;/li&gt;
  &lt;li&gt;运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;automatic-code-spilting-自动跳转&quot;&gt;automatic code spilting 自动跳转&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React from 'react';
import Link from 'next/link';
import Router from 'next/router';

const indexPage = () =&amp;gt; (
    &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;the main page&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Go to &amp;lt;Link href=&quot;/auth&quot;&amp;gt;Auth&amp;lt;/Link&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;button onClick={() =&amp;gt; Router.push(&quot;/auth&quot;)}&amp;gt; got to auth&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt; 
)
export default indexPage;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;点击界面中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Link&lt;/code&gt; 包裹或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;button&lt;/code&gt;就会实现页面跳转，相比于router简便。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在一个页面上加载的另外地方的component会自动在跳转时加载&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用css&quot;&gt;使用css&lt;/h4&gt;
&lt;p&gt;next.js中可以使用style和之前使用的radius或者classes导入作为css传递，新的css使用方法是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const user = (props) =&amp;gt; (
    &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;{props.name}&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;{props.age}&amp;lt;/p&amp;gt;
        &amp;lt;style jsx&amp;gt;{`
            div {
                border:1px solid #eee;
                bosx-shadow:0 2px 3px #eee;
                padding:20px;
                text-align:center;
            }
        `}
        &amp;lt;/style&amp;gt;
    &amp;lt;/div&amp;gt;
);

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;处理error-404-界面&quot;&gt;处理error 404 界面&lt;/h4&gt;
&lt;p&gt;需要定义文件名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_error.js&lt;/code&gt;的错误处理文件&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const errorPage = () =&amp;gt; (
    &amp;lt;div&amp;gt;
        &amp;lt;h1&amp;gt;something went wrong &amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Try &amp;lt;Link href=&quot;/&quot;&amp;gt;go back&amp;lt;/Link&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt; 
)
export default errorPage;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;nextjs原理部分&quot;&gt;next.js原理部分&lt;/h4&gt;
&lt;p&gt;以生命周期举例，next.js是在server端的加载，只有其child被点击之后才会开始加载&lt;/p&gt;

&lt;h3 id=&quot;react-animation-页面美化相关&quot;&gt;react Animation 页面美化相关&lt;/h3&gt;
&lt;p&gt;在Burger中的modal的作用就是显示一种美化之后的模态对话框。&lt;/p&gt;

&lt;h4 id=&quot;页面动态美化使页面能够显示一种modal加载出来是弹跳的状态&quot;&gt;页面动态美化，使页面能够显示一种modal加载出来是弹跳的状态。&lt;/h4&gt;

&lt;p&gt;利用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@keyframes&lt;/code&gt;表示多少百分比的时间显示的透明度和下降深度，transform:表示开始位置是页面正上方，这里的相对Y是中心。这里的openModal功能是modal初始化载入，透明度由0变为1，再之后的closeModal是关闭modal。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@keyframes openModal{
    0% {
        opacity: 0;
        transform: translateY(-100%);
    }
    50% {
        opacity: 1;
        transform: translateY(90%);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes closeModal{
    0% {
        opacity: 1;
        transform: translateY(0);
    }
    50% {
        opacity: 0.8;
        transform: translateY(60%);
    }
    100% {
        opacity: 0;
        transform: translateY(-100%);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@keyframes&lt;/code&gt;名字为属性，在css文件中导入，对应的没有动态弹跳形式的原始css，注意animation的参数，首先是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@keyframes&lt;/code&gt;名字、加载到指定位置的秒数、什么形式加载、加载后是否回到初始位置（也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forwards&lt;/code&gt;）如果没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forwards&lt;/code&gt;，会在弹跳之后变为0%时状态。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.ModalOpen{
    /* display: block;
    opacity: 1;
    transform: translateY(0); */
    animation: openModal 0.4s ease-out forwards;
}
.ModalClose{
    /* display: none; 
    opacity: 0;
    transform: translateY(-100%); */
    animation: closeModal 0.4s ease-out forwards;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;css加载在react遇到的问题&quot;&gt;css加载在react遇到的问题&lt;/h4&gt;

&lt;p&gt;因为加载顺序，在弹跳界面本来是要做同样的弹跳形式返回到原始界面，但是因为display执行顺序，所以不会显示这样界面，引入&lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;reactjs/react-transition-group&lt;/strong&gt;组件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install react-transition-group --save&lt;/code&gt;导入&lt;/p&gt;

&lt;p&gt;分为四个状态
There are 4 main states a Transition can be in:&lt;/p&gt;

&lt;p&gt;‘entering’&lt;/p&gt;

&lt;p&gt;‘entered’&lt;/p&gt;

&lt;p&gt;‘exiting’&lt;/p&gt;

&lt;p&gt;‘exited’&lt;/p&gt;

&lt;p&gt;解决方法就是在exiting和exited之间切换&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Transition&amp;gt;&amp;lt;/Transition&amp;gt;&lt;/code&gt;实现css，具体的实现方式可以看官方文档
&lt;a href=&quot;https://reactcommunity.org/react-transition-group/transition&quot; target=&quot;_blank&quot;&gt;Transition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里注意在载入Transition时会因为react-redux版本冲突加载错误，需要将react设置为16.3以上版本。&lt;/p&gt;

&lt;h3 id=&quot;do-not-go-gentle-into-that-good-night-不要温驯的走进那个良夜&quot;&gt;Do not go gentle into that good night. 不要温驯的走进那个良夜&lt;/h3&gt;

&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;

&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;

&lt;p&gt;Rage, rage against the dying of the light.
&lt;img src=&quot;/img/react-axios.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/18/React-axios/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/18/React-axios/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>no class basing</category>
        
        <category>axios</category>
        
        <category>router</category>
        
        <category>Do not go gentle into that good night.</category>
        
        
      </item>
    
      <item>
        <title> React 笔记 </title>
        <description>&lt;h3 id=&quot;react-语法-小知识点&quot;&gt;React 语法 小知识点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export default xxx&lt;/code&gt; 在后面导入的时候是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import xxx from ''&lt;/code&gt;， 但是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export const xxx&lt;/code&gt; 时 后面导入要求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import {xxx} from ''&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ES7中代码编写的特点，不再使用this关键字了
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;constructor (){this.property = 'xxx'}&lt;/code&gt;转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;property = 'xxx&lt;/code&gt;;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method () {...}&lt;/code&gt;转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method = () =&amp;gt;{...}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt; spread  数组&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const newArray = [...oldArray,1,2]&lt;/code&gt;；Object&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const newObj = {... oldObj, newProp:5}&lt;/code&gt; 如果oldObj也有newProp，新的Obj会覆盖newProp。
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt; rest 针对方法的填充 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function sortArg(...args){return args.sort()}&lt;/code&gt;。注意，使用…表示创建了新的对象。同时对于array concat表示创建新数组，但是push不能创建新数组，所以在redux中能够使用concat的地方就不用push。&lt;/li&gt;
  &lt;li&gt;destructuring 不创建新对象的抽取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[a,b] = ['a', 'b']&lt;/code&gt;此时单独拿a或者b都不算创建新的对象，适用于array和obj。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reference&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;primitive&lt;/code&gt;格式，object和array都是reference所以copy之后会联动修改，但是常量不会，因为常量是primitive格式的。解决联动修改的方法是给copy那一方加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; cosnt person = {name:'max'};
 const secondPersion = {...person,name:'min'};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;filter 适用于 array 的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;react-建立项目以及语法&quot;&gt;React 建立项目以及语法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;sudo npm install create-react-app -g&lt;/li&gt;
  &lt;li&gt;create-react-app react-complete-guide –scripts-version 1.1.5 不是为了加载react的版本，是为了项目结构一致&lt;/li&gt;
  &lt;li&gt;进入dir react-complete-guide npm start&lt;/li&gt;
  &lt;li&gt;理解项目结构
    &lt;ul&gt;
      &lt;li&gt;public web 服务器中显示的界面，index.html 如果是多页面也不会有多个html，这个页面可以导入css依赖&lt;/li&gt;
      &lt;li&gt;src 文件是js和css文件名一一对应，注意在index.js中最好只有一个Component&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;jsx概念：react语法糖，就是js中包裹了HTML，实际上还是js。&lt;/li&gt;
  &lt;li&gt;不能在Component中写class即HTML中class属性被className代替；一个render 的return 只能有一个 root element 并列是不允许的。&lt;/li&gt;
  &lt;li&gt;以小写开头的component是HTML中的，自定义一般大写。&lt;/li&gt;
  &lt;li&gt;dynamic content { }&lt;/li&gt;
  &lt;li&gt;props ，props.children 是在opening component中展示的&amp;lt;P&amp;gt; xxx &amp;lt;/P&amp;gt; 在调用的时候就是props.children&lt;/li&gt;
  &lt;li&gt;在return中定义的方法是不会加上()，因为这样每次页面一加载就会调用这个方法，常见做法是只传入名字。&lt;/li&gt;
  &lt;li&gt;state 在更新state时不是override而是会保留没有修改的state&lt;/li&gt;
  &lt;li&gt;react hook介绍：首先是不再用class定义component而是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const component名 = props =&amp;gt;{}&lt;/code&gt;，其中可以写入方法。而且在component中不再使用render。hook不再使用Component关键字，而是使用以use开头的关键字如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;。
    &lt;ul&gt;
      &lt;li&gt;useState 用法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const [state名, 更新state的方法名] = useState(初始化的state可以是任何形式的数据)&lt;/code&gt;；同时需要注意，&lt;strong&gt;在useState中更新state的方法不会merge原有的state！！！&lt;/strong&gt;，所以在hook中可以有多个useState。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;method在componet之间传递，使用props，如果方法需要参数，可以使用以下两种方法，但是比较推荐第一种的bind，提高效率。
    &lt;ul&gt;
      &lt;li&gt;在调用方法的那一端使用bind(this,参数)&lt;/li&gt;
      &lt;li&gt;或者是使用匿名函数包裹并传入参数()=&amp;gt;this.func(参数)； 如果有event要传入需要在&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;add two way binding, 动态传入用的是onChange 执行的时候自动传入event 获得修改的是event.target.value,但是在一开始并没有输入，所以使用了 value={props.value}当做初始值。&lt;/li&gt;
  &lt;li&gt;要在jsx中加上css文件需要导入&lt;/li&gt;
  &lt;li&gt;在return中不能使用if而是用{ ? :  },如果不想在HTML中使用{}扩上大段的HTML可以在render和return之间加上一个let变量，这样就可以使用if语句。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在jsx中使用&lt;strong&gt;map&lt;/strong&gt;来渲染list类型的数据:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   persons :[
       {name:'l1',age:12},
       {name:'l2',age:13}
   ]
   render(
       return {
           &amp;lt;div&amp;gt;
               {this.persons.map((person,index) =&amp;gt;{ // map需要一个key 这个index就是作用在map中的key，要保证key是不同的，所以这里其实不能用index因为list改变可能会使用相同index，在给用户数据的时候需要一个不同的key，这个可以是list再定义一个id
                   // 这里的person就是  {name:'l1',age:12} 
                   return &amp;lt;Person name={person.name} age={person.age} key={index}&amp;gt;
               })} 
           &amp;lt;/div&amp;gt;
       }
   )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;事件监听event,在传入method中如果要加入event作为参数，并且在调用的方法中是使用onClick等将(event) =&amp;gt;{调用的函数(event)} 作为props传入另外的页面。&lt;/li&gt;
  &lt;li&gt;使用join和数组对className做动态处理66-67&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在button上加上hover，需要引入 npm install –save radium 在export default 用Radium(Component)包裹当前component之后在定义的inline css中。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;       const style={
           color: 'red',
           ':hover':{
               backgroundColor:'lightblue'
           }
       }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;当然在动态调用这个style的时候一般是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style.color='red'&lt;/code&gt;，但是针对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:hover&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style[':hover']={覆盖原来属性}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@media query 根据页面大小调整边距占比。一般是用在CSS中，但是Radium可以帮助调整，在最外层的App.js上套用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import Radium,{StyleRoot} from 'radium&lt;/code&gt;导入 StyleRoot 来引入 ，再wrap 所有Html到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;StyleRoot&amp;gt;&amp;lt;/StyleRoot&amp;gt;&lt;/code&gt;中，在单独需要作用的界面上,需要单独写好 @media同时在export时用Radium包裹。
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const style = {
'@media(min-width:500px)':{
    width:'450px'
}
 }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;styled Component是一个专门做css style的工具，npm install –save styled-components加载
    &lt;a href=&quot;https://styled-components.com/&quot; target=&quot;_blank&quot;&gt;styled-components&lt;/a&gt;
 用法：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   import styled from 'styled-components';
   const StyleDiv = styled.div` //这里可以使用任何html中的标签 h1,span等
           width:12px,
           margin:...,
           @media (min-width:500px):{
               width:450px
           }
           //写入任何css中的style，不需要加上selector
           `//这里用到的`号！！！
   const example = (props) =&amp;gt;{
       return (
           &amp;lt;StyleDiv&amp;gt;
           包裹住想要加上css的标签
           &amp;lt;/StyleDiv&amp;gt;    
       )
   }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;同样 要动态的修改css可以在以上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;styled.div 中使用 ${}&lt;/code&gt;传入props 因为styled-componets定义的css是一个component。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;利用css module实现对单独需要的component进行渲染，好处是不用在整个css文件中渲染导致有相同className的元素共用一个css， 使用react-script版本为1.x.x，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run eject&lt;/code&gt;编写buddle文件
 在 config/webpack.config.dev.js和 config/webpack.config.props.js中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; test: /\.css$/&lt;/code&gt;项目下给use中的options加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules:true,localIdentName:'[name]_[local]_[hash:base64:51]'&lt;/code&gt;表示给每个css文件加上modules而且命名也不同，在正式使用的过程中使用以下方式导入：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   import classes from './XXX.css';//导入css文件 
   render(
       return (
           &amp;lt;div&amp;gt;
               &amp;lt;button className={classes.在css文件中以class为selector的名称}&amp;gt;
           &amp;lt;/div&amp;gt;
       )
   )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;鉴于react手脚架已经更新，所以不再会产生config.dev.js和config.props.js两个文件，所以在产生的config/webpack.config.js文件中对cssModuleRegex和cssRegex两个模块加入以下内容&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   {
       test: cssRegex,
       exclude: cssModuleRegex,
       use: getStyleLoaders({
       importLoaders: 1,
       sourceMap: isEnvProduction &amp;amp;&amp;amp; shouldUseSourceMap,
       modules: {
           getLocalIdent: getCSSModuleLocalIdent,
       },
   }),
   {
       test: cssModuleRegex,
       use: getStyleLoaders({
       importLoaders: 1,
       sourceMap: isEnvProduction &amp;amp;&amp;amp; shouldUseSourceMap,
       modules: {
           getLocalIdent: getCSSModuleLocalIdent,
       },
       }),
   },
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;并在更新之后执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在检查界面看到这个css的class名为 “使用此css的component名_在css文件中定义的classSelector名_随机的hash”,动态加载的界面同样使用join和push来加载，在css文件中可以指定两个classSelector就能通过push传入多个class。&lt;/p&gt;

&lt;h3 id=&quot;react-debug&quot;&gt;React debug&lt;/h3&gt;
&lt;p&gt;在react 16中写入ErrorBoundary文件夹 写入ErrorBoundary 只在有需要时显示customer error message&lt;/p&gt;

&lt;h3 id=&quot;dive-deep-into-react-component--react-internals&quot;&gt;Dive deep into React component &amp;amp; react internals&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;class component create lifecycle hook（ 和 react hook无关）
  因为class based 和 functional based 的component对state的要求不同，所以 lifecycle 只在class based上保有。
    &lt;ol&gt;
      &lt;li&gt;constructor(props) set up state&lt;/li&gt;
      &lt;li&gt;getDerivedStateFromProps 不常用 sync state&lt;/li&gt;
      &lt;li&gt;render&lt;/li&gt;
      &lt;li&gt;render child component&lt;/li&gt;
      &lt;li&gt;componetDidMount() 不要update state 会trigger re-render&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lifecycle update props and state&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getDerivedStateFromProps 不常用&lt;/li&gt;
      &lt;li&gt;shouldComponentUpdate 确定是否继续&lt;/li&gt;
      &lt;li&gt;render&lt;/li&gt;
      &lt;li&gt;update child props&lt;/li&gt;
      &lt;li&gt;getSnapshotBeforeUpdate 获得最后一刻dom的信息&lt;/li&gt;
      &lt;li&gt;componentDidUpdate cause side effects 不要update state&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;functional component hook&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;useEffect default run for every render cycle 每次修改都会调用&lt;/li&gt;
      &lt;li&gt;useEffect (()=&amp;gt;{},[依赖])，可以多次使用，只在依赖改变的时候才执行，如果依赖为空表示只在第一次render的时候执行，但是一定要加上依赖为[]的空数组才能表达这个意思。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;clean life cycle &amp;amp; useEffect&lt;/p&gt;

        &lt;p&gt;在useEffect 中执行return可以是一个方法，在第一次的main useEffect 执行之前 执行，但是在第一次render之后执行，在其中加上的return就是消除本次useEffect的中执行内容对页面的影响。&lt;/p&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;     useEffect (()=&amp;gt;{
         const timer = setTimeout(()=&amp;gt;{alert('')},1000);
         return ()=&amp;gt;{
             cleanTimeout(timer);
         }
         },[]);

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use shouldComponentUpdate for Optimize&lt;/p&gt;

    &lt;p&gt;利用shouldComponentUpdate来优化 
  shouldComponentUpdate中包含参数nextProps, nextState可以通过判断这两个参数是否需要更新来优化代码，避免re-render多余部分。 Chrome -&amp;gt;more tool-&amp;gt;rendering 查看是否有多余render&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optimize functional component with React.memo()适用于functional component&lt;/p&gt;

    &lt;p&gt;React.memo(component)只有input改变才会render这个component&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;问题来了 什么时候应该optimize&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;parent update -&amp;gt; 本component就要render, 没必要的check。&lt;/li&gt;
      &lt;li&gt;pureComponents instead of shouldComponentUpdate
  pureComponent 是 normal 的 component，传入的参数多，不需要每个都检查是否更新了，将原来继承的{Component}修改为{PureComponent}帮助检查参数是否更新，不必多写shouldComponentUpdate代码。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;how react update real dom&lt;/p&gt;

    &lt;p&gt;一般情况下，无论class-based 还是 functional-based的 都会反映到react的虚拟dom上， 
  shouldComponentUpdate() =&amp;gt;render() is called  但是 render{} doesn’t immediately update the “real dom”&lt;/p&gt;

    &lt;p&gt;react 保留两个 dom&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;1) old virtual dom (比real dom 快)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;2) re-rendered Virtual dom&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;比较以上两个dom 是否改变 改变了就update real 不改就是不update&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;render Adjacent JSX elements&lt;/p&gt;

    &lt;p&gt;只能在return中保有一个root element,如果想要多个adjacent elements&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;1）用array将其包裹，传入key可以实现多个element在return中渲染。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;2）使用Aux component props.children实现多个element渲染&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use React.Fragment&lt;/p&gt;

    &lt;p&gt;和上面Aux 传props.children 是一个用处&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Higher Order Component (HOC)&lt;/p&gt;

    &lt;p&gt;以With…开头 使用example，可以用来handle http error&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      使用时
      WithClass from '../...'
      &amp;lt;WithClass classes={}&amp;gt;
      &amp;lt;/WithClass&amp;gt;
       ====================
      import React from 'react';
      const WithClass = props =&amp;gt;{
          &amp;lt;div className={props.classes}&amp;gt;props.children&amp;lt;/div&amp;gt;
      };
      export default withClass;
        
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;其他形式的HOC，function return 一个function component&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      const withClass = (WrappedComponent, className) =&amp;gt;{//不是 functional component
          return props =&amp;gt;{
              &amp;lt;div className={className}&amp;gt;
                  &amp;lt;WrappedComponent&amp;gt;
              &amp;lt;/div&amp;gt;
          }
      };
      export default withClass;
      ============================
      使用时是normal function
      用withClass(需要包裹的component, className)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;passing unknown props&lt;/p&gt;

    &lt;p&gt;是针对HOC传入时 props丢失的情况， 使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;WrappedComponent {...props}&amp;gt;&lt;/code&gt;获得原先需要传入的props&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎样防止错误的 setState&lt;/p&gt;

    &lt;p&gt;sync情况，多个setState同时改变state导致state不能保证哪个是最新的，解决方式
 this.setState((prevState, props)=&amp;gt;{return {新state的修改}})&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新PropsType&lt;/p&gt;

    &lt;p&gt;如果产生错误的传入props的格式，比如age应该是number ，导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm instal --save prop-type&lt;/code&gt; import 之后在使用的时候是在定义需要传入props的component中的export之前加上每个props的定义：&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      Component.propTypes = {
          propname:PropType.func,
          name:PropType.string,
          ...
      };
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use Refs 实时获得当前state&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ref=”“&lt;/strong&gt; key word class-based 的 component
  在打开页面的时候在哪里定位 
  在function-based component中 使用
  useRef&lt;br /&gt;
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosnt toggleBtnFre = useRef(null);&lt;/code&gt;
  在useEffect 中使用 toggleBtnRef
  jsx中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;button ref={toggleBtnFre}&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use Context API&lt;/p&gt;

    &lt;p&gt;用于在一个component中需要certain data inmultiple components and do not want to pass that data across multiple layers，也就是一个state需要传到离他很远的component中来进行确认的时候，就用到Context作为简便获得特定component中的state的语法。
  &lt;strong&gt;比如：确认用户是否login，如果能够login就渲染到另一个界面&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  const Context = React.createContext({
      默认值:''//格式是string array
  })
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;pass within without using props ，在需要的地方引入&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &amp;lt;Context.Provider value=&amp;gt;
  包裹住需要传入的props，这样只要调用这个地方就可以实现实时监听，并且一旦引用就会修改默认值
  &amp;lt;/Context.Provider&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;在return中使用&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &amp;lt;Context.Consumer&amp;gt;//返回的是一个function 以context为 参数
  {(context)=&amp;gt; context 中的value也就是默认值中的value }
  &amp;lt;/Context.Consumeer&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;如果不能再return中使用可以现在class中使用就需要定义一个静态变量，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;，其作用是can be access from outside without need to init an object based on this class可以在外部引入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static contextType = Context&lt;/code&gt;，调用默认值时就可以执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.默认值&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;在functional component中使用 context
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const authContext = useContext(Context)&lt;/code&gt;这样就可以获得context中的内容了。&lt;/p&gt;

    &lt;p&gt;使用useContext 作为function-based 或者定义静态contextType变量再调用实现，详见114。&lt;/p&gt;

    &lt;p&gt;在445课时用到的案例，下面是代码&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  import React, { useState } from 'react';
  export const AuthContext = React.createContext({
  isAuth: false,
  login: () =&amp;gt; {}
  })

  const AuthContextProvider = (props) =&amp;gt; {
      const [isAuth, setIsAuth] = useState(false);
      const loginHandler = () =&amp;gt; {
          setIsAuth(true)
      }
      return (
          &amp;lt;AuthContext.Provider value=&amp;gt;
              {props.children}
          &amp;lt;/AuthContext.Provider&amp;gt;
      )
  }
  export default AuthContextProvider;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在index.js中利用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;AuthContextProvider&amp;gt;&lt;/code&gt;包裹住&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;表示所有需要用到AuthContext地方被表示为Provider,在需要用到的是否login的地方写入以下代码（此处是在App主界面），注意定义中先export的并不是default的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthContextProvider&lt;/code&gt;而是包含默认值的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthContext&lt;/code&gt;所以在导入的时候是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{AuthContext}&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  import { AuthContext } from './context/auth-context';   
    
  const App = props =&amp;gt; {
  const authContext = useContext(AuthContext);
  let content = &amp;lt;Auth /&amp;gt;
  if (authContext.isAuth) {
      content = &amp;lt;Ingredients/&amp;gt;
  }
  return (
      // &amp;lt;AuthContext.Consumer&amp;gt;
      // &amp;lt;Auth /&amp;gt;
      // &amp;lt;/AuthContext.Consumer&amp;gt;
      {content}
      )
  };
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;在需要auth的界面中显示&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  import {AuthContext} from '../context/auth-context';

  const Auth = props =&amp;gt; {
  const authContext = useContext(AuthContext);
  const loginHandler = () =&amp;gt; {
      authContext.login();//改变login中的state从而在App主界面转换为&amp;lt;Ingredients/&amp;gt;
  };
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;react-中小知识点&quot;&gt;React 中小知识点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;preventDefault 在event事件被加载之前，为了不再request，需要调用这个方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;react-test&quot;&gt;React test&lt;/h3&gt;
&lt;p&gt;为了实现单元测试需要导入&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;npm install --save enzyme react-test-renderer enzyme-adapter-react-16
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用形式
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shallow&lt;/code&gt;表示形式是将测试行文设置为浅层的render不涉及其中全部component的render&lt;/p&gt;

&lt;p&gt;如何开启test模式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm test&lt;/code&gt;， 如果是第一次开启需要删除App.test.js再执行。&lt;/p&gt;

&lt;p&gt;创建的test文件名是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NavigationItems.test.js&lt;/code&gt;来执行，文件中代码&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React from 'react';

import { configure, shallow } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
configure({ adapter: new Adapter() });// connect enzyme
import NavigationItems from './NavigationItems';
import NavigationItem from './NavigationItem/NavigationItem';

describe('&amp;lt;NavigationItems /&amp;gt;', () =&amp;gt; {
    it('should render two &amp;lt;NavigationItem /&amp;gt; if not authenticated', () =&amp;gt; {
        const wrapper = shallow(&amp;lt;NavigationItems /&amp;gt;);
        // 确认wrapper中是否含有某个确定的content
        // 这里不再是JS element 而是 export func
        expect(wrapper.find(NavigationItem)).toHaveLength(2);// 表示希望最后传回2个
    });
});
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enzyme&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;react&lt;/code&gt; 通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configure&lt;/code&gt;连接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enzyme&lt;/code&gt;，再通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;describe&lt;/code&gt;确认需要测试的component，以及通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;it&lt;/code&gt;方法传入两个参数，一个是描述测试，另一个是测试的实现匿名方法，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;except&lt;/code&gt;实现，传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;except&lt;/code&gt;中的是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shallow&lt;/code&gt;定义的探寻Component中的content和里面会实现的方法。&lt;/p&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find&lt;/code&gt;关键字实现查找有几个component被调用，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toHaveLength&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jest&lt;/code&gt;中的方法表示返回component的个数。&lt;/p&gt;

&lt;p&gt;可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contains&lt;/code&gt;关键字找打是不是存在一个node&lt;/p&gt;

&lt;p&gt;在终端中显示为
&lt;img src=&quot;/img/react-test.jpg&quot; alt=&quot;&quot; /&gt;
其中Test Suites 是describe function， Tests 整个是 it方法实现&lt;/p&gt;

&lt;h4 id=&quot;实现多个test&quot;&gt;实现多个test&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; let wrapper;
    beforeEach(()=&amp;gt;{ 
        wrapper = shallow(&amp;lt;NavigationItems /&amp;gt;);
    })
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在describe第二个参数中传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeEach&lt;/code&gt;表示每次执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;it&lt;/code&gt;之前执行，如果要加入参数可以使用
` wrapper.setProps({isAuth:true})&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;中的&lt;/code&gt;setProps({})`包裹需要添加的参数&lt;/p&gt;

&lt;h4 id=&quot;实现component测试是将component之前加上const&quot;&gt;实现component测试是将component之前加上const&lt;/h4&gt;
&lt;h4 id=&quot;实现redux测试&quot;&gt;实现redux测试&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import reducer from './auth';
import * as actionTypes from '../actions/actionTypes';

describe('auth reducer', () =&amp;gt; {
    it('it should return initial state', () =&amp;gt; {
        expect(reducer(undefined, {})).toEqual({
            token: null,
            userId: null,
            error: null,
            loading: false,
            authRedirectPath: '/'
        })
    })
    it('it should store token upon login ', () =&amp;gt; {
        expect(reducer({
            token: null,
            userId: null,
            error: null,
            loading: false,
            authRedirectPath: '/'
        }, {
            type: actionTypes.AUTH_SUCCESS,
            idToken: 'some-token',
            userId: 'some-id'
        })).toEqual({
            token: 'some-token',
            userId: 'some-id',
            error: null,
            loading: false,
            authRedirectPath: '/'})
    })
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;部署到web&quot;&gt;部署到web&lt;/h3&gt;
&lt;p&gt;利用firebase部署&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;steps&lt;/th&gt;
      &lt;th&gt;example&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;check base path&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Router basename=&quot;/&quot;&amp;gt;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;build project&lt;/td&gt;
      &lt;td&gt;npm run build&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;server must ALWAYS serve index.html (also for 404 case)&lt;/td&gt;
      &lt;td&gt;ensure router&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;upload static we page&lt;/td&gt;
      &lt;td&gt;in build folder when using create-react-app&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run build&lt;/code&gt; 产生build文件夹&lt;/li&gt;
  &lt;li&gt;利用firebase中的hosting
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install -g firebase-tools&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firebase login&lt;/code&gt;会出现问题，建议在这篇文章中找解答&lt;a href=&quot;https://blog.csdn.net/weixin_34137799/article/details/88723239&quot; target=&quot;_blank&quot;&gt;关于firebase login的问题&lt;/a&gt; 注意如果是国内使用vpn需要将 node_modules中faye-websocket的代理进行设置。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firebase init hosting&lt;/code&gt;表示在hosting界面部署&lt;/li&gt;
      &lt;li&gt;之后会问到一系列问题，我的回答如下，以build作为部署目录，选择的是firebase上面的相关项目，不重写index.html文件。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/react-test-firebaseinit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;之后本来的文件夹下会显示两个以firebase开头的文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firebase deploy&lt;/code&gt;部署，成功后会显示以下内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/react-test-firebasedeploy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打开firebase的hosting中可以看到自己写的网站上线部署成功！&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 11 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/11/React%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/11/React%E7%AC%94%E8%AE%B0/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> React 制作一个burger </title>
        <description>&lt;h3 id=&quot;planning-a-react-app怎样构建一个-app&quot;&gt;Planning a React App怎样构建一个 app&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;component Tree / structure&lt;/li&gt;
  &lt;li&gt;application state&lt;/li&gt;
  &lt;li&gt;components vs containers
 structure:
 APP
    &lt;ul&gt;
      &lt;li&gt;toolbar
        &lt;ul&gt;
          &lt;li&gt;drower toggle&lt;/li&gt;
          &lt;li&gt;logo&lt;/li&gt;
          &lt;li&gt;navigation items&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;sideDrawer
        &lt;ul&gt;
          &lt;li&gt;logo&lt;/li&gt;
          &lt;li&gt;navigation items&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;backDrop&lt;/li&gt;
      &lt;li&gt;props.children
        &lt;ul&gt;
          &lt;li&gt;burger build control …order button&lt;/li&gt;
          &lt;li&gt;burger&lt;/li&gt;
          &lt;li&gt;modal
 State 
ingredient （meat * 2, cheese *2）
purchase :true /false
price&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在开始项目之前可以先将 css设定好
Optional:&lt;/p&gt;

&lt;p&gt;If you still want to eject and manually adjust the Webpack config (as we do it in the new videos - which you don’t need to do if you follow the approach described in the link above), you should take the below comments into account in case your webpack config (after ejecting) doesn’t look the same as it does in my videos:&lt;/p&gt;

&lt;p&gt;After ejecting, we edit a Webpack config file that’s made available by ejecting. This file might look slightly different for you.&lt;/p&gt;

&lt;p&gt;In the video, I’ll look for an entry that starts like this (in the webpack.config.js file):&lt;/p&gt;

&lt;p&gt;{
  test: /.css$/,
  …
}
and I then edit this entry.&lt;/p&gt;

&lt;p&gt;This entry now looks slightly different. You’ll have to find the following part in your webpack.config.js file:&lt;/p&gt;

&lt;p&gt;{
  test: cssRegex,
  exclude: cssModuleRegex,
  …
}
and then edit that entry.&lt;/p&gt;

&lt;p&gt;Finally, it should look like this:&lt;/p&gt;

&lt;p&gt;{
  test: cssRegex,
  exclude: cssModuleRegex,
  use: getStyleLoaders({
      importLoaders: 1,
      modules: true,
      localIdentName: ‘[name]&lt;strong&gt;[local]&lt;/strong&gt;[hash:base64:5]’
  }),
}
You can ignore me editing the webpack.config.prod.js file - with the latest version of create-react-app, ejecting only gives you ONE webpack config file (which you edit as described above).&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/11/React%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAburger/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/11/React%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAburger/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>class-based</category>
        
        
      </item>
    
      <item>
        <title> React Native 设备加载 </title>
        <description>&lt;h2 id=&quot;react-native-实现手机端的相机加载&quot;&gt;React Native 实现手机端的相机加载&lt;/h2&gt;

&lt;p&gt;需要了解到 expo 作为一个基础平台提供了很多工具，比如加载数据库，获取手机的权限，打开相机并拍照等功能，所以利用 expo 提供的 API 实现一个能打开相机，保存拍摄的图片，获得当前位置，在地图上展现出当前位置的 App。&lt;/p&gt;

&lt;h2 id=&quot;基础界面&quot;&gt;基础界面&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;分为 4 个界面
    &lt;ul&gt;
      &lt;li&gt;MapScreen &lt;em&gt;地图界面&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;NewPlaceScreen &lt;em&gt;创建新的图片和位置界面&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;PlaceDetailScreen &lt;em&gt;位置详细信息界面&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;PlacesListScreen &lt;em&gt;所有位置的渲染界面&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react-native-实现设备拍摄照片&quot;&gt;React Native 实现设备拍摄照片&lt;/h2&gt;

&lt;p&gt;用户在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImagePicker.launchCameraAsync({...})&lt;/code&gt;中获得的图像的URI即存储路径，同样其导入是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expo install expo-image-picker&lt;/code&gt;可以在官方文档的ImagePicker中找到用法,同样不光需要拍摄，在拍摄前需要获取device的权限，需要用到Permissions API&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import * as ImagePicker from 'expo-image-picker'; 
import * as Permissions from 'expo-permissions';

const verfiypermissions = async () =&amp;gt; {
        // 这个方法在用户确认后会自动保存在设备上， 用户不需要再次使用
        const result = await Permissions.askAsync(Permissions.CAMERA, Permissions.CAMERA_ROLL)// return 一个Promise
        if (result.status !== 'granted') {
            // 如果没有授权 
            Alert.alert('Insufficient Permissions!',
                'You need to grant camera permissions to use this app.',
                [{ text: 'okey' }]
            );
            return false;
        }
        return true;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;react-native-实现保存照片到本地device&quot;&gt;React Native 实现保存照片到本地device&lt;/h2&gt;

&lt;h2 id=&quot;react-native-实现-sqlite-数据库连接&quot;&gt;React Native 实现 SQLite 数据库连接&lt;/h2&gt;

&lt;p&gt;首先对数据库的连接是在创建 shopApp 中做的，这里是将 fetch 的网页连接变成实际的数据库，当然调用的是用原生 Sql 语言编写，expo 的 SQLite API 提供了事务性。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先定义一个 helpers 包和 App.js 同级，这个是为了更好的调用数据库，其中写入 db.js 文件
在终端中导入包 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expo install expo-sqlite&lt;/code&gt;可以在官方文档的SQLite中找到用法&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面代码定义了创建一个 places 数据库，首先是新建一个 Promise,其中的 SQLite.openDatabase(…) 在官方文档中 Open a database, creating it if it doesn’t exist, and return a Database object,利用 Promise 包裹住这个事务是保证有 error 时可以在 await 中 catch 住。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import * as SQLite from 'expo-sqlite';

const db = SQLite.openDatabase('place.db');

export const init = () =&amp;gt; {
    //create basic table
    const promise = new Promise((resolve, reject) =&amp;gt; {
        db.transaction((tx) =&amp;gt; {
            // transaction保证事务性
            tx.executeSql(&quot;CREATE TABLE IF NOT EXISTS places (id INTEGER PRIMARY KEY NOT NULL, title TEXT NOT NULL, imageUri TEXT NOT NULL, address TEXT NOT NULL, lat REAL NOT NULL, lng REAL NOT NULL)&quot;,
                [],
                () =&amp;gt; {
                    // SUCCESS
                    resolve();
                },
                (_, err) =&amp;gt; {//第一个参数是 repeition of query ,第二个才是需要的error信息
                    // error
                    reject(err);
                }
            );
        });
    });
    return promise;
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 store/places-actions.js 中来获得数据库传入的数据
这里的 FileSystem.documentDirectory 又是 expo 提供的 API 需要先导入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expo install expo-file-system&lt;/code&gt;可以在官方文档的FileSystem中找到用法作用是：provides access to a file system stored locally on the device. Within the Expo client, each app has a separate file system and has no access to the file system of other Expo apps.这里是为了将拍下来的照片存入device。&lt;/p&gt;

    &lt;p&gt;其中addPlace是需要在NewPlaceScreen中载入的图片，其中传入的参数，一个是用户输入的title,一个是存入缓存中的imageUri,一路follow其实传递路线是&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const addPlace = (title, image) =&amp;gt; {
    return async dispatch =&amp;gt; {
        // 需要dispatch的方法
        const fileName = image.split('/').pop();
        const newPath = FileSystem.documentDirectory + fileName;
        console.log(newPath)

        try {
            await FileSystem.moveAsync({// 存储位置 从哪里来 到哪里去
                from: image,
                to: newPath
            });
            const dbResult = await insertPlace(
                title,
                newPath,
                'Dummey Address',
                15.6,
                12.3
            );
            console.log(dbResult);
            dispatch({ type: ADD_PLACE, placeData:
            { id: dbResult.insertId,
            title: title,
            image: newPath } });

        } catch (err) {
            console.log(err);
            throw (err);
        }
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;react-native-实现手机端获得地址&quot;&gt;React Native 实现手机端获得地址&lt;/h2&gt;

&lt;h2 id=&quot;react-native-百度地图实现静态地图渲染&quot;&gt;React Native 百度地图实现静态地图渲染&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://lbsyun.baidu.com/index.php?title=static&quot; target=&quot;_blank&quot;&gt;百度地图开发者获得静态地图界面&lt;/a&gt;
原始的教程中是 Google Map 获得 API 但是需要绑定 credit card 以及连接 VPN，这里利用百度地图也可以实现类似功能，就是界面有点难找：）&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/06/React-Native%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E6%89%8B%E6%9C%BA%E5%8A%A0%E8%BD%BD/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/06/React-Native%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E6%89%8B%E6%9C%BA%E5%8A%A0%E8%BD%BD/</guid>
        
        <category>react native</category>
        
        <category>self-learning</category>
        
        <category>permission</category>
        
        
      </item>
    
  </channel>
</rss>
