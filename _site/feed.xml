<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joy Blog</title>
    <description>季月侣的Blog || About Joy </description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 18 Dec 2020 15:01:56 +0800</pubDate>
    <lastBuildDate>Fri, 18 Dec 2020 15:01:56 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title> jvm </title>
        <description>&lt;h1 id=&quot;chapter-1--什么是jvm&quot;&gt;Chapter 1  什么是JVM&lt;/h1&gt;
&lt;h2 id=&quot;定义-java-visual-machine&quot;&gt;定义 java visual machine&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;优点
    &lt;ol&gt;
      &lt;li&gt;一次编写到处运行&lt;/li&gt;
      &lt;li&gt;自动内存管理，垃圾回收&lt;/li&gt;
      &lt;li&gt;数组下标越界自动检查&lt;/li&gt;
      &lt;li&gt;多态&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;学习jvm有什么用&quot;&gt;学习JVM有什么用&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;面试&lt;/li&gt;
  &lt;li&gt;理解底层原理&lt;/li&gt;
  &lt;li&gt;中高级的必备技能 项目上线之后会有内存溢出等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常见-jvm&quot;&gt;常见 JVM&lt;/h2&gt;
&lt;p&gt;hot spot&lt;/p&gt;

&lt;h2 id=&quot;jvm-学习路线&quot;&gt;JVM 学习路线&lt;/h2&gt;
&lt;p&gt;java class -&amp;gt; java classLoader &amp;lt;–&amp;gt; 内存结构(方法区 -&amp;gt; 堆 -&amp;gt; 虚拟机栈 -&amp;gt; 程序计数器 -&amp;gt; 本地方法栈) &amp;lt;–&amp;gt; 执行引擎(解释器 -&amp;gt; 即时编译器 -&amp;gt; GC 垃圾回收)&lt;/p&gt;

&lt;p&gt;学习顺序是1. 内存结构 2. 垃圾回收 3. java class 4. java classLoader 5. 即时编译器&lt;/p&gt;

&lt;h2 id=&quot;内存结构&quot;&gt;内存结构&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序计数器 ： Program Counter Register&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;方法区 -&amp;gt; 堆 -&amp;gt; 虚拟机栈 -&amp;gt;  -&amp;gt; 本地方法栈&lt;/p&gt;

</description>
        <pubDate>Thu, 17 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/17/JAVA-jvm/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/17/JAVA-jvm/</guid>
        
        <category>Java</category>
        
        <category>JVM</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记04 重新认识SpringBoot 运行中的SpringBoot </title>
        <description>&lt;h1 id=&quot;chapter-8-重新认识springboot&quot;&gt;Chapter 8 重新认识SpringBoot&lt;/h1&gt;
&lt;p&gt;Spring boot 不是什么
不是应⽤用服务器
不是 Java EE 之类的规范 
不是代码⽣生成器
不是 Spring Framework 的升级版&lt;/p&gt;

&lt;h2 id=&quot;spring-boot-特性&quot;&gt;Spring Boot 特性&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;⽅便地创建可独⽴运行的 Spring 应⽤程序&lt;/li&gt;
  &lt;li&gt;直接内嵌 Tomcat、Jetty 或 Undertow&lt;/li&gt;
  &lt;li&gt;简化了项⽬的构建配置&lt;/li&gt;
  &lt;li&gt;为 Spring 及第三⽅库提供⾃动配置&lt;/li&gt;
  &lt;li&gt;提供⽣产级特性&lt;/li&gt;
  &lt;li&gt;无需⽣成代码或进⾏ XML 配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-boot-核心&quot;&gt;Spring Boot 核心&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;⾃动配置 - Auto Configuration&lt;/li&gt;
  &lt;li&gt;起步依赖 - Starter Dependency&lt;/li&gt;
  &lt;li&gt;命令行界⾯面 - Spring Boot CLI&lt;/li&gt;
  &lt;li&gt;Actuator&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;了解自动配置原理&quot;&gt;了解自动配置(原理)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;自动配置
    &lt;ul&gt;
      &lt;li&gt;基于添加的 JAR 依赖⾃自动对 Spring Boot 应⽤用程序进行配置&lt;/li&gt;
      &lt;li&gt;spring-boot-autoconfiguration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启⾃动配置
    &lt;ul&gt;
      &lt;li&gt;@EnableAutoConfiguration
        &lt;ul&gt;
          &lt;li&gt;exclude = Class&amp;lt;?&amp;gt;[] 指定排除哪些配置&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;@SpringBootApplication（默认带了@EnableAutoConfiguration）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自动配置实现原理&quot;&gt;自动配置实现原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;@EnableAutoConfiguration
    &lt;ul&gt;
      &lt;li&gt;AutoConfigurationImportSelector&lt;/li&gt;
      &lt;li&gt;META-INF/spring.factories
        &lt;ul&gt;
          &lt;li&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;了解自动配置的情况&quot;&gt;了解⾃自动配置的情况&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;观察⾃自动配置的判断结果
run configuration 里面 –debug&lt;/li&gt;
  &lt;li&gt;ConditionEvaluationReportLoggingListener
    &lt;ul&gt;
      &lt;li&gt;Positive matches&lt;/li&gt;
      &lt;li&gt;Negative matches&lt;/li&gt;
      &lt;li&gt;Exclusions&lt;/li&gt;
      &lt;li&gt;Unconditional classes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;手动实现自动配置&quot;&gt;手动实现自动配置&lt;/h2&gt;
&lt;h3 id=&quot;主要工作内容&quot;&gt;主要工作内容&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;编写 Java Config
    &lt;ul&gt;
      &lt;li&gt;@Configuration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;添加条件
    &lt;ul&gt;
      &lt;li&gt;定位⾃自动配置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@Conditional
    &lt;ul&gt;
      &lt;li&gt;META-INF/spring.factories&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;条件注解&quot;&gt;条件注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;条件注解
    &lt;ul&gt;
      &lt;li&gt;@Conditional &lt;strong&gt;在Spring 4中引入的在3中没有&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnClass 存在一个类时做什么&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingClass&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;属性条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnProperty 属性等于特定的值时应该做什么&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bean 条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnBean 存在某个Bean做什么&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingBean&lt;/li&gt;
      &lt;li&gt;@ConditionalOnSingleCandidate 上下文只有一个候选的Bean的时候应该做什么 如果是Primary也是满足这个条件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;资源条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnResource&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Web 应⽤用条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnWebApplication 如果是web应用满足什么条件&lt;/li&gt;
      &lt;li&gt;@ConditionalOnNotWebApplication&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他条件
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnExpression&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJava&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJndi&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自动配置执行顺序&quot;&gt;自动配置执行顺序&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;自动配置的执⾏顺序
    &lt;ul&gt;
      &lt;li&gt;@AutoConfigureBefore&lt;/li&gt;
      &lt;li&gt;@AutoConfigureAfter&lt;/li&gt;
      &lt;li&gt;@AutoConfigureOrder&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;在需要引入自动配置的类下面引入两个写好的自动配置项，注意是applicationRunner格式不佳任何注解，防止生成Bean，详见69课&lt;/p&gt;

&lt;h2 id=&quot;springboot-提供的failureanalysis&quot;&gt;SpringBoot 提供的FailureAnalysis&lt;/h2&gt;
&lt;p&gt;位置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/Users/apple/.m2/repository/org/springframework/boot/spring-boot/2.1.4.RELEASE/spring-boot-2.1.4.RELEASE.jar!/org/springframework/boot/diagnostics/FailureAnalysis.class&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;private final String description; 失败描述&lt;/li&gt;
  &lt;li&gt;private final String action; 失败建议后续动作&lt;/li&gt;
  &lt;li&gt;private final Throwable cause; 失败异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何在低版本-spring-中快速实现类似自动配置的功能&quot;&gt;如何在低版本 Spring 中快速实现类似⾃自动配置的功能&lt;/h2&gt;

&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;3.x 的 Spring 没有条件注解&lt;/li&gt;
  &lt;li&gt;⽆法⾃动定位需要加载的⾃动配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;核解决思路&quot;&gt;核⼼解决思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;条件判断
    &lt;ul&gt;
      &lt;li&gt;通过 BeanFactoryPostProcessor 进⾏判断&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置加载
    &lt;ul&gt;
      &lt;li&gt;编写 Java Config 类&lt;/li&gt;
      &lt;li&gt;引入配置类
        &lt;ul&gt;
          &lt;li&gt;通过 component-scan&lt;/li&gt;
          &lt;li&gt;通过 XML ⽂件 import&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-的两个扩展点&quot;&gt;Spring 的两个扩展点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BeanPostProcessor
    &lt;ul&gt;
      &lt;li&gt;针对 Bean 实例例&lt;/li&gt;
      &lt;li&gt;在 Bean 创建后提供定制逻辑回调&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BeanFactoryPostProcessor
    &lt;ul&gt;
      &lt;li&gt;针对 Bean 定义&lt;/li&gt;
      &lt;li&gt;在容器创建 Bean 前获取配置元数据&lt;/li&gt;
      &lt;li&gt;Java Config 中需要定义为 static ⽅方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关于-bean-的一些定制&quot;&gt;关于 Bean 的一些定制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Lifecycle Callback
    &lt;ul&gt;
      &lt;li&gt;InitializingBean / @PostConstruct / init-method 初始化&lt;/li&gt;
      &lt;li&gt;DisposableBean / @PreDestroy / destroy-method bean销毁时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XxxAware 接⼝
    &lt;ul&gt;
      &lt;li&gt;ApplicationContextAware 注入ApplicationContext&lt;/li&gt;
      &lt;li&gt;BeanFactoryAware&lt;/li&gt;
      &lt;li&gt;BeanNameAware 注入Bean名字&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用操作&quot;&gt;常用操作&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;判断类是否存在
    &lt;ul&gt;
      &lt;li&gt;ClassUtils.isPresent()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;判断 Bean 是否已定义
    &lt;ul&gt;
      &lt;li&gt;ListableBeanFactory.containsBeanDefinition()&lt;/li&gt;
      &lt;li&gt;ListableBeanFactory.getBeanNamesForType()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注册 Bean 定义
    &lt;ul&gt;
      &lt;li&gt;BeanDefinitionRegistry.registerBeanDefinition()
        &lt;ul&gt;
          &lt;li&gt;GenericBeanDefinition&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BeanFactory.registerSingleton()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter-9-使用lucene-和-elasticsearch-实现全文检索和分析&quot;&gt;chapter 9 使用Lucene 和 ElasticSearch 实现全文检索和分析&lt;/h1&gt;
&lt;p&gt;1、创建一个索引文件目录，然后把需要检索的信息 用Field 对应匹配的 封装成一个Document文档对象，将这个对象放入索引文件目录中，这里既可以将索引存放到磁盘中，也可以放入内存中，如果放入内存，那么程序关闭索引就没有了，所以一般都是将索引放入磁盘中；&lt;/p&gt;

&lt;p&gt;2、如果发现信息有问题需要删除，那么索引文件也要删除，否则检索的时候还是会查询得到，这个时候需要根据索引id去删除对应的索引；&lt;/p&gt;

&lt;p&gt;3、如果发现信息被更新了，那么索引文件也要更新，这个时候需要先将旧的索引删除然后添加新的索引；&lt;/p&gt;

&lt;p&gt;4、最后重头戏是全文搜索了，这和查询数据库一样，先需要创建索引读取对象，然后封装Query查询对象，调用search()方法 得到检索结果。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/supermao1013/article/details/83443611&quot; target=&quot;_blank&quot;&gt; lucene 在java中如何使用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用elasticsearch可视化内容&quot;&gt;使用ElasticSearch可视化内容&lt;/h2&gt;

&lt;p&gt;如何利用docker开启elasticSearch在本地的方法在Docker那个小结已经实现，主要注意力在code上。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Elasticsearch是基于Lucene开发的一个分布式全文检索框架，向Elasticsearch中存储和从Elasticsearch中查询，格式是json。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;索引index，相当于数据库中的database。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型type相当于数据库中的table。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主键id相当于数据库中记录的主键，是唯一的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向Elasticsearch中存储数据，其实就是向es中的index下面的type中存储json类型的数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Elasticsearch是RestFul风格的api，通过http的请求形式（注意，参数是url拼接还是请求的json形式哦），发送请求，对Elasticsearch进行操作。
    &lt;ul&gt;
      &lt;li&gt;查询，请求方式应该是get。删除，请求方式应该是delete。添加，请求方式应该是put/post。修改，请求方式应该是put/post。&lt;/li&gt;
      &lt;li&gt;RESTFul接口url的格式:http://ip:port/&lt;index&gt;/&lt;type&gt;/&amp;lt;[id]&amp;gt;。其中index、type是必须提供的。id是可以选择的，不提供es会自动生成，index、type将信息进行分层，利于管理。&lt;/type&gt;&lt;/index&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;chapter-10-运行中的springboot&quot;&gt;Chapter 10 运行中的SpringBoot&lt;/h1&gt;

&lt;h2 id=&quot;springboot的各种-actuator-endpoint&quot;&gt;SpringBoot的各种 Actuator EndPoint&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Actuator 目的是监控和管理应用程序&lt;/li&gt;
  &lt;li&gt;访问形式 HTTP,JMX&lt;/li&gt;
  &lt;li&gt;使用 引入spring-boot-start-actuator&lt;/li&gt;
  &lt;li&gt;访问接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;接入访问&quot;&gt;接入访问&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 访问
    &lt;ul&gt;
      &lt;li&gt;/actuator/&lt;id&gt;&lt;/id&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;端⼝与路径
    &lt;ul&gt;
      &lt;li&gt;management.server.address=&lt;/li&gt;
      &lt;li&gt;management.server.port= actuator 发布端口和应用端口分开实现隔离外部访问端口设置为8080 但是actuator端口是用8081外部就不会访问acutuator&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.base-path=/actuator&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.path-mapping.&lt;id&gt;=路径&lt;/id&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启 Endpoint
    &lt;ul&gt;
      &lt;li&gt;management.endpoint.&lt;id&gt;.enabled=true 可以通过这种方式关掉某写端口&lt;id&gt;变成health并且设置为false就能关掉health端口&lt;/id&gt;&lt;/id&gt;&lt;/li&gt;
      &lt;li&gt;management.endpoints.enabled-by-default=false&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;暴露 Endpoint
    &lt;ul&gt;
      &lt;li&gt;management.endpoints.jmx.exposure.exclude=&lt;/li&gt;
      &lt;li&gt;management.endpoints.jmx.exposure.include=* 表示发布所有&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.exposure.exclude=&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.exposure.include=info, health&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;打开 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:8080/actuator&lt;/code&gt; 可以看见各种对web状况&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自己定制-health-indicator&quot;&gt;自己定制 health Indicator&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;目的：检查应用程序的运行状态&lt;/li&gt;
  &lt;li&gt;状态：
    &lt;ul&gt;
      &lt;li&gt;DOWN 503&lt;/li&gt;
      &lt;li&gt;OUT_OF_SERVICE 503&lt;/li&gt;
      &lt;li&gt;UP 200&lt;/li&gt;
      &lt;li&gt;UNKNOWN 200&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-boot-带的-health-indicator&quot;&gt;Spring Boot ⾃带的 Health Indicator&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;机制
    &lt;ul&gt;
      &lt;li&gt;通过 HealthIndicatorRegistry 收集信息&lt;/li&gt;
      &lt;li&gt;HealthIndicator 实现具体检查逻辑&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置项
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;management.health.defaults.enabled=true&lt;/td&gt;
              &lt;td&gt;false 默认打开所有indicator&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;management.health.&lt;id&gt;.enabled=true&lt;/id&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;management.endpoint.health.show-details=never&lt;/td&gt;
              &lt;td&gt;when-&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;authorized&lt;/td&gt;
              &lt;td&gt;always 看到具体明细状况&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自定义health-indicator&quot;&gt;自定义Health Indicator&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pom&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;application.properties文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.jpa.hibernate.ddl-auto=none
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true

management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

info.app.author=DigitalSonic
info.app.encoding=@project.build.sourceEncoding@
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的info.app是这是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8080/actuctor/info&lt;/code&gt;中能看到的author信息和encoding&lt;/p&gt;

&lt;p&gt;因为是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show-details&lt;/code&gt;所以是显示所有的database具体信息的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实际的indicator
在support文件中加入&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
public class CoffeeIndicator implements HealthIndicator {
  @Autowired
  private CoffeeService coffeeService;

  @Override
  public Health health() {
    long count = coffeeService.getCoffeeCount();
    Health health;
    if (count &amp;gt; 0) {
      health = Health.up()
        .withDetail(&quot;count&quot;, count)
        .withDetail(&quot;message&quot;, &quot;We have enough coffee.&quot;)
        .build();
    } else {
      health = Health.down()
              .withDetail(&quot;count&quot;, 0)
              .withDetail(&quot;message&quot;, &quot;We are out of coffee.&quot;)
              .build();
    }
    return health;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码表示如果没有在数据库中有多余0的数量的coffee就表示插入失败，是一种自动配置不需要再Controller中实现调用&lt;/p&gt;

&lt;h2 id=&quot;micrometer-获得运行数据&quot;&gt;Micrometer 获得运行数据&lt;/h2&gt;
&lt;p&gt;度量界的Sl4j&lt;/p&gt;
&lt;h3 id=&quot;micrometer-特性&quot;&gt;Micrometer 特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;多维度
    &lt;ul&gt;
      &lt;li&gt;支持Tag&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;预置了大量探针
    &lt;ul&gt;
      &lt;li&gt;缓存 类加载器 GC CPU使用率 线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;与 Spring深度整合&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;核心度量指标&quot;&gt;核心度量指标&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;核心接口
    &lt;ul&gt;
      &lt;li&gt;Meter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内置实现
    &lt;ul&gt;
      &lt;li&gt;Gauge TimeGauge CPU使用情况&lt;/li&gt;
      &lt;li&gt;Timer LongTaskTimer FunctionTimer&lt;/li&gt;
      &lt;li&gt;Counter, FunctionCounter 分布式情况&lt;/li&gt;
      &lt;li&gt;DistributionSummary&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;micrometer-in-spring-boot-2x&quot;&gt;Micrometer in Spring Boot 2.x&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;⼀些 URL
    &lt;ul&gt;
      &lt;li&gt;/actuator/metrics&lt;/li&gt;
      &lt;li&gt;/actuator/prometheus&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些配置项
    &lt;ul&gt;
      &lt;li&gt;management.metrics.export.*&lt;/li&gt;
      &lt;li&gt;management.metrics.tags.*&lt;/li&gt;
      &lt;li&gt;management.metrics.enable.*&lt;/li&gt;
      &lt;li&gt;management.metrics.distribution.*&lt;/li&gt;
      &lt;li&gt;management.metrics.web.server.auto-time-requests&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;micrometer-in-spring-boot-2x-1&quot;&gt;Micrometer in Spring Boot 2.x&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;核⼼度量项
    &lt;ul&gt;
      &lt;li&gt;JVM、CPU、⽂文件句句柄数、⽇日志、启动时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他度量量项
    &lt;ul&gt;
      &lt;li&gt;Spring MVC、Spring WebFlux&lt;/li&gt;
      &lt;li&gt;Tomcat、Jersey JAX-RS&lt;/li&gt;
      &lt;li&gt;RestTemplate、WebClient&lt;/li&gt;
      &lt;li&gt;缓存、数据源、Hibernate&lt;/li&gt;
      &lt;li&gt;Kafka、RabbitMQ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;具体的实现&quot;&gt;具体的实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;自定义度量指标
    &lt;ul&gt;
      &lt;li&gt;通过 MeterRegistry 注册 Meter&lt;/li&gt;
      &lt;li&gt;提供 MeterBinder Bean 让 Spring Boot ⾃动绑定&lt;/li&gt;
      &lt;li&gt;通过 MeterFilter 进行定制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在Service 上面implements一个MeterBiner的接口 在这个Service中注册一个 Counter&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Service
@Transactional
@Slf4j
public class CoffeeOrderService implements MeterBinder {
  @Autowired
  private CoffeeOrderRepository orderRepository;

  private Counter orderCounter = null;

  public CoffeeOrder get(Long id) {
      return orderRepository.getOne(id);
  }

  public CoffeeOrder createOrder(String customer, Coffee...coffee) {
    CoffeeOrder order = CoffeeOrder.builder()
            .customer(customer)
            .items(new ArrayList&amp;lt;&amp;gt;(Arrays.asList(coffee)))
            .state(OrderState.INIT)
            .build();
    CoffeeOrder saved = orderRepository.save(order);
    log.info(&quot;New Order: {}&quot;, saved);
    orderCounter.increment();
    return saved;
  }

  public boolean updateState(CoffeeOrder order, OrderState state) {
    if (state.compareTo(order.getState()) &amp;lt;= 0) {
      log.warn(&quot;Wrong State order: {}, {}&quot;, state, order.getState());
      return false;
    }
    order.setState(state);
    orderRepository.save(order);
    log.info(&quot;Updated Order: {}&quot;, order);
    return true;
  }

  @Override
  public void bindTo(MeterRegistry meterRegistry) {
    this.orderCounter = meterRegistry.counter(&quot;order.count&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码维护了一个Counter并在最后将他注册为了一个MeterRegistry在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8080/actuator/order.count&lt;/code&gt;中只要是创建了订单就都会在这里有所体现。&lt;/p&gt;

&lt;h2 id=&quot;收集监控信息并展示springboot-admin&quot;&gt;收集监控信息并展示SpringBoot Admin&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目的:为 Spring Boot 应用程序提供一套管理界⾯ &lt;strong&gt;actuator中通过json显示的信息可以可视化的显示出来&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;主要功能:
    &lt;ul&gt;
      &lt;li&gt;集中展示应⽤用程序 Actuator 相关的内容&lt;/li&gt;
      &lt;li&gt;变更通知&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;快速上手&quot;&gt;快速上手&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;服务端
    &lt;ul&gt;
      &lt;li&gt;de.codecentric:spring-boot-admin-starter-server:2.1.3&lt;/li&gt;
      &lt;li&gt;@EnableAdminServer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端
    &lt;ul&gt;
      &lt;li&gt;de.codecentric:spring-boot-admin-starter-client:2.1.3 配置服务端及Endpoint&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.url=http://localhost:8080&lt;/li&gt;
      &lt;li&gt;management.endpoints.web.exposure.include=*&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全控制&quot;&gt;安全控制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;安全相关依赖
    &lt;ul&gt;
      &lt;li&gt;spring-boot-starter-security&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;服务端配置
    &lt;ul&gt;
      &lt;li&gt;spring.security.user.name&lt;/li&gt;
      &lt;li&gt;spring.security.user.password&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端配置
    &lt;ul&gt;
      &lt;li&gt;spring.boot.admin.client.username&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.password&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.instance.metadata.user.name&lt;/li&gt;
      &lt;li&gt;spring.boot.admin.client.instance.metadata.user.password&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-sba-server-demo-sba-client-demo&quot;&gt;案例 sba-server-demo sba-client-demo&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;server端的pom&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;server 端 applic.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.application.name=sba-server
server.port=8080

spring.security.user.name=geektime
spring.security.user.password=sba-server-password
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;server端 的主程序
加上了@EnableAdminServer注解&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
@EnableAdminServer
public class SbaServerApplication extends WebSecurityConfigurerAdapter {
	@Autowired
	private AdminServerProperties adminServerProperties;

	public static void main(String[] args) {
		SpringApplication.run(SbaServerApplication.class, args);
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		String adminContextPath = adminServerProperties.getContextPath();

		SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();
		successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);
		successHandler.setDefaultTargetUrl(adminContextPath + &quot;/&quot;);

		http.authorizeRequests()
				.antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()
				.antMatchers(adminContextPath + &quot;/login&quot;).permitAll()
				.anyRequest().authenticated()
				.and()
				.formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and()
				.logout().logoutUrl(adminContextPath + &quot;/logout&quot;).and()
				.httpBasic().and()
				.csrf()
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
				.ignoringAntMatchers(
						adminContextPath + &quot;/instances&quot;,
						adminContextPath + &quot;/actuator/**&quot;
				);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码实现了AdminServerProperties自动注入，并且对url的类型做出控制，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTargetUrlParameter(&quot;redirectTo&quot;);&lt;/code&gt;表示可以进行重定向，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/assets/**&quot;&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;/login&quot;&lt;/code&gt;是不需要身份认证的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formLogin&lt;/code&gt;表示通过表单做登录，登出的url是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logout&lt;/code&gt;还开启了csrf支持&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.ignoringAntMatchers(
  adminContextPath + &quot;/instances&quot;,
  adminContextPath + &quot;/actuator/**&quot;
)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示忽略因为instances是server对client注册信息，actuator是用来监控&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client端的pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;client端application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.application.name=sba-client
server.port=8081

management.endpoints.web.exposure.include=*

info.demo.name=Spring Boot Admin Client Demo

spring.security.user.name=geektime
spring.security.user.password=sba-client-password

spring.boot.admin.client.url=http://localhost:8080
spring.boot.admin.client.username=geektime
spring.boot.admin.client.password=sba-server-password

spring.boot.admin.client.instance.metadata.user.name=${spring.security.user.name}
spring.boot.admin.client.instance.metadata.user.password=${spring.security.user.password}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;转为了8081端口，发布了所有端口，访问的server 是8080端口上的，用户名密码都对应了server中的用户名密码，通过占位符配置了instance的用户名密码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不建议产线上使用spring boot admin&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何定制web容器参数&quot;&gt;如何定制web容器参数&lt;/h2&gt;
&lt;h3 id=&quot;可选容器列表&quot;&gt;可选容器列表&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;spring-boot-starter-tomcat&lt;/li&gt;
  &lt;li&gt;spring-boot-starter-jetty&lt;/li&gt;
  &lt;li&gt;spring-boot-starter-undertow&lt;/li&gt;
  &lt;li&gt;spring-boot-starter-reactor-netty&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;修改容器配置&quot;&gt;修改容器配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;端⼝
    &lt;ul&gt;
      &lt;li&gt;server.port&lt;/li&gt;
      &lt;li&gt;server.address&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;压缩
    &lt;ul&gt;
      &lt;li&gt;server.compression.enabled 设置为True&lt;/li&gt;
      &lt;li&gt;server.compression.min-response-size 最小默认为2k&lt;/li&gt;
      &lt;li&gt;server.compression.mime-types&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;修改容器配置&quot;&gt;修改容器配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Tomcat 配置
    &lt;ul&gt;
      &lt;li&gt;server.tomcat.max-connections=10000&lt;/li&gt;
      &lt;li&gt;server.tomcat.max-http-post-size=2MB&lt;/li&gt;
      &lt;li&gt;server.tomcat.max-swallow-size=2MB&lt;/li&gt;
      &lt;li&gt;server.tomcat.max-threads=200&lt;/li&gt;
      &lt;li&gt;server.tomcat.min-spare-threads=10&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;错误处理
    &lt;ul&gt;
      &lt;li&gt;server.error.path=/error 错误页面是不是要显示信息&lt;/li&gt;
      &lt;li&gt;server.error.include-exception=false&lt;/li&gt;
      &lt;li&gt;server.error.include-stacktrace=never  在产线上不要打开&lt;/li&gt;
      &lt;li&gt;server.error.whitelabel.enabled=true&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他
    &lt;ul&gt;
      &lt;li&gt;server.use-forward-headers 设置头 传递真实的来源IP&lt;/li&gt;
      &lt;li&gt;server.servlet.session.timeout 设置超时&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编程方式
    &lt;ul&gt;
      &lt;li&gt;WebServerFactoryCustomizer&lt;T&gt;
&lt;/T&gt;        &lt;ul&gt;
          &lt;li&gt;TomcatServletWebServerFactory&lt;/li&gt;
          &lt;li&gt;JettyServletWebServerFactory&lt;/li&gt;
          &lt;li&gt;UndertowServletWebServerFactory&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;也可以自己写一个WebServerFactoryCustomizer 详见tomcat-demo&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实际案例&quot;&gt;实际案例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.jpa.hibernate.ddl-auto=none
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true

server.compression.enabled=true
server.compression.min-response-size=512B

server.error.include-stacktrace=always
server.error.include-exception=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置了压缩量，include了错误信息和栈信息，设置为true在实际生产中不要这么用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;替换压缩配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想要编程实现压缩可以在主程序中写以下代码，application中的配置可以注掉&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void customize(TomcatServletWebServerFactory factory) {
  Compression compression = new Compression();
  compression.setEnabled(true);
  compression.setMinResponseSize(DataSize.ofBytes(512));
  factory.setCompression(compression);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;如何配置http2-上&quot;&gt;如何配置HTTP2 （上）&lt;/h2&gt;

&lt;h3 id=&quot;服务端配置https-service&quot;&gt;服务端配置HTTPS Service&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通过参数进行配置
    &lt;ul&gt;
      &lt;li&gt;server.port=8443&lt;/li&gt;
      &lt;li&gt;server.ssl.*
        &lt;ul&gt;
          &lt;li&gt;server.ssl.key-store&lt;/li&gt;
          &lt;li&gt;server.ssl.key-store-type，JKS或者PKCS12&lt;/li&gt;
          &lt;li&gt;server.ssl.key-store-password=secret&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;⽣成证书文件
    &lt;ul&gt;
      &lt;li&gt;命令
        &lt;ul&gt;
          &lt;li&gt;keytool -genkey -alias 别名&lt;/li&gt;
          &lt;li&gt;-storetype 仓库类型 -keyalg 算法 -keysize ⻓度&lt;/li&gt;
          &lt;li&gt;-keystore 文件名 -validity 有效期&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;说明
    &lt;ul&gt;
      &lt;li&gt;仓库类型，JKS、JCEKS、PKCS12 等&lt;/li&gt;
      &lt;li&gt;算法，RSA、DSA 等&lt;/li&gt;
      &lt;li&gt;⻓度，例例如 2048&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;eg. terminal上写入 springbucks apple$ keytool -genkey -alias springbucks -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore springbucks.p12 -validity 365&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;输入密钥库口令: spring 
再次输入新口令: spring
您的名字与姓氏是什么?
  [Unknown]:  Yuelyu
您的组织单位名称是什么?
  [Unknown]:  Yuelyu
您的组织名称是什么?
  [Unknown]:  Yuelyu
您所在的城市或区域名称是什么?
  [Unknown]:  Changchun
您所在的省/市/自治区名称是什么?
  [Unknown]:  Jilin
该单位的双字母国家/地区代码是什么?
  [Unknown]:  CN   
CN=Yuelyu, OU=Yuelyu, O=Yuelyu, L=Changchun, ST=Jilin, C=CN是否正确?
  [否]:  Y
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后会显示一个叫 springbucks.p12的文件&lt;/p&gt;

&lt;h3 id=&quot;客户端-https-支持&quot;&gt;客户端 HTTPS ⽀支持&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;配置 HttpClient ( &amp;gt;= 4.4 )
    &lt;ul&gt;
      &lt;li&gt;SSLContextBuilder 构造 SSLContext&lt;/li&gt;
      &lt;li&gt;setSSLHostnameVerifier(new NoopHostnameVerifier())&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置 RequestFactory
    &lt;ul&gt;
      &lt;li&gt;HttpComponentsClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;setHttpClient()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-ssl-waiter-service--ssl-customer-service&quot;&gt;案例 ssl-waiter-service &amp;amp; ssl-customer-service&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;service 中显示将刚刚配置的springbucks.p12文件导入到其中的resource目录下
在application.properties中写入，这里换了端口&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;# 在使用SSL属性时开的端口
server.port=8443
server.ssl.key-store=classpath:springbucks.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=spring
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;client
    &lt;ul&gt;
      &lt;li&gt;在application.properties中配置，对应的发现的地址，并且配置一个同样的p12文件和密码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;waiter.service.url=https://localhost:8443

security.key-store=classpath:springbucks.p12
security.key-pass=spring
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在主程序中，注入用户名密码，配置SSL校验SSLContextBuilder&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Value(&quot;${security.key-store}&quot;)
private Resource keyStore;
@Value(&quot;${security.key-pass}&quot;)
private String keyPass;
...
// 在main函数中配置 bean
@Bean
	public HttpComponentsClientHttpRequestFactory requestFactory() {
		SSLContext sslContext = null;
		try {
			sslContext = SSLContextBuilder.create()
					// 会校验证书
					.loadTrustMaterial(keyStore.getURL(), keyPass.toCharArray())
					// 放过所有证书校验
//					.loadTrustMaterial(null, (certificate, authType) -&amp;gt; true)
					.build();
		} catch(Exception e) {
			log.error(&quot;Exception occurred while creating SSLContext.&quot;, e);
		}

		CloseableHttpClient httpClient = HttpClients.custom()
				.evictIdleConnections(30, TimeUnit.SECONDS)
				.setMaxConnTotal(200)
				.setMaxConnPerRoute(20)
				.disableAutomaticRetries()
				.setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())
				.setSSLContext(sslContext)
				.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)
				.build();

		HttpComponentsClientHttpRequestFactory requestFactory =
				new HttpComponentsClientHttpRequestFactory(httpClient);

		return requestFactory;
	}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;terminal中curl 地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8443/menu&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl -k -v https://localhost:8443/menu/&lt;/code&gt; 带上-k是接收不安全的证书 -v打印详细信息，不要忘记加https&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显示的是详细的返回信息和证书的信息&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8443 (#0)
* ALPN, offering http/1.1
* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH
* successfully set certificate verify locations:
*   CAfile: /Users/apple/anaconda3/ssl/cacert.pem
  CApath: none
* TLSv1.2 (OUT), TLS header, Certificate Status (22):
* TLSv1.2 (OUT), TLS handshake, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Server hello (2):
* TLSv1.2 (IN), TLS handshake, Certificate (11):
* TLSv1.2 (IN), TLS handshake, Server key exchange (12):
* TLSv1.2 (IN), TLS handshake, Server finished (14):
* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):
* TLSv1.2 (OUT), TLS handshake, Finished (20):
* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):
* TLSv1.2 (IN), TLS handshake, Finished (20):
* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384
* ALPN, server did not agree to a protocol
* Server certificate:
*  subject: C=CN; ST=Jilin; L=Changchun; O=Yuelyu; OU=Yuelyu; CN=Yuelyu
*  start date: Dec 18 02:21:13 2020 GMT
*  expire date: Dec 18 02:21:13 2021 GMT
*  issuer: C=CN; ST=Jilin; L=Changchun; O=Yuelyu; OU=Yuelyu; CN=Yuelyu
*  SSL certificate verify result: self signed certificate (18), continuing anyway.
&amp;gt; GET /menu/ HTTP/1.1
&amp;gt; Host: localhost:8443
&amp;gt; User-Agent: curl/7.61.1
&amp;gt; Accept: */*
&amp;gt; 
&amp;lt; HTTP/1.1 200 
&amp;lt; vary: accept-encoding
&amp;lt; Content-Type: application/json;charset=UTF-8
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Date: Fri, 18 Dec 2020 02:54:50 GMT
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;在client端运行文件 使用的是restTemplate将所有的内容通过编程的方式获得&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;配置-http2-下&quot;&gt;配置 HTTP/2 （下）&lt;/h2&gt;

&lt;h3 id=&quot;前提条件&quot;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;支持 Java &amp;gt;= JDK 9&lt;/li&gt;
  &lt;li&gt;Tomcat &amp;gt;= 9.0.0&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Spring Boot 不支持 h2c，需要先配置 SSL&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置项&quot;&gt;配置项&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;server.http2.enabled&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;客户端-http2-支持&quot;&gt;客户端 HTTP/2 支持&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 库选择
    &lt;ul&gt;
      &lt;li&gt;OkHttp( com.squareup.okhttp3:okhttp:3.14.0 )
        &lt;ul&gt;
          &lt;li&gt;OkHttpClient&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RestTemplate 配置
    &lt;ul&gt;
      &lt;li&gt;OkHttp3ClientHttpRequestFactory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例--http2-waiter-service--http2-customer-service&quot;&gt;案例  http2-waiter-service &amp;amp; http2-customer-service&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;server端 的 application.properties文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#设置 http2可行
server.http2.enabled=true
server.port=8443
server.ssl.key-store=classpath:springbucks.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=spring
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;client 端 修改CustormerApplication 主程序中注册的HttpClient为&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public ClientHttpRequestFactory requestFactory() {
  OkHttpClient okHttpClient = null;
  try {
    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
    keyStore.load(this.keyStore.getInputStream(), keyPass.toCharArray());//加载key store
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(keyStore);
    SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
    sslContext.init(null, tmf.getTrustManagers(), null);

    okHttpClient = new OkHttpClient.Builder()
        .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) tmf.getTrustManagers()[0])
        .hostnameVerifier((hostname, session) -&amp;gt; true)//对hostname 不做校验  
        .build();
  } catch (Exception e) {
    log.error(&quot;Exception occurred!&quot;, e);
  }
  return new OkHttp3ClientHttpRequestFactory(okHttpClient);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的代码只需要贴上去就可以实现http2的请求访问了&lt;/p&gt;

&lt;h2 id=&quot;spring-怎样开发一个只用命令行运行的程序&quot;&gt;Spring 怎样开发一个只用命令行运行的程序&lt;/h2&gt;

&lt;h3 id=&quot;关闭-web-容器&quot;&gt;关闭 Web 容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;控制依赖
    &lt;ul&gt;
      &lt;li&gt;不添加 Web 相关依赖&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置⽅式
    &lt;ul&gt;
      &lt;li&gt;spring.main.web-application-type=none&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编程⽅式
    &lt;ul&gt;
      &lt;li&gt;SpringApplication
        &lt;ul&gt;
          &lt;li&gt;setWebApplicationType()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SpringApplicationBuilder
        &lt;ul&gt;
          &lt;li&gt;web()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在调⽤ SpringApplication 的 run() ⽅法前 设置 WebApplicationType&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用工具类&quot;&gt;常⽤用⼯工具类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不同的 Runner
    &lt;ul&gt;
      &lt;li&gt;ApplicationRunner
        &lt;ul&gt;
          &lt;li&gt;参数是 ApplicationArguments&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CommandLineRunner
        &lt;ul&gt;
          &lt;li&gt;参数是 String[] 
&lt;strong&gt;以上两个功能是类似，就是在程序开始之前启动一段代码，区别在于参数&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;返回码
    &lt;ul&gt;
      &lt;li&gt;ExitCodeGenerator&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-command-line-demo&quot;&gt;案例 command-line-demo&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在application.properties中设置不能开启web
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.main.web-application-type=none&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在主程序中设置配置项，表示web不启用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
public class CommandLineApplication {

	public static void main(String[] args) {
		new SpringApplicationBuilder(CommandLineApplication.class)
				.web(WebApplicationType.NONE)
				.run(args);
		// 根据 application.properties 里的配置来决定 WebApplicationType
//		SpringApplication.run(CommandLineApplication.class, args);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;设置3个执行的主方法根据执行顺序
    &lt;ol&gt;
      &lt;li&gt;Foo&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
@Order(1)
@Slf4j
public class FooCommandLineRunner implements CommandLineRunner {
  @Override
  public void run(String... args) throws Exception {
      log.info(&quot;Foo&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Bar&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
@Order(2)
@Slf4j
public class BarApplicationRunner implements ApplicationRunner {
  @Override
  public void run(ApplicationArguments args) throws Exception {
      log.info(&quot;Bar&quot;);
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;获得 ApplicationContextAware 取得 applicationContext 在将其传入 SpringApplication其实就是能获得返回码&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
@Order(3)
@Slf4j
public class ExitApplicationRunner implements ApplicationRunner, ApplicationContextAware {
  private ApplicationContext applicationContext;//获取

  @Override
  public void run(ApplicationArguments args) throws Exception {
    int code = SpringApplication.exit(applicationContext);
    log.info(&quot;Exit with {}.&quot;, code);//打印返回码 后面扩展 传入 exit值
    System.exit(code);
  }

  @Override
  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    this.applicationContext = applicationContext;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;返回码的Generator&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
public class MyExitCodeGenerator implements ExitCodeGenerator {
  @Override
  public int getExitCode() {
      return 1;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;可执行jar包&quot;&gt;可执行jar包&lt;/h2&gt;

&lt;h3 id=&quot;认识可执-jar&quot;&gt;认识可执⾏ Jar&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;包含
    &lt;ul&gt;
      &lt;li&gt;Jar 描述，META-INF/MANIFEST.MF&lt;/li&gt;
      &lt;li&gt;Spring Boot Loader，org/springframework/boot/loader&lt;/li&gt;
      &lt;li&gt;项⽬目内容，BOOT-INF/classes&lt;/li&gt;
      &lt;li&gt;项目依赖，BOOT-INF/lib&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不包含
    &lt;ul&gt;
      &lt;li&gt;JDK / JRE&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何找到程序的口&quot;&gt;如何找到程序的⼊口&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Jar 的启动类
    &lt;ul&gt;
      &lt;li&gt;MANIFEST.MF
        &lt;ul&gt;
          &lt;li&gt;Main-Class: org.springframework.boot.loader.JarLauncher&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;项目的主类
    &lt;ul&gt;
      &lt;li&gt;@SpringApplication&lt;/li&gt;
      &lt;li&gt;MANIFEST.MF
        &lt;ul&gt;
          &lt;li&gt;Start-Class: xxx.yyy.zzz&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何直接创建可执行的jar&quot;&gt;如何直接创建可执行的jar&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;executable&amp;gt;true&amp;lt;/executable&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;打包后的 Jar 可直接运行，无需 java 命令  运行方式就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./ jar包名&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可以在 .conf 的同名⽂件中配置参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;config中的可执行参数&quot;&gt;config中的可执行参数&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;配置项&lt;/td&gt;
      &lt;td&gt;说明&lt;/td&gt;
      &lt;td&gt;备注&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CONF_FOLDER&lt;/td&gt;
      &lt;td&gt;放置 .conf 的⽬录位置&lt;/td&gt;
      &lt;td&gt;只能放环境变量量中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JAVA_OPTS&lt;/td&gt;
      &lt;td&gt;JVM 启动时的参数&lt;/td&gt;
      &lt;td&gt;比如 JVM 的内存和 GC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RUN_ARGS&lt;/td&gt;
      &lt;td&gt;传给程序执⾏的参数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;案例-jar-demo&quot;&gt;案例 jar-demo&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进入到 jar-demo的文件夹下执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn clean package -Dmaven.test.skip=true&lt;/code&gt;开始打包
[INFO] Scanning for projects…
[INFO]
[INFO] ————-&amp;lt; geektime.spring.springbucks:waiter-service &amp;gt;————-
[INFO] Building waiter-service 0.0.1-SNAPSHOT
[INFO] ——————————–[ jar ]———————————
…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;之后进入到target目录中解码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd target/
unzip -l waiter-service-0.0.1-SNAPSHOT.jar
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看到jar包内容其中包含 META-INF/MANIFEST.MF这个文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;之后进入到 META-INF/MANIFEST.MF文件中获得 基本信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unzip -p waiter-service-0.0.1-SNAPSHOT.jar META-INF/MANIFEST.MF&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;warning [waiter-service-0.0.1-SNAPSHOT.jar]:  8692 extra bytes at beginning or within zipfile
  (attempting to process anyway)
Manifest-Version: 1.0
Implementation-Title: waiter-service
Implementation-Version: 0.0.1-SNAPSHOT
Built-By: apple
Implementation-Vendor-Id: geektime.spring.springbucks
Spring-Boot-Version: 2.1.3.RELEASE
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: geektime.spring.springbucks.waiter.WaiterServiceApplicati
 on
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Created-By: Apache Maven 3.6.3
Build-Jdk: 1.8.0_181
Implementation-URL: https://projects.spring.io/spring-boot/#/spring-bo
 ot-starter-parent/waiter-service
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示是谁写的，jdk版本，Main-Class，Start-Class等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unzip 的使用 -l 显示压缩文件内所包含的文件。-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将这个jar包赋值到外面
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp -f waiter-service-0.0.1-SNAPSHOT.jar ../waiter-service.jar&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同一个目录下准备了一个waiter-service.conf文件用来配置 JVM 的参数
文件中的内容是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JAVA_OPTS=&quot;-Xmx1024m -Xms1024m -Xmn384m&quot;&lt;/code&gt; 查看 这个config文件的命令行是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat waiter-service.conf&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;执行已经打包好的jar文件 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./waiter-service.jar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看是否按照conf配置jvm参数
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps xu| grep java&lt;/code&gt;可以看到 刚刚运行的java&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;apple 56271   0.0  5.8  6921632 486412 s003  S+    1:58下午   0:41.47 /usr/bin/java -Dsun.misc.URLClassPath.disableJarChecking=true -Xmx1024m -Xms1024m -Xmn384m -jar /Users/apple/Downloads/spring全家桶/geektime-spring-family/Chapter 10/jar-demo/waiter-service.jar
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;spring-boot-打包成docker镜像&quot;&gt;Spring boot 打包成Docker镜像&lt;/h2&gt;

&lt;h3 id=&quot;什么是docker镜像&quot;&gt;什么是Docker镜像&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;镜像是静态的只读模板&lt;/li&gt;
  &lt;li&gt;镜像中包含构建 Docker 容器的指令&lt;/li&gt;
  &lt;li&gt;镜像是分层的&lt;/li&gt;
  &lt;li&gt;通过 Dockerfile 来创建镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;指令&lt;/td&gt;
      &lt;td&gt;作⽤&lt;/td&gt;
      &lt;td&gt;格式举例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FROM&lt;/td&gt;
      &lt;td&gt;基于哪个镜像&lt;/td&gt;
      &lt;td&gt;FROM /&lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]&lt;/name&gt;&lt;/tag&gt;&lt;/image&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LABEL&lt;/td&gt;
      &lt;td&gt;设置标签&lt;/td&gt;
      &lt;td&gt;LABEL maintainer=“Geektime”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RUN&lt;/td&gt;
      &lt;td&gt;运行安装命令&lt;/td&gt;
      &lt;td&gt;RUN [“executable”, “param1”, “param2”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CMD&lt;/td&gt;
      &lt;td&gt;容器启动时的命令&lt;/td&gt;
      &lt;td&gt;CMD [“executable”,”param1”,”param2”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ENTRYPOINT&lt;/td&gt;
      &lt;td&gt;容器启动后的命令&lt;/td&gt;
      &lt;td&gt;ENTRYPOINT [“executable”, “param1”, “param2”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VOLUME&lt;/td&gt;
      &lt;td&gt;挂载目录&lt;/td&gt;
      &lt;td&gt;VOLUME [“/data”]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EXPOSE&lt;/td&gt;
      &lt;td&gt;容器要监听的端⼝&lt;/td&gt;
      &lt;td&gt;EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]&lt;/protocol&gt;&lt;/port&gt;&lt;/port&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ENV&lt;/td&gt;
      &lt;td&gt;设置环境变量&lt;/td&gt;
      &lt;td&gt;ENV &lt;key&gt; &lt;value&gt;&lt;/value&gt;&lt;/key&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ADD&lt;/td&gt;
      &lt;td&gt;添加⽂件&lt;/td&gt;
      &lt;td&gt;ADD [–chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;&lt;/dest&gt;&lt;/src&gt;&lt;/group&gt;&lt;/user&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WORKDIR&lt;/td&gt;
      &lt;td&gt;设置运行的⼯作⽬录&lt;/td&gt;
      &lt;td&gt;WORKDIR /path/to/workdir&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;USER&lt;/td&gt;
      &lt;td&gt;设置运行的⽤户&lt;/td&gt;
      &lt;td&gt;USER &lt;user&gt;[:&lt;group&gt;]&lt;/group&gt;&lt;/user&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;maven来构建docker&quot;&gt;maven来构建Docker&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;准备⼯作
    &lt;ul&gt;
      &lt;li&gt;提供⼀个 Dockerfile&lt;/li&gt;
      &lt;li&gt;配置 dockerfile-maven-plugin 插件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;执行构建
    &lt;ul&gt;
      &lt;li&gt;mvn package&lt;/li&gt;
      &lt;li&gt;mvn dockerfile:build&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;检查结果
    &lt;ul&gt;
      &lt;li&gt;docker images&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;案例-1&quot;&gt;案例&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;properties&amp;gt;
  &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
  &amp;lt;docker.image.prefix&amp;gt;springbucks&amp;lt;/docker.image.prefix&amp;gt;
&amp;lt;/properties&amp;gt;

...

&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;com.spotify&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;dockerfile-maven-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.4.10&amp;lt;/version&amp;gt;
  &amp;lt;executions&amp;gt;
    &amp;lt;execution&amp;gt;
      &amp;lt;id&amp;gt;default&amp;lt;/id&amp;gt;
      &amp;lt;goals&amp;gt;
        &amp;lt;goal&amp;gt;build&amp;lt;/goal&amp;gt;
        &amp;lt;goal&amp;gt;push&amp;lt;/goal&amp;gt;
      &amp;lt;/goals&amp;gt;
    &amp;lt;/execution&amp;gt;
  &amp;lt;/executions&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;repository&amp;gt;${docker.image.prefix}/${project.artifactId}&amp;lt;/repository&amp;gt;
    &amp;lt;tag&amp;gt;${project.version}&amp;lt;/tag&amp;gt;
    &amp;lt;buildArgs&amp;gt;
      &amp;lt;JAR_FILE&amp;gt;${project.build.finalName}.jar&amp;lt;/JAR_FILE&amp;gt;
    &amp;lt;/buildArgs&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;pom文件同目录下写入Docker文件 
其中Docker文件如下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;FROM java:8
EXPOSE 8080
ARG JAR_FILE
ADD target/${JAR_FILE} /waiter-service.jar
ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;/waiter-service.jar&quot;]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;镜像是基于java8构建、端口是8080、将target文件夹下的jar文件放到 /waiter-service.jar这个文件下 ，在程序运行的时候就是执行 java -jar /waiter-service.jar这样来执行的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进入到pom文件所在目录 开始利用maven打包&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn clean package -Dmaven.test.skip=true&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;经过漫长时间的打包终于能看到镜像了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 09 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/09/Spring04/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/09/Spring04/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记03 访问Web资源和Web开发进阶 </title>
        <description>&lt;h1 id=&quot;chapter-6-访问web资源&quot;&gt;Chapter 6 访问Web资源&lt;/h1&gt;

&lt;h2 id=&quot;通过-resttemplate-访问-web-资源&quot;&gt;通过 RestTemplate 访问 Web 资源&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Boot 中的 RestTemplate
    &lt;ul&gt;
      &lt;li&gt;Spring Boot 中没有⾃自动配置 RestTemplate&lt;/li&gt;
      &lt;li&gt;Spring Boot 提供了了 RestTemplateBuilder
        &lt;ul&gt;
          &lt;li&gt;RestTemplateBuilder.build()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用方法
    &lt;ul&gt;
      &lt;li&gt;GET 请求  getForObject() / getForEntity()&lt;/li&gt;
      &lt;li&gt;POST 请求 postForObject() / postForEntity() PUT 请求&lt;/li&gt;
      &lt;li&gt;PUT 请求 put()&lt;/li&gt;
      &lt;li&gt;DELETE 请求 delete()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;构造URI
    &lt;ul&gt;
      &lt;li&gt;构造 URI： UriComponentsBuilder&lt;/li&gt;
      &lt;li&gt;构造相对于当前请求的 URI： ServletUriComponentsBuilder&lt;/li&gt;
      &lt;li&gt;构造指向 Controller 的 URI：MvcUriComponentsBuilder
simple-restTemplate-demo示例&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resttemplate-的高阶用法&quot;&gt;RestTemplate 的高阶用法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;传递 HTTP Header在requestEntity中传入响应头
    &lt;ul&gt;
      &lt;li&gt;RestTemplate.exchange()&lt;/li&gt;
      &lt;li&gt;RequestEntity&lt;T&gt; / ResponseEntity&lt;T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类型转化
    &lt;ul&gt;
      &lt;li&gt;JsonSerializer / JsonDeserializer 序列化和反序列化&lt;/li&gt;
      &lt;li&gt;@JsonComponent&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解析泛型队形
    &lt;ul&gt;
      &lt;li&gt;RestTemplate.exchange()&lt;/li&gt;
      &lt;li&gt;ParameterizedTypeReference&lt;T&gt;
以上内容的具体实现是complex-resttemplate-demo&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;getForObject–发送GET请求，将HTTP response转换成一个指定的object对象&lt;/strong&gt;
&lt;strong&gt;postForEntity – 发送POST请求，将给定的对象封装到HTTP请求体，返回类型是一个HttpEntity对象&lt;/strong&gt;
&lt;strong&gt;每个HTTP方法对应的RestTemplate方法都有3种。其中2种的url参数为字符串，URI参数变量分别是Object数组和Map，第3种使用URI类型作为参数exchange 和execute 方法比上面列出的其它方法（如getForObject、postForEntity等）使用范围更广，允许调用者指定HTTP请求的方法（GET、POST、PUT等），并且可以支持像HTTP PATCH（部分更新)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在RestTemplate.exchange中的参数&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;url: 请求地址；&lt;/li&gt;
  &lt;li&gt;method: 请求类型(如：POST,PUT,DELETE,GET)；&lt;/li&gt;
  &lt;li&gt;requestEntity: 请求实体，封装请求头，请求内容&lt;/li&gt;
  &lt;li&gt;responseType: 响应类型，根据服务接口的返回类型决定&lt;/li&gt;
  &lt;li&gt;uriVariables: url中参数变量值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;以上的参数可以采用单独requestEntity和 responseType两个合起来实现的方式&lt;/strong&gt;
    &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coffeeUri, HttpMethod.GET, null, ptr&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;req, String.class&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;简单定制resttemplate-advanced-resttemplate-demo&quot;&gt;简单定制RestTemplate （advanced-resttemplate-demo）&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;RestTemplate ⽀支持的 HTTP 库
    &lt;ul&gt;
      &lt;li&gt;默认实现：SimpleClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;通用接口：ClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;Apache HttpComponents：HttpComponentsClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;Netty: Netty4ClientHttpRequestFactory&lt;/li&gt;
      &lt;li&gt;OkHttp: OkHttp3ClientHttpRequestFactory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定制主要是在做什么
    &lt;ul&gt;
      &lt;li&gt;连接管理
        &lt;ul&gt;
          &lt;li&gt;PoolingHttpClientConnectionManager&lt;/li&gt;
          &lt;li&gt;KeepAlive 策略&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;超时设定&lt;strong&gt;不能无限制等待&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;connectTimeout / readTimeout&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SSL校验
        &lt;ul&gt;
          &lt;li&gt;证书检查策略&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;4.5.7&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ConnectionKeepAliveStrategy来源于此&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在工具类中实现对最长存活时间的注解&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class CustomConnectionKeepAliveStrategy implements ConnectionKeepAliveStrategy {
  private final long DEFAULT_SECONDS = 30;
  @Override
  public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) {
    return Arrays.asList(httpResponse.getHeaders(HTTP.CONN_KEEP_ALIVE))
    .stream()
    .filter(h -&amp;gt; StringUtils.equalsIgnoreCase(h.getName(), &quot;timeout&quot;)
    &amp;amp;&amp;amp; StringUtils.isNumeric(h.getValue()))
    .findFirst()
    .map(h -&amp;gt; NumberUtils.toLong(h.getValue(), DEFAULT_SECONDS))
    .orElse(DEFAULT_SECONDS) * 1000;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用stream方法对上下文做出修改，获取HttpResponse的keepLive的响应头，对timeout这个属性，如果这个属性的parameter的属性是数字就取出来，转换为Long类型，如果转换失败就是用默认值来代替，复杂化的写法详见&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;../.m2/repository/org/apache/httpcomponents/httpclient/4.5.7/httpclient-4.5.7.jar!/org/apache/http/impl/client/DefaultConnectionKeepAliveStrategy.class&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在主程序中模拟web来访问资源&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
@Slf4j
public class CustomerServiceApplication implements ApplicationRunner {
	@Autowired
	private RestTemplate restTemplate;

	public static void main(String[] args) {
		new SpringApplicationBuilder()//构建运行池 不启动 Tomcat
				.sources(CustomerServiceApplication.class)
				.bannerMode(Banner.Mode.OFF)
				.web(WebApplicationType.NONE)
				.run(args);
	}
  ...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码意思是使用restTemplate，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.web(WebApplicationType.NONE)&lt;/code&gt;表示不默认启动一个服务器，因为启动web服务的同时会启动Tomcat，这个操作就是将其关闭。&lt;/p&gt;

&lt;p&gt;以下代码接上面代码&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public HttpComponentsClientHttpRequestFactory requestFactory() {//配置连接池
  PoolingHttpClientConnectionManager connectionManager =
      new PoolingHttpClientConnectionManager(30, TimeUnit.SECONDS);
  connectionManager.setMaxTotal(200);//最大连接数
  connectionManager.setDefaultMaxPerRoute(20);

  CloseableHttpClient httpClient = HttpClients.custom()//定制 HttpClient
      .setConnectionManager(connectionManager)//connectionManager 来自前面设置的
      .evictIdleConnections(30, TimeUnit.SECONDS)
      .disableAutomaticRetries()//不希望自动重试 比如打款操作 HttpClient 是为了模仿网页中的请求设计的
      // 有 Keep-Alive 认里面的值，没有的话永久有效
      //.setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE)
      // 换成自定义的
      .setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())
      .build();

  HttpComponentsClientHttpRequestFactory requestFactory =//利用HttpClient创建了requestFactory
      new HttpComponentsClientHttpRequestFactory(httpClient);

  return requestFactory;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码的作用是设置连接池，定制HttpClient，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.disableAutomaticRetries()&lt;/code&gt; 不希望自动重试 比如打款操作 HttpClient 是为了模仿网页中的请求设计,如果自动重试有些操作会发生错误；修改默认的KeepLive时间&lt;/p&gt;

&lt;p&gt;以下代码接上面代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	@Bean
	public RestTemplate restTemplate(RestTemplateBuilder builder) {
//		return new RestTemplate();

		return builder
      .setConnectTimeout(Duration.ofMillis(100))//连接超时100毫秒
      .setReadTimeout(Duration.ofMillis(500))
      .requestFactory(this::requestFactory)
      .build();
	}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码的意思是设置连接超时时间100毫秒，readTimeout是500毫秒，传入requestFactory&lt;strong&gt;java8中使用::来访问类的构造方法，对象方法，静态方法&lt;a href=&quot;https://blog.csdn.net/kegaofei/article/details/80582356&quot; target=&quot;_blank&quot;&gt;::java8详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下代码接上面&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  URI uri = UriComponentsBuilder
      .fromUriString(&quot;http://localhost:8080/coffee/?name={name}&quot;)
      .build(&quot;mocha&quot;);
  RequestEntity&amp;lt;Void&amp;gt; req = RequestEntity.get(uri)
      .accept(MediaType.APPLICATION_XML)
      .build();
  ResponseEntity&amp;lt;String&amp;gt; resp = restTemplate.exchange(req, String.class);
  log.info(&quot;Response Status: {}, Response Headers: {}&quot;, resp.getStatusCode(), resp.getHeaders().toString());
  log.info(&quot;Coffee: {}&quot;, resp.getBody());
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码的意思是UriComponentsBuilder建立一个根据name查找coffee的请求了，使用的是GET方法，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestEntity&amp;lt;Void&amp;gt;&lt;/code&gt;是在GET请求的情况下才是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Void&lt;/code&gt;如果是POST就不能为空，通过构造&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestEntity&lt;/code&gt;并且显示返回值也就是accept头是xml类型穿件请求，之后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restTemplate.exchange&lt;/code&gt;获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ResponseEntity&lt;/code&gt;返货的响应体是String类型的&lt;/p&gt;

&lt;p&gt;对于返回的是List类型的响应体如一次性要返回所有的Coffee对象需要使用专门的包装&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParameterizedTypeReference&lt;/code&gt;详细代码如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;String coffeeUri = &quot;http://localhost:8080/coffee/&quot;;
Coffee request = Coffee.builder()
    .name(&quot;Americano&quot;)
    .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.00))
    .build();
Coffee response = restTemplate.postForObject(coffeeUri, request, Coffee.class);
log.info(&quot;New Coffee: {}&quot;, response);

ParameterizedTypeReference&amp;lt;List&amp;lt;Coffee&amp;gt;&amp;gt; ptr =
    new ParameterizedTypeReference&amp;lt;List&amp;lt;Coffee&amp;gt;&amp;gt;() {};
ResponseEntity&amp;lt;List&amp;lt;Coffee&amp;gt;&amp;gt; list = restTemplate
    .exchange(coffeeUri, HttpMethod.GET, null, ptr);
list.getBody().forEach(c -&amp;gt; log.info(&quot;Coffee: {}&quot;, c));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;通过webclient访问web资源&quot;&gt;通过WebClient访问Web资源&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;WebClient:⼀个以 Reactive ⽅方式处理理 HTTP 请求的非阻塞式的客户端，在RestTemplate 中能够实现的也能在WebClient中实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持的底层 HTTP 库&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Reactor Netty - ReactorClientHttpConnector&lt;/li&gt;
      &lt;li&gt;Jetty ReactiveStream HttpClient - JettyClientHttpConnector&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;创建WebClient库
    &lt;ul&gt;
      &lt;li&gt;WebClient.create()&lt;/li&gt;
      &lt;li&gt;WebClient.builder()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发起请求
    &lt;ul&gt;
      &lt;li&gt;get() / post() / put() / delete() / patch()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;获得结果
    &lt;ul&gt;
      &lt;li&gt;retrieve() / exchange()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理理 HTTP Status
    &lt;ul&gt;
      &lt;li&gt;onStatus()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;应答正⽂
    &lt;ul&gt;
      &lt;li&gt;bodyToMono() / bodyToFlux()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;导入pom文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;主程序&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public WebClient webClient(WebClient.Builder builder) {
  return builder.baseUrl(&quot;http://localhost:8080&quot;).build();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上是为了注册一个端口&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;具体在主程序中的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  CountDownLatch cdl = new CountDownLatch(2);

  webClient.get()
    .uri(&quot;/coffee/{id}&quot;, 1)
    .accept(MediaType.APPLICATION_JSON_UTF8)
    .retrieve()//获得结果 类似于exchange
    .bodyToMono(Coffee.class)//转换为Mono型对象Mone&amp;lt;Coffee&amp;gt;
    .doOnError(t -&amp;gt; log.error(&quot;Error: &quot;, t))
    .doFinally(s -&amp;gt; cdl.countDown())//主线程等待异步线程处理
    .subscribeOn(Schedulers.single())
    .subscribe(c -&amp;gt; log.info(&quot;Coffee 1: {}&quot;, c));

  Mono&amp;lt;Coffee&amp;gt; americano = Mono.just(
      Coffee.builder()
        .name(&quot;americano&quot;)
        .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.00))
        .build()
  );
  webClient.post()
    .uri(&quot;/coffee/&quot;)
    .body(americano, Coffee.class)//post请求构造的正文就是之前Mono
    .retrieve()
    .bodyToMono(Coffee.class)
    .doFinally(s -&amp;gt; cdl.countDown())
    .subscribeOn(Schedulers.single())
    .subscribe(c -&amp;gt; log.info(&quot;Coffee Created: {}&quot;, c));

  cdl.await();

  webClient.get()
    .uri(&quot;/coffee/&quot;)
    .retrieve()
    .bodyToFlux(Coffee.class)//返回的是List类型 Flux表示多个对象 获得Flux&amp;lt;Coffee&amp;gt;
    .toStream()// Stream&amp;lt;Coffee&amp;gt;
    .forEach(c -&amp;gt; log.info(&quot;Coffee in List: {}&quot;, c));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码释义：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt;是一个计数器,作用大致就是数量达到了某个点之后计数结束，才能继续往下走。可以用作流程控制之类的作用。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;countDown.await()&lt;/code&gt;代表需要在countDown计数完成之后才执行其后的代码，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;countDown.countDown()&lt;/code&gt;方法执行表示计数器加1，直到计数器中数字符合预设的数字之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await()&lt;/code&gt;方法才不会阻塞。&lt;/li&gt;
  &lt;li&gt;subscribeOn常见用法见02中subscribeOn详细信息的连接。&lt;/li&gt;
  &lt;li&gt;以上代码表示get一个请求，post一个请求，这两个的顺序是可变的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;WebClient使用场景：如果你用WebFlux，那请求处理过程中需要访问其他HTTP服务就可以用WebClient。再通用一点，你希望通过异步线程来访问HTTP时，就可以考虑用WebClient。Reactor可以简化你的多线程代码。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;chapter-7-web开发进阶&quot;&gt;Chapter 7 Web开发进阶&lt;/h1&gt;

&lt;h2 id=&quot;设计好的-restful-web-service&quot;&gt;设计好的 RESTful Web Service&lt;/h2&gt;

&lt;h3 id=&quot;识别资源&quot;&gt;识别资源&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;找到领域名词
    &lt;ul&gt;
      &lt;li&gt;能⽤ CRUD 操作的名词eg.Coffee&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将资源组织为集合(即集合资源)eg.Order&lt;/li&gt;
  &lt;li&gt;将资源合并为复合资源eg.CoffeeOrder&lt;/li&gt;
  &lt;li&gt;计算或处理理函数
    &lt;h3 id=&quot;选择合适的资源粒度&quot;&gt;选择合适的资源粒度&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;站在服务端的⻆角度，要考虑
    &lt;ul&gt;
      &lt;li&gt;⽹络效率&lt;/li&gt;
      &lt;li&gt;表述的多少：一次网络交互中处理多少东西&lt;/li&gt;
      &lt;li&gt;客户端的易用程度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;站在客户端的⻆角度，要考虑
    &lt;ul&gt;
      &lt;li&gt;可缓存性&lt;/li&gt;
      &lt;li&gt;修改频率：客户端多久变一次&lt;/li&gt;
      &lt;li&gt;可变性：eg.用户注册时间不会变&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设计-uri&quot;&gt;设计 URI&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用域及子域对资源进行合理的分组或划分&lt;/li&gt;
  &lt;li&gt;在 URI 的路径部分使⽤斜杠分隔符 ( / ) 来表示资源之间的层次关系&lt;/li&gt;
  &lt;li&gt;在 URI 的路径部分使⽤逗号 ( , ) 和分号 ( ; ) 来表示⾮层次元素，并不是所有库都支持&lt;/li&gt;
  &lt;li&gt;使用连字符 ( - ) 和下划线 ( _ ) 来改善⻓路径中名称的可读性&lt;/li&gt;
  &lt;li&gt;在 URI 的查询部分使⽤用“与”符号 ( &amp;amp; ) 来分隔参数，queryString&lt;/li&gt;
  &lt;li&gt;在 URI 中避免出现文件扩展名 ( 例例如 .php，.aspx 和 .jsp )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;选择合适的-http-法和返回码&quot;&gt;选择合适的 HTTP ⽅法和返回码&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;认识Http方法
&lt;img src=&quot;/img/jave-spring/chapter7-restful.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安全：不会改变资源内容
幂等：不管请求多少次，结果都是一样的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;URI 和Http结合的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/jave-spring/chapter7-restful-uri.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Http状态码
&lt;img src=&quot;/img/jave-spring/chapter7-httpstatuscode.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设计资源的表述json-xml-html&quot;&gt;设计资源的表述(json xml html)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JSON
    &lt;ul&gt;
      &lt;li&gt;MappingJackson2HttpMessageConverter&lt;/li&gt;
      &lt;li&gt;GsonHttpMessageConverter&lt;/li&gt;
      &lt;li&gt;JsonbHttpMessageConverter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;XML
    &lt;ul&gt;
      &lt;li&gt;MappingJackson2XmlHttpMessageConverter&lt;/li&gt;
      &lt;li&gt;Jaxb2RootElementHttpMessageConverter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;ProtoBuf
    &lt;ul&gt;
      &lt;li&gt;ProtobufHttpMessageConverter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hateoas&quot;&gt;HATEOAS&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Richardson 成熟度模型
    &lt;ul&gt;
      &lt;li&gt;Level 3 - Hypermedia Controls&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HATEOAS
    &lt;ul&gt;
      &lt;li&gt;Hybermedia As The Engine Of Application State&lt;/li&gt;
      &lt;li&gt;REST 统⼀接口的必要组成部分&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hateoas-vs-wsdl&quot;&gt;HATEOAS v.s. WSDL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HATEOAS
    &lt;ul&gt;
      &lt;li&gt;表述中的超链接会提供服务所需的各种 REST 接口信息&lt;/li&gt;
      &lt;li&gt;无需事先约定如何访问服务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;传统的服务契约
    &lt;ul&gt;
      &lt;li&gt;必须事先约定服务的地址与格式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用超链接类型&quot;&gt;常用超链接类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/jave-spring/chapter7-hyper-type.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使-spring-data-rest-实现简单的超媒体服务&quot;&gt;使⽤ Spring Data REST 实现简单的超媒体服务&lt;/h2&gt;

&lt;h3 id=&quot;认识halhypertext-application-language&quot;&gt;认识HAL(Hypertext Application Language)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HAL 是⼀种简单的json格式，为 API 中的资源提供简单一致的链接&lt;/li&gt;
  &lt;li&gt;HAL 模型
    &lt;ul&gt;
      &lt;li&gt;链接&lt;/li&gt;
      &lt;li&gt;内嵌资源&lt;/li&gt;
      &lt;li&gt;状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-data-rest&quot;&gt;Spring Data REST&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Boot 依赖
    &lt;ul&gt;
      &lt;li&gt;spring-boot-starter-data-rest&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用注解与类
    &lt;ul&gt;
      &lt;li&gt;@RepositoryRestResource&lt;/li&gt;
      &lt;li&gt;Resource&lt;T&gt;&lt;/T&gt;&lt;/li&gt;
      &lt;li&gt;PagedResource&lt;T&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案例-chapter-8hateoas-waiter-service&quot;&gt;案例 Chapter 8/hateoas-waiter-service&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;启动服务之后可以通过超媒体的方式对内容进行查询
pom文件导入jpa和data rest&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-rest&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;启动服务之后用客户端访问服务-案例-chapter-8hateoas-customer-service&quot;&gt;启动服务之后用客户端访问服务 案例 Chapter 8/hateoas-customer-service&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;配置 Jackson JSON
    &lt;ul&gt;
      &lt;li&gt;注册 HAL 支持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;操作超链接
    &lt;ul&gt;
      &lt;li&gt;找到需要的 Link&lt;/li&gt;
      &lt;li&gt;访问超链接 restTemplate 或者 WebClient(不同link的POST, GET等)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;pom文件 导入web 和 data rest&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-rest&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Runner文件中这里的实现完全可以通过Postman自己操作&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private static final URI ROOT_URI = URI.create(&quot;http://localhost:8080/&quot;);
...

private Link getLink(URI uri, String rel) {
  ResponseEntity&amp;lt;Resources&amp;lt;Link&amp;gt;&amp;gt; rootResp = restTemplate.exchange(uri,
    HttpMethod.GET, 
    null,
    new ParameterizedTypeReference&amp;lt;Resources&amp;lt;Link&amp;gt;&amp;gt;() {});
  Link link = rootResp.getBody().getLink(rel);
  log.info(&quot;Link: {}&quot;, link);
  return link;
}

private void readCoffeeMenu(Link coffeeLink) {
  ResponseEntity&amp;lt;PagedResources&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt;&amp;gt; coffeeResp = restTemplate.exchange(coffeeLink.getTemplate().expand(),
    HttpMethod.GET, 
    null,
    new ParameterizedTypeReference&amp;lt;PagedResources&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt;&amp;gt;() {});
  log.info(&quot;Menu Response: {}&quot;, coffeeResp.getBody());
}

private Resource&amp;lt;Coffee&amp;gt; addCoffee(Link link) {
  Coffee americano = Coffee.builder()
          .name(&quot;americano&quot;)
          .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.0))
          .build();
  RequestEntity&amp;lt;Coffee&amp;gt; req =
          RequestEntity.post(link.getTemplate().expand()).body(americano);
  ResponseEntity&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt; resp =
          restTemplate.exchange(req,
                  new ParameterizedTypeReference&amp;lt;Resource&amp;lt;Coffee&amp;gt;&amp;gt;() {});
  log.info(&quot;add Coffee Response: {}&quot;, resp);
  return resp.getBody();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;getLink 方法是发起一个Get请求，返回是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resources&amp;lt;Link&amp;gt;&lt;/code&gt;类型的，在通过getBody再去做getLink操作获得，假设原来的rel是coffees就会获得rel的link&lt;/li&gt;
  &lt;li&gt;readCoffeeMenu返回的是带有分页信息的Resources，每个内嵌的信息都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resource&amp;lt;Coffee&amp;gt;&lt;/code&gt;之后在拿这个信息做addCoffee&lt;/li&gt;
  &lt;li&gt;addCoffee传入添加coffee的link&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;添加订单&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private void addOrder(Link link, Resource&amp;lt;Coffee&amp;gt; coffee) {
  CoffeeOrder newOrder = CoffeeOrder.builder()
          .customer(&quot;Li Lei&quot;)
          .state(OrderState.INIT)
          .build();
  RequestEntity&amp;lt;?&amp;gt; req =
          RequestEntity.post(link.getTemplate().expand()).body(newOrder);
  ResponseEntity&amp;lt;Resource&amp;lt;CoffeeOrder&amp;gt;&amp;gt; resp =
          restTemplate.exchange(req,
                  new ParameterizedTypeReference&amp;lt;Resource&amp;lt;CoffeeOrder&amp;gt;&amp;gt;() {});
  log.info(&quot;add Order Response: {}&quot;, resp);

  Resource&amp;lt;CoffeeOrder&amp;gt; order = resp.getBody();
  Link items = order.getLink(&quot;items&quot;);
  req = RequestEntity.post(items.getTemplate().expand()).body(coffee.getLink(&quot;self&quot;));
  ResponseEntity&amp;lt;String&amp;gt; itemResp = restTemplate.exchange(req, String.class);
  log.info(&quot;add Order Items Response: {}&quot;, itemResp);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码addOrder使用先构造了一个coffeeOrder的对象，并将刚刚创建的coffeeOrder传入到由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestEntity.post&lt;/code&gt;的URI中，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restTemplate.exchange&lt;/code&gt;，通过对coffeeOrder中的items链接做post，传入的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resource&amp;lt;Coffee&amp;gt;&lt;/code&gt;表示的是取得原先的创建的coffee的链接(&lt;strong&gt;这里还是不太明白，详见62&lt;/strong&gt;)。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用String作为返回值类型查询到创建的订单中有多少coffee订单&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private void queryOrders(Link link) {
  ResponseEntity&amp;lt;String&amp;gt; resp = restTemplate.getForEntity(link.getTemplate().expand(), String.class);
  log.info(&quot;query Order Response: {}&quot;, resp);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;run中的主逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void run(ApplicationArguments args) throws Exception {
  Link coffeeLink = getLink(ROOT_URI,&quot;coffees&quot;);
  readCoffeeMenu(coffeeLink);
  Resource&amp;lt;Coffee&amp;gt; americano = addCoffee(coffeeLink);

  Link orderLink = getLink(ROOT_URI, &quot;coffeeOrders&quot;);
  addOrder(orderLink, americano);
  queryOrders(orderLink);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;分布式环境中解决session&quot;&gt;分布式环境中解决Session&lt;/h2&gt;

&lt;h3 id=&quot;常见的会话解决方案&quot;&gt;常见的会话解决方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;粘性会话 Sticky Session&lt;/li&gt;
  &lt;li&gt;会话复制 Session Replication&lt;/li&gt;
  &lt;li&gt;集中会话 Centralized Session
前两种不推荐，第三中使用redis集中存储&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;认识-spring-session&quot;&gt;认识 Spring Session&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Session
    &lt;ul&gt;
      &lt;li&gt;简化集群中的⽤户会话管理&lt;/li&gt;
      &lt;li&gt;⽆需绑定容器特定解决⽅案&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;支持的存储
    &lt;ul&gt;
      &lt;li&gt;Redis&lt;/li&gt;
      &lt;li&gt;MongoDB&lt;/li&gt;
      &lt;li&gt;JDBC&lt;/li&gt;
      &lt;li&gt;Hazelcast&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;定制 HttpSession&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过定制的 HttpServletRequest 返回定制的 HttpSession(屏蔽后端差异)
    &lt;ul&gt;
      &lt;li&gt;SessionRepositoryRequestWrapper&lt;/li&gt;
      &lt;li&gt;SessionRepositoryFilter&lt;/li&gt;
      &lt;li&gt;DelegatingFilterProxy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于-redis-的-httpsession&quot;&gt;基于 Redis 的 HttpSession&lt;/h3&gt;
&lt;p&gt;引⼊入依赖&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;spring-session-data-redis
基本配置&lt;/li&gt;
  &lt;li&gt;@EnableRedisHttpSession&lt;/li&gt;
  &lt;li&gt;提供 RedisConnectionFactory&lt;/li&gt;
  &lt;li&gt;实现 AbstractHttpSessionApplicationInitializer
    &lt;ul&gt;
      &lt;li&gt;配置 DelegatingFilterProxy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;spring-boot-对-spring-session-的支持&quot;&gt;Spring Boot 对 Spring Session 的支持&lt;/h3&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;spring.session.store-type=redis&lt;/li&gt;
  &lt;li&gt;spring.session.timeout=
    &lt;ul&gt;
      &lt;li&gt;server.servlet.session.timeout=&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;spring.session.redis.flush-mode=on-save&lt;/li&gt;
  &lt;li&gt;spring.session.redis.namespace=spring:session&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实例&quot;&gt;实例&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-session-core&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;启动redis&lt;/li&gt;
  &lt;li&gt;带有相同SessionId的内容能显示相同属性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;使用webflux代替springmvc&quot;&gt;使用WebFlux代替SpringMVC&lt;/h2&gt;

&lt;h3 id=&quot;什么是-webflux&quot;&gt;什么是 WebFlux&lt;/h3&gt;
&lt;p&gt;⽤用于构建基于 Reactive 技术栈之上的 Web 应⽤用程序
基于 Reactive Streams API ，运⾏行行在⾮非阻塞服务器器上&lt;/p&gt;

&lt;h3 id=&quot;为什么会有-webflux&quot;&gt;为什么会有 WebFlux&lt;/h3&gt;
&lt;p&gt;对于⾮阻塞 Web 应用的需要 
函数式编程&lt;/p&gt;

&lt;h3 id=&quot;关于-webflux-的性能&quot;&gt;关于 WebFlux 的性能&lt;/h3&gt;
&lt;p&gt;请求的耗时并不会有很⼤的改善
仅需少量固定数量的线程和较少的内存即可实现扩展&lt;/p&gt;

&lt;h3 id=&quot;web-mvc-vs-web-flux&quot;&gt;Web MVC v.s. Web Flux&lt;/h3&gt;
&lt;p&gt;已有 Spring MVC 应⽤，运⾏正常，就别改了 
依赖了大量阻塞式持久化 API 和⽹络 API，建议使⽤ Spring MVC 
已经使⽤了⾮阻塞技术栈，可以考虑使⽤WebFlux
想要使⽤ Java 8 Lambda 结合轻量级函数式框架，可以考虑 WebFlux&lt;/p&gt;

&lt;h3 id=&quot;webflux-中的编程模型&quot;&gt;WebFlux 中的编程模型&lt;/h3&gt;
&lt;p&gt;两种编程模型&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基于注解的控制器 &lt;strong&gt;课程中主要讨论的内容&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;函数式 Endpoints&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于注解的控制器&quot;&gt;基于注解的控制器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;常⽤用注解
    &lt;ul&gt;
      &lt;li&gt;@Controller&lt;/li&gt;
      &lt;li&gt;@RequestMapping 及其等价注解&lt;/li&gt;
      &lt;li&gt;@RequestBody / @ResponseBody&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;返回值
    &lt;ul&gt;
      &lt;li&gt;Mono&lt;T&gt; / Flux&lt;T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 09 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/09/Spring03/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/09/Spring03/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>RestTemplate</category>
        
        <category>RESTful API</category>
        
        <category>Spring MVC</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Pandas </title>
        <description>
</description>
        <pubDate>Sun, 29 Nov 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/11/29/Pandas/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/11/29/Pandas/</guid>
        
        <category>Python</category>
        
        <category>Pandas</category>
        
        <category>Numpy</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记02 数据库操作进阶以及MVC实战相关 </title>
        <description>&lt;h1 id=&quot;chapter-4-数据访问进阶&quot;&gt;Chapter 4 数据访问进阶&lt;/h1&gt;

&lt;h2 id=&quot;project-reactor&quot;&gt;Project Reactor&lt;/h2&gt;

&lt;p&gt;“在计算机中，响应式编程或反应式编程(英语:Reactive Programming)是⼀一种⾯面向数据流和变化传播的编程范式。这 意味着可以在编程语⾔言中很⽅方便便地表达静态或动态的数据流， ⽽而相关的计算模型会⾃自动将变化的值通过数据流进⾏行行传播。”&lt;/p&gt;

&lt;p&gt;实现上下文的语句简洁性，如果需要不停的判断CallBack是很麻烦的&lt;/p&gt;

&lt;h3 id=&quot;基本知识&quot;&gt;基本知识&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Operators - Publisher / Subscriber 发布和订阅
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Nothing Happens Until You subscribe()&lt;/strong&gt; 只有subscribe才会执行&lt;/li&gt;
      &lt;li&gt;Flux [ 0..N ] - onNext()、onComplete()、onError()&lt;/li&gt;
      &lt;li&gt;Mono [ 0..1 ] - onNext()、onComplete()、onError()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Flux 和 Mono都是通过lambda去处理的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Backpressure 缓压力上游生产速度快，下游subscribe跟不上
    &lt;ul&gt;
      &lt;li&gt;Subscription&lt;/li&gt;
      &lt;li&gt;onRequest()每次请求多少元素、onCancel()取消订阅过程、onDispose()终止订阅过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程调度 Schedulers
    &lt;ul&gt;
      &lt;li&gt;immediate() 现在在哪个线程上就使用这个线程/ single() 可复用线程 / newSingle() 新启一个线程&lt;/li&gt;
      &lt;li&gt;elastic() 缓存的线程池上操作60s后会回收/ parallel() 创建和CPU线程相同数量的线程，不会被回收 / newParallel() 新建一个线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;错误处理
    &lt;ul&gt;
      &lt;li&gt;onError / onErrorReturn 错误之后返回特定值/ onErrorResume 用一段Lambda来做处理&lt;/li&gt;
      &lt;li&gt;doOnError / doFinally&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tonydz0523/article/details/107861620&quot; target=&quot;_blank&quot;&gt; Schedule，subscribeOn和publishOn详细例子&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;实际案例&quot;&gt;实际案例&lt;/h3&gt;

&lt;p&gt;pom文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.projectreactor&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;reactor-core&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主程序&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  Flux.range(1, 6)
      .doOnRequest(n -&amp;gt; log.info(&quot;Request {} number&quot;, n)) // 注意顺序造成的区别
      .doOnComplete(() -&amp;gt; log.info(&quot;Publisher COMPLETE 1&quot;))
    //.publishOn(Schedulers.elastic())
      .map(i -&amp;gt; {
        log.info(&quot;Publish {}, {}&quot;, Thread.currentThread(), i);
        return 10 / (i - 3);
//					return i;
      })
      .doOnComplete(() -&amp;gt; log.info(&quot;Publisher COMPLETE 2&quot;))
//				.subscribeOn(Schedulers.single())
//				.onErrorResume(e -&amp;gt; {
//					log.error(&quot;Exception {}&quot;, e.toString());
//					return Mono.just(-1);
//				})
//				.onErrorReturn(-1)
      .subscribe(i -&amp;gt; log.info(&quot;Subscribe {}: {}&quot;, Thread.currentThread(), i),
          e -&amp;gt; log.error(&quot;error {}&quot;, e.toString()),
          () -&amp;gt; log.info(&quot;Subscriber COMPLETE&quot;)//,
//						s -&amp;gt; s.request(4)
      );
  Thread.sleep(2000);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先创建了Flux 1到6的序列，在每次请求Request 答应了每次请求多少的日志，在打印结束之后打印一个Publisher COMPLETE 1，map可以实现元素转换，
打印当前线程。第二个doOnComplete是打印在哪个线程上面，之后有一个subscribe动作，显示&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public final Disposable subscribe(@Nullable Consumer&amp;lt;? super T&amp;gt; consumer, @Nullable Consumer&amp;lt;? super Throwable&amp;gt; errorConsumer, @Nullable Runnable completeConsumer) {
  return this.subscribe(consumer, errorConsumer, completeConsumer, (Consumer)null);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示在消费，错误和完成之后做怎样的处理，在源码中也有&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public final Disposable subscribe(@Nullable Consumer&amp;lt;? super T&amp;gt; consumer, @Nullable Consumer&amp;lt;? super Throwable&amp;gt; errorConsumer, @Nullable Runnable completeConsumer, @Nullable Consumer&amp;lt;? super Subscription&amp;gt; subscriptionConsumer) {
    return (Disposable)this.subscribeWith(new LambdaSubscriber(consumer, errorConsumer, completeConsumer, subscriptionConsumer));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;多了一个在backPressure中做处理的元素。&lt;/p&gt;

&lt;p&gt;取消了以上的代码的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.publishOn(Schedulers.elastic())&lt;/code&gt;就表示在elastic线程池中执行，打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.subscribeOn(Schedulers.single())&lt;/code&gt;中的代码，就会使订阅在single线程上&lt;/p&gt;

&lt;p&gt;对于错误的返回，在map中写入错误，取消掉onErrorReturn的注释，里面传入的是发生错误时返回的默认值。如果希望有代码处理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onErrorResume&lt;/code&gt;简单打印。&lt;/p&gt;

&lt;p&gt;怎样做backPresure
取消注释中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s -&amp;gt; s.request(4)&lt;/code&gt;每次取回四个，所以public没有onComplete，注意这里需要将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.publishOn(...)&lt;/code&gt;挪到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flux.range(...)&lt;/code&gt;的第一个位置，否则会直接先抓出最多的可publish个数再到指定线程里面操作，打印的结果就不是原来的4个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在没进行subscribe之前是不会对其内容有任何操作，以map为例，其实只是onAsmably封装，没有实际触发&lt;/p&gt;

&lt;p&gt;这里只是简单介绍了如何使用reactive的响应式风格，具体的理解和其中的属性的作用可以看这篇文章
&lt;a href=&quot;https://developer.ibm.com/zh/articles/j-cn-with-reactor-response-encode/&quot; target=&quot;_blank&quot;&gt;java响应式&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;reactive-对redis的支持&quot;&gt;Reactive 对redis的支持&lt;/h3&gt;
&lt;p&gt;Reactive其实也支持RDBC但是可能现在功能不是很完善
Jedis客户端不支持Reactive方式，如果要用redis最好使用Lettuce客户端&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ReactiveRedisConnection&lt;/li&gt;
  &lt;li&gt;ReactiveRedisConnectionFactory&lt;/li&gt;
  &lt;li&gt;ReactiveRedisTemplate
    &lt;ul&gt;
      &lt;li&gt;opsForXxx()
和直接使用不同的是这里返回的是Mono或者Flux&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pom文件自动生成可以在start.spring里点击reactive.redis支持&lt;/li&gt;
  &lt;li&gt;在配置model的时候不再需要JPA支持也就是@Table等，有@Data和@Builder即可&lt;/li&gt;
  &lt;li&gt;需要自己在主程序中定义一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reactiveRedisTemplate&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveStringRedisTemplate&lt;/code&gt;类型的，SpringBoot自动的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object Object&lt;/code&gt;类型的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisTemplate&lt;/code&gt;，&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
ReactiveStringRedisTemplate reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
    return new ReactiveStringRedisTemplate(factory);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisConnectionFactory&lt;/code&gt;中只有Lettuce实现，其中需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisConnection&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveRedisClusterConnection&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;aop打印数据访问层&quot;&gt;AOP打印数据访问层&lt;/h2&gt;

&lt;p&gt;applicationContext概念在Web章节说明
&lt;img src=&quot;/img/java-spring/chapter4-aop.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;

&lt;p&gt;AOP中对于事务的增强，定义是在@EnableTranscationManagement中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxyTargetClass&lt;/code&gt;制定了代理的形式，是Cglib还是基于接口，但是没有实现细节，实现是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProxyTransactionConfiguration&lt;/code&gt;中实现的
其中定义了一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TransactionIntersepter&lt;/code&gt;是一个拦截器，implement了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MethodInterceptor&lt;/code&gt;是实现Spring Around类型的Advice&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@FunctionalInterface
public interface MethodInterceptor extends Interceptor {
  Object invoke(MethodInvocation var1) throws Throwable;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现了一个invoke，但是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TransactionIntersepter&lt;/code&gt;中执行这个invoke方法是执行了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeWithinTransaction&lt;/code&gt;中实现了事务性的代码，这个方法是在不使用trasactionManager的基础上实现了事务的封装。&lt;/p&gt;

&lt;h3 id=&quot;实践&quot;&gt;实践&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;常用注解
    &lt;ul&gt;
      &lt;li&gt;@EnableAspectJAutoProxy 对有@Aspect注解的类做支持&lt;/li&gt;
      &lt;li&gt;@Aspect 声明为一个切面 &lt;strong&gt;光写@Aspect还不能变成一个Bean要么使用JavaConfig要么增加@Component注解&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;@Pointcut&lt;/li&gt;
      &lt;li&gt;@Before 在方法执行前执行&lt;/li&gt;
      &lt;li&gt;@After 方法执行之后执行 / @AfterReturning 方法执行成功之后执行/ @AfterThrowing 方法执行失败之后执行&lt;/li&gt;
      &lt;li&gt;@Around 环绕通知 有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProceedingJoinPoint&lt;/code&gt;参数，其中有一个proceed方法可回调原有目标对象的方法&lt;/li&gt;
      &lt;li&gt;@Order 切面的执行顺序，数字越小优先级就越高&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Spring 官方文档中的定义，在写@Pointcut中的正则表达的时候可以看。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Pointcut常用的正则表达
    &lt;ul&gt;
      &lt;li&gt;@Pointcut(“execution(* geektime.spring.springbucks.repository..*(..))”)&lt;/li&gt;
      &lt;li&gt;execution用于匹配是连接点执行的方法&lt;/li&gt;
      &lt;li&gt;
        &lt;ul&gt;
          &lt;li&gt;表示任意返回方法的类型&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;geektime.spring.springbucks.repository是全限定类名&lt;/li&gt;
      &lt;li&gt;全限定类名之后可以接类中的方法名&lt;/li&gt;
      &lt;li&gt;(..)表示匹配任意参数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何打印SQL
    &lt;ul&gt;
      &lt;li&gt;HikariCP P6SQL，https://github.com/p6spy/p6spy&lt;/li&gt;
      &lt;li&gt;Druid  https://github.com/alibaba/druid/wiki/Druid中使⽤用log4j2进⾏日志输出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;拦截器的demo讲解&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;pom文件中&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;p6spy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;p6spy&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;使用p6spy后不能使用Spring自己的数据库，转而使用插入p6spy作为数据库的增强具体实现在integrating p6spy中，&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver
spring.datasource.url=jdbc:p6spy:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;在resources文件夹下配置一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spy.properties&lt;/code&gt;的文件根据&lt;a href=&quot;https://p6spy.readthedocs.io/en/latest/configandusage.html&quot; target=&quot;_blank&quot;&gt;属性文档&lt;/a&gt;
中的内容来配置&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;# 单行日志
logMessageFormat=com.p6spy.engine.spy.appender.SingleLineFormat
# 使用Slf4J记录sql
appender=com.p6spy.engine.spy.appender.Slf4JLogger
# 是否开启慢SQL记录
outagedetection=true
# 慢SQL记录标准，单位秒
outagedetectioninterval=2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;配置modal文件
因为会产生lombok产生的id字段不匹配现象，最好配置@EqualsAndHashCode&lt;strong&gt;使用@Data时同时加上@EqualsAndHashCode(callSuper=true)注解。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对Repository做增强&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect // 说明是切面
@Component // 定义为Bean
@Slf4j
public class PerformanceAspect {
//    @Around(&quot;execution(* geektime.spring.springbucks.repository..*(..))&quot;)
    @Around(&quot;repositoryOps()&quot;)
    public Object logPerformance(ProceedingJoinPoint pjp) throws Throwable {
        long startTime = System.currentTimeMillis();
        String name = &quot;-&quot;;
        String result = &quot;Y&quot;; // 正确返回 Y
        try {
            name = pjp.getSignature().toShortString();//获得对象的方法
            return pjp.proceed(); //调用对象
        } catch (Throwable t) {
            result = &quot;N&quot;; // 错误返回N
            throw t;
        } finally {
            long endTime = System.currentTimeMillis();
            log.info(&quot;{};{};{}ms&quot;, name, result, endTime - startTime); // 显示Repository执行耗时
        }
    }

    @Pointcut(&quot;execution(* geektime.spring.springbucks.repository..*(..))&quot;)
    private void repositoryOps() {
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要记得在主程序上写@EnableAspectjAutoProxy在最主要的案例中因为run方法过长直接分为两个方法来执行了&lt;/p&gt;

&lt;h1 id=&quot;chapter5-spring-mvc实战&quot;&gt;Chapter5 Spring MVC实战&lt;/h1&gt;

&lt;h2 id=&quot;spring-mvc核心内容就是&quot;&gt;Spring MVC核心内容就是&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DispatcherServlet是一个入口
    &lt;ul&gt;
      &lt;li&gt;Controller 每一个请求的处理逻辑&lt;/li&gt;
      &lt;li&gt;xxxResolver 各种解析器
        &lt;ul&gt;
          &lt;li&gt;ViewResolver&lt;/li&gt;
          &lt;li&gt;HandlerExceptionResolver&lt;/li&gt;
          &lt;li&gt;MultipartResolver&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HandlerMapping 处理请求怎样映射&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring MVC中的常用注解
    &lt;ul&gt;
      &lt;li&gt;@Controller 定义一个控制器
        &lt;ul&gt;
          &lt;li&gt;@RestController &lt;strong&gt;@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;@RequestMapping 定义controller处理哪些请求，指定url的path，也可以指定http method或指定消费哪些content-type内容&lt;strong&gt;可以定义在方法上面也可以定义在类上&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;@GetMapping / @PostMapping&lt;/li&gt;
          &lt;li&gt;@PutMapping / @DeleteMapping&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;requestMapping使用事项，在定义在类上的时候&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestMapping(&quot;/coffee&quot;)&lt;/code&gt;就表示这个类中定义的路径的基础就是/coffee/&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;用 @Controller时&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@GetMapping(&quot;/&quot;)
@ResponseBody
public List&amp;lt;Coffee&amp;gt; getAll() {
    return coffeeService.getAllCoffee();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;以上的代码定义在类中，定义的getAll方法直接作为结果返回到responsebody中&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;另一种使用@RestController的格式&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(&quot;/&quot;)
@ResponseStatus(HttpStatus.CREATED)
public CoffeeOrder create(@RequestBody NewOrderRequest newOrder) {
    log.info(&quot;Receive new Order {}&quot;, newOrder);
    Coffee[] coffeeList = coffeeService.getCoffeeByName(newOrder.getItems())
            .toArray(new Coffee[] {});// 调用实例，做成数组
    return orderService.createOrder(newOrder.getCustomer(), coffeeList);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;@RequestBody 对应请求的报文  / @ResponseBody 响应的报文/ @ResponseStatus 指定请求码 @ResponseState可以用在方法前或者类前有不同参数。
&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ResponseStatus(HttpStatus.CREATED)&lt;/code&gt;用在方法前表示请求码注解中有两个参数，value属性设置异常的状态码，reaseon是异常的描述。&lt;/strong&gt;
&lt;a href=&quot;https://blog.51cto.com/4837471/2327327&quot; target=&quot;_blank&quot;&gt;常用的HttpStatus状态&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上面使用了@PostMapping的案例来说，定义了@RequestBody 是NewOrderRequest这个是自己定义的一个类，做了一个实例&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Getter
@Setter
@ToString
public class NewOrderRequest {
    private String customer;
    private List&amp;lt;String&amp;gt; items;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;postman-的-web请求&quot;&gt;postman 的 web请求&lt;/h3&gt;
&lt;h3 id=&quot;application-context-spring-的应用程序上下文&quot;&gt;Application context Spring 的应用程序上下文&lt;/h3&gt;
&lt;p&gt;管理组件的生命周期，依赖注入，上下文的接口BeanFactory等。基于注解的配置。一般不会用BeanFactory。对于BeanFactoryPostProcessor和BeanPostProcessor的扩展点会在低版本Spring实现高版本的Spring配置时会学到。&lt;/p&gt;
&lt;h3 id=&quot;web上下文层次&quot;&gt;Web上下文层次&lt;/h3&gt;
&lt;p&gt;Servlet WebApplicationContext(controllers viewResolver handler mapping)中的继承Root WebApplicationContext(services, repository)中的内容，如果做AOP增强记得要写在Root WebApplicationContext中！&lt;/p&gt;

&lt;h3 id=&quot;web层上下文&quot;&gt;web层上下文&lt;/h3&gt;
&lt;p&gt;ContextHierarchy首先定义了情景，父子上下文增强。是在课程40的内容，主要演示了在父子上下文中是否定义切面&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先定义切面&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Aspect
@Slf4j
public class FooAspect {
    @AfterReturning(&quot;bean(testBean*)&quot;)
    public void printAfter() {
        log.info(&quot;after hello()&quot;);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表示拦截以testBean打头的bean，在return之后打印。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义TestBean表示传入一个context就知道是在哪里使用了这个Bean&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@AllArgsConstructor
@Slf4j
public class TestBean {
    private String context;

    public void hello() {
        log.info(&quot;hello &quot; + context);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@AllArgsConstructor
使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数
@NoArgsConstructor
使用后创建一个无参构造函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义配置类和切面&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Configuration
@EnableAspectJAutoProxy
public class FooConfig {
  @Bean
  public TestBean testBeanX() {
      return new TestBean(&quot;foo&quot;);
  }

  @Bean
  public TestBean testBeanY() {
      return new TestBean(&quot;foo&quot;);
  }

  @Bean
  public FooAspect fooAspect() {
    //实现切面
      return new FooAspect();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方法的主类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void run(ApplicationArguments args) throws Exception {
  ApplicationContext fooContext = new AnnotationConfigApplicationContext(FooConfig.class);
  ClassPathXmlApplicationContext barContext = new ClassPathXmlApplicationContext(
      new String[] {&quot;applicationContext.xml&quot;}, fooContext);//读入自定义的barContext这个里面定义了一个textBeanX 并且 申明fooContext是上级context
  TestBean bean = fooContext.getBean(&quot;testBeanX&quot;, TestBean.class);// 检查输出是否增强
  bean.hello();

  log.info(&quot;=============&quot;);

  bean = barContext.getBean(&quot;testBeanX&quot;, TestBean.class);
  bean.hello();

  bean = barContext.getBean(&quot;testBeanY&quot;, TestBean.class);
  bean.hello();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显示的结果是，在foo(父)上下文中增强过的Bean在子context调用的时候仍能增强，但是子context中没有声明增强的xml文件不能增强，同理如果在foo中删除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fooAspect&lt;/code&gt;这个方法就不能增强。如果要同时增强父子，可以开启AOP增强&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aop:aspectj-autoproxy&lt;/code&gt;表示在写入xml的地方也开启了增强。&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc的请求处理机制&quot;&gt;Spring MVC的请求处理机制&lt;/h2&gt;
&lt;p&gt;⼀个请求的⼤致处理流程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;绑定一些 Attribute
    &lt;ul&gt;
      &lt;li&gt;WebApplicationContext / LocaleResolver / ThemeResolver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理理 Multipart
    &lt;ul&gt;
      &lt;li&gt;如果是，则将请求转为 MultipartHttpServletRequest&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Handler 处理理
    &lt;ul&gt;
      &lt;li&gt;如果找到对应 Handler，执行 Controller 及前后置处理器逻辑&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何定义一个controller&quot;&gt;如何定义一个Controller&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;@Controller&lt;/li&gt;
  &lt;li&gt;@RequestMapping
    &lt;ul&gt;
      &lt;li&gt;path / method 指定映射路路径与⽅方法&lt;/li&gt;
      &lt;li&gt;params / headers 限定映射范围 一般在使用@RequestParam的时候不需要加上这个，但是如果是严格的路径一定要加上限制的params或者headers
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GetMapping(path = &quot;/&quot;, params=&quot;!name&quot;)&lt;/code&gt;表示，使用get请求，在url中没有其他string的url&lt;/li&gt;
      &lt;li&gt;consumes 只接受特定content-type的内容  / produces 只接受特定的响应格式特定的accept头,consumes和produces可以多个获得。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些快捷⽅方式
    &lt;ul&gt;
      &lt;li&gt;@RestController @Controller和@ResponseBody结合&lt;/li&gt;
      &lt;li&gt;@GetMapping / @PostMapping / @PutMapping / @DeleteMapping / @PatchMapping&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定义处理方法
    &lt;ul&gt;
      &lt;li&gt;@RequestBody 请求正文/ @ResponseBody 响应正文将java对象转化为json格式/ @ResponseStatus 响应的Http返回码&lt;/li&gt;
      &lt;li&gt;表示url路径上的变量@PathVariable / @RequestParam使用特定格式的响应标注参数不能为空 / @RequestHeader uri路径上的变量&lt;/li&gt;
      &lt;li&gt;HttpEntity 参数中可接受的/ ResponseEntity 响应中的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各种定义的具体处理形式可以从以下两个文档中找到对应的&lt;a href=&quot;https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-arguments&quot; target=&quot;_blank&quot;&gt; 发送&lt;/a&gt;和&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-return-types&quot; target=&quot;_blank&quot;&gt;响应&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对@ResponseBody的作用可以看&lt;a href=&quot;https://www.cnblogs.com/qiankun-site/p/5774325.html&quot; target=&quot;_blank&quot;&gt;@ResponseBody作用&lt;/a&gt;将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先需要了解的是@RequestBody可以这样定义,该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；
&lt;strong&gt;@RequestBody的作用是修改content-type不是application/x-www-form-urlcoded编码的内容&lt;a href=&quot;https://blog.csdn.net/qq_38408785/article/details/89887748&quot; target=&quot;_blank&quot;&gt; @RequestBody作用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@GetMappig(&quot;/insert&quot;)
@ResponseBody
public Map&amp;lt;String, Object&amp;gt; requestParam(
  @RequestParam(&quot;int_val&quot;) Integer intVal,
  @RequestParam(&quot;long_val&quot;) Long longVal,
  @RequestParam(&quot;str_val&quot;, required=false) String strVal// 这里设置了required为false表示可以设置为空值
){
  Map&amp;lt;String, Object&amp;gt; paramsMap = new HashMap&amp;lt;&amp;gt;();
  paramsMap.put(&quot;intVal&quot;,intVal);
  paramsMap.put(&quot;longVal&quot;,longVal);
  paramsMap.put(&quot;strVal&quot;,strVal);

  return paramsMap;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这之中post和get请求都是需要在实现的时候多加注意的。多种传递参数的方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;无注解的&lt;/li&gt;
  &lt;li&gt;@RequestParam 前后端参数映射的关系&lt;/li&gt;
  &lt;li&gt;数组传递&lt;/li&gt;
  &lt;li&gt;JSON传递&lt;/li&gt;
  &lt;li&gt;URL传递参数的方式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GetMapping(&quot;/{id}&quot;)&lt;/code&gt;之后在方法需要传入的变量中dingyi&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public User get(@PathVariable(&quot;id&quot;) Long id){...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;定义类型转换&quot;&gt;定义类型转换&lt;/h2&gt;
&lt;p&gt;⾃己实现 WebMvcConfigurer
Spring Boot 在 WebMvcAutoConfiguration 中实现了一个 添加⾃自定义的 Converter: 作为一个一对一转换器，从一种类型转化到另外一种类型接口定义
添加自定义的 Formatter&lt;/p&gt;

&lt;h3 id=&quot;formatter-使用样例&quot;&gt;Formatter 使用样例&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Component
public class MoneyFormatter implements Formatter&amp;lt;Money&amp;gt; {
  /**
    * 处理 CNY 10.00 / 10.00 形式的字符串
    * 校验不太严密，仅作演示
    */
  @Override
  public Money parse(String text, Locale locale) throws ParseException {
    if (NumberUtils.isParsable(text)) {
        return Money.of(CurrencyUnit.of(&quot;CNY&quot;), NumberUtils.createBigDecimal(text));
    } else if (StringUtils.isNotEmpty(text)) {
        String[] split = StringUtils.split(text, &quot; &quot;);
        if (split != null &amp;amp;&amp;amp; split.length == 2 &amp;amp;&amp;amp; NumberUtils.isParsable(split[1])) {
            return Money.of(CurrencyUnit.of(split[0]),
                    NumberUtils.createBigDecimal(split[1]));
        } else {
            throw new ParseException(text, 0);
        }
    }
    throw new ParseException(text, 0);
  }

  @Override
  public String print(Money money, Locale locale) {
      if (money == null) {
          return null;
      }
      return money.getCurrencyUnit().getCode() + &quot; &quot; + money.getAmount();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码定义，首先通过@Component自动注册为Bean，对输入的内容做BigDecimal转换，之后通过判断输入的是否为空或者是CNY 10 还是直接输入10 作为 金钱单位，这里不是很精确。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Locale&lt;/code&gt;是国际化的常用单位，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NumberUtils.isParsable&lt;/code&gt;的原理是逐个字符判断是否为数字，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NumberUtils&lt;/code&gt;还有其他用法如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isCreatable&lt;/code&gt;是判断字符串能否转化为Java可识别的数字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意pom引入Apatch的commons.lang&lt;/strong&gt;
&lt;strong&gt;throw:一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常&lt;/strong&gt;
&lt;strong&gt;throws:当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理&lt;/strong&gt;
&lt;strong&gt;如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;定义校验&quot;&gt;定义校验&lt;/h2&gt;
&lt;p&gt;通过 Validator 对绑定结果进行校验
Hibernate Validator
@Valid 注解 
通过返回BindingResult实现最后结果。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addCoffeeWithoutBindingResult(@Valid NewCoffeeRequest newCoffee) {
    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;没有加上@RequestBody 是因为会将请求正文变成对象传入， consumes表示处理的数据形式，这里是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APPLICATION_FORM_URLENCODED_VALUE&lt;/code&gt;表示处理表单，因为path对应多个controller所以要写consumes;这里的NewCoffeeRequest是帮助在读入数据之前对数据的检查可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.validation.constraints.NotNull&lt;/code&gt;甚至里面可以使用正则表达。其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.validation.constraints.NotEmpty&lt;/code&gt;和NotNull区别是NotEmpty还要保证输入的不为空字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要mediaType对应的类型APPLICATION_JSON_UTF8_VALUE是application/json;charset=UTF-8&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,
                        BindingResult result) {
    if (result.hasErrors()) {
        // 这里先简单处理一下，后续讲到异常处理时会改
        log.warn(&quot;Binding Errors: {}&quot;, result);
        return null;
    }
    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于出现的异常通过BindingResult实现转换，错误返回null，详细内容需要看错误处理章节。&lt;/p&gt;
&lt;h2 id=&quot;multipart-上传-文件上传&quot;&gt;Multipart 上传 文件上传&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;配置 MultipartResolver
    &lt;ul&gt;
      &lt;li&gt;Spring Boot ⾃动配置 MultipartAutoConfiguration&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;支持类型 multipart/form-data&lt;/li&gt;
  &lt;li&gt;MultipartFile 类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public List&amp;lt;Coffee&amp;gt; batchAddCoffee(@RequestParam(&quot;file&quot;) MultipartFile file) {
  List&amp;lt;Coffee&amp;gt; coffees = new ArrayList&amp;lt;&amp;gt;();
  if (!file.isEmpty()) {
    BufferedReader reader = null;
    try {
      reader = new BufferedReader(new InputStreamReader(file.getInputStream()));
      String str;
      while ((str = reader.readLine()) != null) {
        String[] arr = StringUtils.split(str, &quot; &quot;);
        if (arr != null &amp;amp;&amp;amp; arr.length == 2) {
          coffees.add(coffeeService.saveCoffee(arr[0],
                  Money.of(CurrencyUnit.of(&quot;CNY&quot;),
                          NumberUtils.createBigDecimal(arr[1]))));
        }
      }
    } catch (IOException e) {
        log.error(&quot;exception&quot;, e);
    } finally {
        IOUtils.closeQuietly(reader);
    }
  }
  return coffees;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解释，通过@RequestParam获得file，通过BufferedReader，再通过空格分开，最后再对reader做一个关闭。在postman中操作的时候需要选择文件上传。&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc-视图解析相关&quot;&gt;Spring MVC 视图解析相关&lt;/h2&gt;

&lt;h3 id=&quot;视图解析的基础实现&quot;&gt;视图解析的基础实现&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ViewResolver 与 View 接⼝
    &lt;ul&gt;
      &lt;li&gt;AbstractCachingViewResolver&lt;/li&gt;
      &lt;li&gt;UrlBasedViewResolver&lt;/li&gt;
      &lt;li&gt;FreeMarkerViewResolver&lt;/li&gt;
      &lt;li&gt;ContentNegotiatingViewResolver 可以接受的返回类型选择合适的响应&lt;/li&gt;
      &lt;li&gt;InternalResourceViewResolver 放在解析链最后的解析器 处理JSP JSTL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dispatcherservlet-中的视图解析逻辑&quot;&gt;DispatcherServlet 中的视图解析逻辑&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;initStrategies()
    &lt;ul&gt;
      &lt;li&gt;initViewResolvers() 初始化了了对应 ViewResolver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;doDispatch()
    &lt;ul&gt;
      &lt;li&gt;processDispatchResult()
        &lt;ul&gt;
          &lt;li&gt;没有返回视图的话，尝试 RequestToViewNameTranslator&lt;/li&gt;
          &lt;li&gt;resolveViewName() 解析 View 对象&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使⽤用 @ResponseBody 的情况
    &lt;ul&gt;
      &lt;li&gt;在 HandlerAdapter.handle() 的中完成了了 Response 输出
        &lt;ul&gt;
          &lt;li&gt;RequestMappingHandlerAdapter.invokeHandlerMethod()
            &lt;ul&gt;
              &lt;li&gt;HandlerMethodReturnValueHandlerComposite.handleReturnValue()
                &lt;ul&gt;
                  &lt;li&gt;RequestResponseBodyMethodProcessor.handleReturnValue()&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;重定向&quot;&gt;重定向&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;redirect: 客户端发起，url有变化，而且会丢失request信息&lt;/li&gt;
  &lt;li&gt;forward：服务端发起，浏览器url无变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-mvc-常用视图&quot;&gt;Spring MVC 常用视图&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Jackson-based JSON / XML&lt;/li&gt;
  &lt;li&gt;Thymeleaf &amp;amp; FreeMarke
&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-view&quot; target=&quot;_blank&quot;&gt;常见视图官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置message-converter&quot;&gt;配置Message Converter&lt;/h3&gt;

&lt;p&gt;通过WebMvcCOnfigurer 中的 ConfigureMessageConverters() 在 Spring Boot 自动查找 HttpMessageConverters 进行注册&lt;/p&gt;

&lt;h3 id=&quot;spring-boot-对-jackson-的支持&quot;&gt;Spring Boot 对 Jackson 的⽀支持&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JacksonAutoConfiguration
    &lt;ul&gt;
      &lt;li&gt;Spring Boot 通过 @JsonComponent 注册 JSON 序列列化组件，作用于JackJson模块上也就是在例子的主程序中定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hibernate5Module&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Jackson2ObjectMapperBuilderCustomizer 定义返回类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JacksonHttpMessageConvertersConfiguration
    &lt;ul&gt;
      &lt;li&gt;增加 jackson-dataformat-xml 以支持 XML 序列列化
这个通过JacksonHttpMessageConvertersConfiguration实现的就是通过给响应序列化和反序列化对请求和响应内容做精简，同时也能对Hibernate做优化，比如在Termianl中需要显示响应信息可以通过Jacksonjson实现缩进&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;!-- 增加Jackson的Hibernate类型支持 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jackson-datatype-hibernate5&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.9.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 增加Ja ckson XML支持 --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.fasterxml.jackson.dataformat&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jackson-dataformat-xml&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在之后的需要对数据进行序列化和反序列化&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//序列化
@JsonComponent
public class MoneySerializer extends StdSerializer&amp;lt;Money&amp;gt; {
  protected MoneySerializer() {
      super(Money.class);
  }

  @Override
  public void serialize(Money money, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
      jsonGenerator.writeNumber(money.getAmount());
  }
}

// 反序列化
@JsonComponent
public class MoneyDeserializer extends StdDeserializer&amp;lt;Money&amp;gt; {
    protected MoneyDeserializer() {
        super(Money.class);
    }

    @Override
    public Money deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        return Money.of(CurrencyUnit.of(&quot;CNY&quot;), p.getDecimalValue());
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在最终的实现格式是在主程序中&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public Hibernate5Module hibernate5Module() {
  return new Hibernate5Module();
}

@Bean
public Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer() {//作用接口的内部匿名实现类
  return builder -&amp;gt; builder.indentOutput(true);//实现缩进
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hibernate5Module&lt;/code&gt;是JackJson的模块，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jackson2ObjectMapperBuilderCustomizer&lt;/code&gt;是用来实现缩进的
在controller中需要修改的地方是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path=&quot;/&quot;, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addCoffeeWithoutBinding(@Valid  @RequestBody NewCoffeeRequest coffeeRequest){
  return coffeeService.saveCoffee(coffeeRequest.getName(), coffeeRequest.getPrice());
}
...
@GetMapping(path = &quot;/{id}&quot;)
@ResponseBody
public Coffee getById(@PathVariable Long id){
  return coffeeService.getCoffee(id);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getById方法可以返回json对象，并且是对这个懒加载对象的方式的的文件格式没有要求，因为没有加上consumer。&lt;/p&gt;

&lt;h2 id=&quot;spring-常见模板引擎&quot;&gt;Spring 常见模板引擎&lt;/h2&gt;
&lt;h3 id=&quot;添加-thymeleaf-依赖&quot;&gt;添加 Thymeleaf 依赖&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使⽤用 Thymeleaf
    &lt;ul&gt;
      &lt;li&gt;org.springframework.boot:spring-boot-starter-thymeleaf&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Boot 的⾃自动配置
    &lt;ul&gt;
      &lt;li&gt;ThymeleafAutoConfiguration&lt;/li&gt;
      &lt;li&gt;ThymeleafViewResolver&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thymeleaf-的一些默认配置&quot;&gt;Thymeleaf 的⼀一些默认配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;spring.thymeleaf.cache=true  模板默认是加载一次后不会再加载了，如果开发环境中需要加载，所以，在开发时需要设置为false
&lt;strong&gt;提醒：如果是噻idea中，编辑的地方是src的source模块下，但是实际应用的目录是在target下的&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.check-template=true  是否校验模板&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.check-template-location=true 是否要检查模板位置&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.enabled=true&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.encoding=UTF-8&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.mode=HTML&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.servlet.content-type=text/html&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.prefix=classpath:/templates/ 模板前缀&lt;/li&gt;
  &lt;li&gt;spring.thymeleaf.suffix=.html 模板后缀&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thymeleaf使用案例&quot;&gt;Thymeleaf使用案例&lt;/h3&gt;
&lt;p&gt;controller的修改，不再只用@RestController而是使用@Controller，并且给每个方法都增加了@ResponseBody注解&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结，Thymeleaf已经不太适用于做大前端的服务项目，例如静态资源等可以通过Nginx来代替做静态资源缓存&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;静态资源与缓存spring中其实不太建议使用静态资源缓存了&quot;&gt;静态资源与缓存（spring中其实不太建议使用静态资源缓存了）&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;核⼼心逻辑
    &lt;ul&gt;
      &lt;li&gt;WebMvcConfigurer.addResourceHandlers()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常⽤用配置
    &lt;ul&gt;
      &lt;li&gt;spring.mvc.static-path-pattern=/**&lt;/li&gt;
      &lt;li&gt;spring.resources.static-locations=classpath:/META-INF/ 
resources/,classpath:/resources/,classpath:/static/,classpath:/public/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存配置常⽤用配置(默认时间单位都是秒)
    &lt;ul&gt;
      &lt;li&gt;ResourceProperties.Cache&lt;/li&gt;
      &lt;li&gt;spring.resources.cache.cachecontrol.max-age=时间 最大缓存时间默认单位是秒&lt;/li&gt;
      &lt;li&gt;spring.resources.cache.cachecontrol.no-cache=true/false&lt;/li&gt;
      &lt;li&gt;spring.resources.cache.cachecontrol.s-max-age=时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不建议使用缓存在controller中使用，可以在拦截器中使用缓存&lt;/p&gt;

&lt;h2 id=&quot;spring中的异常处理机制&quot;&gt;Spring中的异常处理机制&lt;/h2&gt;

&lt;h3 id=&quot;核心接口&quot;&gt;核心接口&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HandlerExceptionResolver
    &lt;h3 id=&quot;实现类&quot;&gt;实现类&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;SimpleMappingExceptionResolver&lt;/li&gt;
  &lt;li&gt;DefaultHandlerExceptionResolver&lt;/li&gt;
  &lt;li&gt;ResponseStatusExceptionResolver&lt;/li&gt;
  &lt;li&gt;ExceptionHandlerExceptionResolver&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;异常处理方法&quot;&gt;异常处理方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@ExceptionHandler
    &lt;h3 id=&quot;添加位置&quot;&gt;添加位置&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;@Controller / @RestController&lt;/li&gt;
  &lt;li&gt;@ControllerAdvice / @RestControllerAdvice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在BindingResult 中的处理方式 和@ControllAdvice中的不同，在postman中的反应形式不同。&lt;/p&gt;

&lt;p&gt;BindingResult中需要定义一个@ResponseBody&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@ResponseStatus(HttpStatus.BAD_REQUEST)
@Getter
@AllArgsConstructor//使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数
public class FormValidationException extends RuntimeException {
  private BindingResult result;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个是在 BindingResult中定义result最后的返回类上的throw的new方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormValidationException&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(paht = &quot;/&quot;, consumer = MediaType.APPLICATION_JSON_UTF8_VALUE)
@ResponseStatus(HttpStatus.CREATED)
@ResponseBody
public Coffee addCoffee(@Valid NewCoffeeRequest newCoffeeRequest,
                        BindingResult result) {
  if (result.hasErrors()) {
    log.warn(&quot;Binding Errors: {}&quot;, result);
    throw new FormValidationException(result);
  }
  return coffeeService.saveCoffee(newCoffeeRequest.getName(), newCoffeeRequest.getPrice(), newCoffeeRequest.getFormCode())
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是要在@ControllerAdvice上定义错误处理函数可以见以下案例&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@RestControllerAdvice
public class GlobalControllerAdvice {
  @ExceptionHandler(ValidationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  public Map&amp;lt;String, String&amp;gt; validationExceptionHandler(ValidationException exception) {
    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;message&quot;, exception.getMessage());
    return map;
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相对应的定义的Controller中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValidationException&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostMapping(path = &quot;/&quot;, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
@ResponseBody
@ResponseStatus(HttpStatus.CREATED)
public Coffee addJsonCoffee(@Valid @RequestBody NewCoffeeRequest newCoffee,BindingResult result) {
  if (result.hasErrors()) {
      log.warn(&quot;Binding Errors: {}&quot;, result);
      throw new ValidationException(result.toString());
  }
  return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;详细的@ControllerAdvice的用法如下&lt;a href=&quot;https://www.cnblogs.com/lenve/p/10748453.html&quot; target=&quot;_blank&quot;&gt;@ControllerAdvisor&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/yanggb/p/10859907.html&quot; target=&quot;_blank&quot;&gt;@ControllerAdvisor&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc-切入点&quot;&gt;Spring MVC 切入点&lt;/h2&gt;

&lt;h3 id=&quot;spring-mvc-的拦截器器&quot;&gt;Spring MVC 的拦截器器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HandlerInteceptor
    &lt;ul&gt;
      &lt;li&gt;boolean preHandle() 预处理 返回布尔 false就终止&lt;/li&gt;
      &lt;li&gt;void postHandle() 后处理&lt;/li&gt;
      &lt;li&gt;void afterCompletion() 后处理之后的完成方法
postHandle 和 afterCompletion区别是视图呈现的区别&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;针对 @ResponseBody 和 ResponseEntity 的情况
    &lt;ul&gt;
      &lt;li&gt;ResponseBodyAdvice&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;针对异步请求的接⼝&lt;strong&gt;异步方法不会执行postHandle或者afterCompletion&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;AsyncHandlerInterceptor
        &lt;ul&gt;
          &lt;li&gt;void afterConcurrentHandlingStarted()&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;拦截器的配置方法&quot;&gt;拦截器的配置方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;常规方法
    &lt;ul&gt;
      &lt;li&gt;WebMvcConfigurer.addInterceptors()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Boot 中的配置
    &lt;ul&gt;
      &lt;li&gt;创建⼀个带 @Configuration 的 WebMvcConfigurer 配置类&lt;/li&gt;
      &lt;li&gt;不能带 @EnableWebMvc(想彻底⾃己控制 MVC 配置除外)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;主程序中继承WebMvcConfigurer来实现addInterceptors方法注册PerformanceInteceptor&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class WaiterServiceApplication implements WebMvcConfigurer {
  @Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(new PerformanceInteceptor())
				.addPathPatterns(&quot;/coffee/**&quot;).addPathPatterns(&quot;/order/**&quot;);
	}
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码表示要拦截“/coffee/”所有请求的调用，以及“/order/”相关的拦截器&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;之后写入实例performanceIntercepter实例化拦截器&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class PerformanceInteceptor implements HandlerInterceptor {
  private ThreadLocal&amp;lt;StopWatch&amp;gt; stopWatch = new ThreadLocal&amp;lt;&amp;gt;();

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    StopWatch sw = new StopWatch();
    stopWatch.set(sw);
    sw.start();
    return true;
  }

  @Override
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    stopWatch.get().stop();
    stopWatch.get().start();
  }

  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    StopWatch sw = stopWatch.get();
    sw.stop();
    String method = handler.getClass().getSimpleName();
    if (handler instanceof HandlerMethod) {
      String beanType = ((HandlerMethod) handler).getBeanType().getName();
      String methodName = ((HandlerMethod) handler).getMethod().getName();
      method = beanType + &quot;.&quot; + methodName;
    }
    log.info(&quot;{};{};{};{};{}ms;{}ms;{}ms&quot;,
      request.getRequestURI(),
      method,
      response.getStatus(),
      ex == null ? &quot;-&quot; : ex.getClass().getSimpleName(),
      sw.getTotalTimeMillis(), 
      sw.getTotalTimeMillis() - sw.getLastTaskTimeMillis(),
      sw.getLastTaskTimeMillis());
    stopWatch.remove();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解释:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。&lt;/li&gt;
  &lt;li&gt;StopWatch是SpringMVC中常见的记录时间的工具&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler.getClass().getSimpleName();&lt;/code&gt;获得的是hanlder方法名也就是哪个controller来处理&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log.info&lt;/code&gt;中的内容作用是：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.getRequestURI()&lt;/code&gt;获得的是哪个URI的请求，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method&lt;/code&gt;使用的是哪个handler的哪个方法做的处理，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response.getStatus()&lt;/code&gt;获得HttpStatus，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex == null ? &quot;-&quot; : ex.getClass().getSimpleName(),&lt;/code&gt;如果有异常将异常类名打出，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sw.getTotalTimeMillis() - sw.getLastTaskTimeMillis(),&lt;/code&gt;用总耗时减去上一个节点的记录时间表示prehandle 到 posthandle的时间, 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sw.getLastTaskTimeMillis()&lt;/code&gt;posthandle 到 afterCompletion之间的耗时&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 04 Nov 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/11/04/Spring02/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/11/04/Spring02/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>WebFlux</category>
        
        <category>Project Reactor</category>
        
        <category>Spring MVC</category>
        
        <category>NoSql</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Docker教程 </title>
        <description>&lt;p&gt;Docker&lt;/p&gt;
&lt;h1 id=&quot;查看&quot;&gt;查看&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;docker ps 查看正在运行的容器&lt;/li&gt;
  &lt;li&gt;docker ps -a 查看所有容器
    &lt;h1 id=&quot;创建并启动&quot;&gt;创建并启动&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;docker run 参数-i 保持docker运行 常于-t 一起使用
    &lt;ul&gt;
      &lt;li&gt;-t将容器分配入伪终端&lt;/li&gt;
      &lt;li&gt;-d以守护后台方式维护容器 以docker exec 进入容器 退出后容器不会关闭&lt;/li&gt;
      &lt;li&gt;-it 交互式容器 -id守护式容器&lt;/li&gt;
      &lt;li&gt;—name为容器创建名字&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;删除镜像 docker rmi 镜像名&lt;/li&gt;
  &lt;li&gt;删除容器 docker rm 容器名&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;镜像&quot;&gt;镜像&lt;/h1&gt;

&lt;h2 id=&quot;查看本地所有镜像&quot;&gt;查看本地所有镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker images
    &lt;ul&gt;
      &lt;li&gt;docker images -p // 查看镜像id&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;查找所需镜像&quot;&gt;查找所需镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker search 查找镜像名 如redis&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;拉取镜像&quot;&gt;拉取镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker pull 镜像名&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;删除镜像&quot;&gt;删除镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker rmi 镜像id&lt;/li&gt;
  &lt;li&gt;docker rmi ‘docker images -q’删除本地所有镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;容器的启动&quot;&gt;容器的启动&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;docker run&lt;/li&gt;
  &lt;li&gt;docker start/stop &lt;容器器名&gt;&lt;/容器器名&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker ps &lt;容器器名&gt; docker logs &lt;容器器名&gt;&lt;/容器器名&gt;&lt;/容器器名&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker run 的常⽤用选项 
&lt;strong&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG…]&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;-d，后台运⾏行行容器器&lt;/li&gt;
      &lt;li&gt;-e，设置环境变量量&lt;/li&gt;
      &lt;li&gt;–expose / -p 宿主端⼝:容器器端⼝&lt;/li&gt;
      &lt;li&gt;–name，指定容器器名称&lt;/li&gt;
      &lt;li&gt;–link，链接不不同容器&lt;/li&gt;
      &lt;li&gt;-v 宿主⽬目录:容器器⽬目录，挂载磁盘卷&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;exec 容器id进入容器 退出时不会关闭
eg. docker exec -it Rea /bin/bash 进入容器&lt;/li&gt;
  &lt;li&gt;exit 之后不会关闭&lt;/li&gt;
  &lt;li&gt;docker start 容器名&lt;/li&gt;
  &lt;li&gt;docker run 创建并启动容器 eg. docker run -it –name=RRea redis:latest /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;docker-删除容器&quot;&gt;docker 删除容器&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;docker rm ’docker ps -aq’ 删除所有容器
开启中的容器不能删除&lt;/li&gt;
  &lt;li&gt;docker stop 容器名 停止&lt;/li&gt;
  &lt;li&gt;docker inspect 容器名 查看容器信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;容器的数据卷-一个文件和根目录&quot;&gt;容器的数据卷 （一个文件和根目录）&lt;/h1&gt;

&lt;h2 id=&quot;数据卷解决的问题-&quot;&gt;数据卷解决的问题 ：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;容器删除后 里面的文件还存在吗？ 不在&lt;/li&gt;
  &lt;li&gt;docker容器可以和外部机器交换文件吗？ 不能&lt;/li&gt;
  &lt;li&gt;两个容器之间怎么交互数据？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数据卷概念&quot;&gt;数据卷概念：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;数据卷是宿主机中的一个目录或者文件 
（宿主机目录挂载容器）&lt;/li&gt;
  &lt;li&gt;当容器目录和数据卷目录绑定后修改会立即同步&lt;/li&gt;
  &lt;li&gt;一个数据卷可以被多个容器挂载&lt;/li&gt;
  &lt;li&gt;一个容器可以挂载多个数据卷&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;配置数据卷&quot;&gt;配置数据卷&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;docker run  … -v 宿主机目录（文件）：容器内目录（文件）…
注意事项： 目录必须是绝对路径 ；如果目录不存在会自动创建；可以挂载多个数据卷
eg. docker run -it –name=c1 -v /root/data/:/root/data_container centos:7  创建 centos 镜像文件 并挂载数据卷&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据卷容器&quot;&gt;数据卷容器&lt;/h2&gt;
&lt;p&gt;通过一个容器挂载两个容器 同时挂载一个数据卷 ：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建启动c3数据卷容器&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;docker run -it —name=c3数据卷名 -v /数据卷目录 centos:7 /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;创建启动c1,c2 容器—volumes-from 设置参数&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;docker run -it —name=c1 —volumes-from c3 cenos:7 /bin/bash&lt;/li&gt;
  &lt;li&gt;docker run -it —name=c2 —volumes-from c3 cenos:7 /bin/bash&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;docker-部署&quot;&gt;docker 部署&lt;/h1&gt;
&lt;h2 id=&quot;通过外部mysql客户端操作mysql&quot;&gt;通过外部MySQL客户端操作MySQL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;问题：外部容器无法访问容器 但是宿主机和外部同&lt;/li&gt;
  &lt;li&gt;端口映射：外部机器访问宿主机端口从而访问容器端口&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;$ docker run -id \
 -p 3307:3306 \ 
 --name=c_mysql \
 -v $PWD/conf:/etc/mysql/conf.d \
 -v $PWD/logs:/logs \
 -v $PWD/data:/var/lib/mysql \
 -e MYSQL_ROOT_PASSWORD=123456 \
 mysql:5.6
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-p 3307:3306 将容器的3306映射到宿主机的3307&lt;/li&gt;
  &lt;li&gt;-v $PWD/conf:/etc/mysql/conf.d 将当前主机下的conf/my.cnf挂载到容器&lt;/li&gt;
  &lt;li&gt;-v $PWD/logs:/logs 将日志目录匹配&lt;/li&gt;
  &lt;li&gt;-v $PWD/data:/var/lib/mysql 数据目录同步 即使容器坏掉 依然能够使用data&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-e MYSQL_ROOT_PASSWORD=123456 配置 root用户的环境变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;进入容器：docker exec -it c_mysql /bin/bash&lt;/li&gt;
  &lt;li&gt;登录mysql ：mysql -uroot -p123456
在mysql界面上的命令
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create database db1;&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show databases; &lt;/code&gt;需要有 &lt;strong&gt;;&lt;/strong&gt; 符号
外部登录MySQL 直接在 navicate 上登录MySQL 并输入 端口号 取得一个映射 注意此处是3307 root和密码输入即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;部署mongodb&quot;&gt;部署MongoDB&lt;/h3&gt;

&lt;p&gt;获取镜像&lt;/p&gt;

&lt;p&gt;运行 MongoDB 镜像 https://hub.docker.com/_/mongo&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker pull mongo
docker run --name mongo -p 27017:27017 -v ~/docker-
data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin
-e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过  Docker 启动 MongoDB&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;登录到 MongoDB 容器中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec -it mongo bash&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过 Shell 连接 MongoDB &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongo -u admin -p admin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;配置tomcat&quot;&gt;配置Tomcat&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;搜索 和 拉取 tomcat镜像docker search tomcat   docker pull tomcat&lt;/li&gt;
  &lt;li&gt;创建容器 映射端口&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mkdir ~/tomcat
cd ~/tomcat
docker run -id --name=c_tomcat \
-p 8080:8080 \
-v $PWD:/usr/local/tomcat/webapps \
tomcat
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数介绍：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-p 8080:8080 容器端口映射到主机端口&lt;/li&gt;
  &lt;li&gt;-v $PWD:/usr/local/tomcat/webapps 将主机的当前目录 挂载到 容器的webapps 上 
 简单配置方式
 $mkdir test
$ cd test
$ vim index.html 编写一个简单HTML页面
在网页的地址栏输入 分配的地址:8080/test/index.html
在日后的使用时 直接将页面放入Tomcat目录中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nignx-部署&quot;&gt;Nignx 部署&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;查找和下载 docker search nginx 
Docker pull nignx&lt;/li&gt;
  &lt;li&gt;mkdir ~/nginx&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd ~/nginx
mkdir conf
cd conf
vim nginx.conf
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写入以下文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    keepalive_timeout  65;
    #gzip  on;
    include /etc/nginx/conf.d/*.conf;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意 以下操作一定要推到nginx目录里面操作&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker run -id --name=容器名称 \
-p 宿主机端口:容器端口 \
-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \
-v $PWD/logs:/var/log/nginx \
-v $PWD/html:/usr/share/nginx/html \
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nginx:版本号
参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录&lt;/li&gt;
  &lt;li&gt;-v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eg:docker run -id –name=c_nginx -p 8000:80 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/var/log/nginx -v $PWD/html:/usr/share/nginx/html nginx
在HTML目录下创建文件 之后直接在 地址号：端口号 就能看见配置的 文件&lt;/p&gt;

&lt;h3 id=&quot;redis-部署&quot;&gt;redis 部署&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;docker run -id –name=c_redis -p 6379:6379  redis:5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;elasticsearch-部署&quot;&gt;elasticsearch 部署&lt;/h3&gt;
&lt;p&gt;https://www.cnblogs.com/powerbear/p/11298135.html&lt;/p&gt;

&lt;p&gt;如果是要和kibana联合使用需要开一个内部网络&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker network create esnet&lt;/code&gt;之后查看镜像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker images&lt;/code&gt;之后开始运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name elasticsearch  -p 9200:9200 -p 9300:9300  --network esnet -e &quot;discovery.type=single-node&quot; 镜像号&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt;表示设置初始堆内存和最大内存 也可以调整虚拟机内存如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e S_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;&lt;/code&gt;
打开localhost:9200如果是一段一下内容表示成功。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
&quot;name&quot; : &quot;39042254f345&quot;,
&quot;cluster_name&quot; : &quot;docker-cluster&quot;,
&quot;cluster_uuid&quot; : &quot;gO3NL-XwRWq3siqb8uNahw&quot;,
&quot;version&quot; : {
  &quot;number&quot; : &quot;7.4.2&quot;,
  &quot;build_flavor&quot; : &quot;default&quot;,
  &quot;build_type&quot; : &quot;docker&quot;,
  &quot;build_hash&quot; : &quot;2f90bbf7b93631e52bafb59b3b049cb44ec25e96&quot;,
  &quot;build_date&quot; : &quot;2019-10-28T20:40:44.881551Z&quot;,
  &quot;build_snapshot&quot; : false,
  &quot;lucene_version&quot; : &quot;8.2.0&quot;,
  &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
  &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
},
&quot;tagline&quot; : &quot;You Know, for Search&quot;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;elasticsearch 可视化插件elasticsearch-head 详细启动见https://www.cnblogs.com/afeige/p/10771140.html 在本机中使用如下命令打开这个插件，注意端口9100是对的，在网页上输入localhost:9100后可以看到集群情况
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -d -p 9100:9100 docker.io/mobz/elasticsearch-head:5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此后有了用户名和密码的设计，所有密码是fiona@1999用户名是对应的应用&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Enter password for [elastic]:
Reenter password for [elastic]:
Enter password for [apm_system]:
Reenter password for [apm_system]:
Enter password for [kibana]:
Reenter password for [kibana]:
Enter password for [logstash_system]:
Reenter password for [logstash_system]:
Enter password for [beats_system]:
Reenter password for [beats_system]:
Enter password for [remote_monitoring_user]:
Reenter password for [remote_monitoring_user]:
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker-快速启动kibana&quot;&gt;docker 快速启动kibana&lt;/h3&gt;
&lt;p&gt;一、拉取镜像
二、启动容器:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name kibana -e ELASTICSEARCH_URL=http://0.0.0.0:9200 -p 5601:5601 -d kibana:7.4.2&lt;/code&gt;
三、访问kibana:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:5601&lt;/code&gt;
四、可能遇到的问题&lt;/p&gt;

&lt;h1 id=&quot;docker-转镜像&quot;&gt;Docker 转镜像&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;容器转镜像（目录挂载不进入）
docker commit 容器 id 镜像名称 ：版本号&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;镜像转压缩文件
    &lt;ul&gt;
      &lt;li&gt;docker save -o 压缩文件名 镜像名：版本号&lt;/li&gt;
      &lt;li&gt;docker load -i 压缩文件名称  （还原压缩文件）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;docker file 
制作镜像的文件 是文本文件 包含一条一条指令每一层指令构成一个镜像
    &lt;ul&gt;
      &lt;li&gt;案例
        &lt;ul&gt;
          &lt;li&gt;docker run -it –name=c11 centos:7
&lt;strong&gt;官方路径在/root下 不能用vim&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;自定义centos&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;默认路径在/usr&lt;/li&gt;
  &lt;li&gt;能使用 vim&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;解决
    &lt;ol&gt;
      &lt;li&gt;父镜像 FROM centos:7&lt;/li&gt;
      &lt;li&gt;作者信息 MAINTAINER jojo&lt;a href=&quot;mailto:jijojo@1212&quot;&gt;jijojo@1212&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;执行安装vim命令 RUN yum install -y vim&lt;/li&gt;
      &lt;li&gt;工作路径 WORKDIR /usr&lt;/li&gt;
      &lt;li&gt;启动执行命令 CMD /bin/bash&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docker build -f(docker file 的文件路径) ./centos_dockerfile -t(设置新的镜像名字) jojoscenos&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;部署 spring boot项目&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;docker服务编排&lt;/li&gt;
      &lt;li&gt;Compose： 按照业务规则批量管理容器&lt;/li&gt;
      &lt;li&gt;docker compose 分布式部署工具 完整生命周期&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安装：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-&lt;/code&gt;uname -s&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;uname -m&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; -o /usr/local/bin/docker-compose&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;配置权限 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod +x /usr/local/bin/docker-compose&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看版本信息 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose -version&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;卸载&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm /usr/local/bin/docker-compose&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用docker搭建nginx和springboot项目&quot;&gt;用docker搭建nginx和springboot项目&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mkdir ~/docker-compose
cd ~/docker-compose
vim docker-compose.yml
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写配置文件  （键值对有空格 写的时候有高亮）&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;version: '3'
services:
 nginx:
  image: nginx
  ports:
   - 80:80
  links:
   - app
  volumes:
   - ./nginx/conf.d:/etc/nginx/conf.d
 app:
  image: app
  expose:
   - &quot;8080&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建./nginx/conf.d目录 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkdir -p ./nginx/conf.d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在./nginx/conf.d目录下 编写itheima.conf文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;server {
    listen 80;
    access_log off;
    location / {
        proxy_pass http://app:8080;
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打开 consul &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --name consul -d -p 8500:8500 -p 8600:8600/udp consul&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Nov 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/11/02/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/11/02/Docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
        
        <category>Docker</category>
        
        <category>redis</category>
        
        <category>mysql</category>
        
        <category>mongodb</category>
        
        <category>NoSql</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> Spring全家桶笔记01 基础知识和数据库 </title>
        <description>&lt;p&gt;React项目做到一半，实在是不想再去复现大段CSS代码，开始复习一下Java的Spring boot全家桶在极客时间上的课，毕竟不能靠着firebase过一辈子。所有的代码可以在&lt;a href=&quot;https://github.com/geektime-geekbang/geektime-spring-family&quot; target=&quot;_blank&quot;&gt;github仓库&lt;/a&gt;上找到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;写在前面： 插件安装lombok，在本地启动docker环境在redis和MongoDB时会比较简单。&lt;/em&gt;&lt;/strong&gt;
需要预先了解的知识： java8中的lambda和stream
例如对以下代码的解读&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private String getJoinedOrderId(List&amp;lt;CoffeeOrder&amp;gt; list) {
		return list.stream().map(o -&amp;gt; o.getId().toString())
				.collect(Collectors.joining(&quot;,&quot;));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在list这个表中形成stream类型为集合创建串行流，map 方法用于映射每个元素到对应的结果；Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串，在这里是对字符串做拼接。&lt;/p&gt;

&lt;h1 id=&quot;chapter1&quot;&gt;Chapter1&lt;/h1&gt;

&lt;h2 id=&quot;配置单源数据&quot;&gt;配置单源数据&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Spring 框架的基本配置是可以通过 https://start.spring.io/ 这个网页帮助自动配置的。&lt;/li&gt;
  &lt;li&gt;数据的启动方式是通过在这个界面勾选依赖，实现自动配置。&lt;/li&gt;
  &lt;li&gt;配置的演示：
    &lt;ul&gt;
      &lt;li&gt;引入对应数据库驱动 —H2&lt;/li&gt;
      &lt;li&gt;引入JDBC依赖 — spring-boot-starter-jdbc&lt;/li&gt;
      &lt;li&gt;获得DataSource Bean 打印信息&lt;/li&gt;
      &lt;li&gt;通过/acturator/beans 查看Bean&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring boot 根据数据源会自动配置数据库，对于所需要的Bean在不使用Springboot的情况下需要自己手写以下内容:
    &lt;ul&gt;
      &lt;li&gt;数据源相关Datasource 根据选择的连接池实现&lt;/li&gt;
      &lt;li&gt;事务相关&lt;/li&gt;
      &lt;li&gt;PlatformTransactionManager(DataSource TransactionManager)&lt;/li&gt;
      &lt;li&gt;Transaction Template&lt;/li&gt;
      &lt;li&gt;操作相关 JdbcTemplate&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据源相关配置属性
&lt;img src=&quot;/img/java-spring/spring-boot-chapter1-datasourcs.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;配置多源数据&quot;&gt;配置多源数据&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;配置数据源分开&lt;/li&gt;
  &lt;li&gt;关注每次使用的数据源
    &lt;ul&gt;
      &lt;li&gt;有多个DataSource时系统如何判断&lt;/li&gt;
      &lt;li&gt;对应的（事务，ORM）如何选择DataSource&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;和Spring Boot 协同工作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;配置@Primary类型的Bean&lt;/li&gt;
  &lt;li&gt;排除Spring Boot 自动配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;好用的数据连接池&quot;&gt;好用的数据连接池&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;HikariCP
HikariCP 来源于日本，高性能JDBC数据库连接池，tomcat在连接取放比较占有优势，使用了JavaAssist生成，是一种字节码级别的优势，同时有大量的小改进使用了FastStatementList 代替了 ArrayList, 无锁集合 ConcurrentBag以及代理类的优化，积少成多的优化。
怎样在代码中使用：
    &lt;ul&gt;
      &lt;li&gt;Spring Boot2.x中是默认使用HikariCP只要配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.hikari.*&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;在Spring Boot 1.x中默认是Tomcat 连接池，需要移除pom文件中 Tomcat-jdbc依赖，在Spring Boot的 application.properties当中配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.type=com.zaxxer.hikari.HikariDataSource&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在DataSourceConfiguration中是怎样配置的，源码中的实现方式是在上下文中配置了HikariDataSource而且上下文没有配置DataSource的Bean，而且Spring.datasource的属性配置的是Hikari，详细信息见
&lt;a href=&quot;https://github.com/brettwooldridge/HikariCP&quot; target=&quot;_blank&quot;&gt;HikariCP网址 &lt;/a&gt;
常用的HikariCP参数配置是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.datasource.hikari.maximumPoolSize=10
spring.datasource.hikari.minimumIdle=10
spring.datasource.hikari.idleTimeout=600000
spring.datasource.hikari.connectionTimeout=30000
spring.datasource.hikari.maxLifetime=1800000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Druid 是阿里巴巴
详细监控，Sql注入等&lt;a href=&quot;github.com/alibaba/druid&quot; target=&quot;_blank&quot;&gt;Druid官网&lt;/a&gt;文档齐全
扩展点很多。
    &lt;ul&gt;
      &lt;li&gt;使用方式：直接配置druid-spring-boot-starter&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;Filter 配置
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.datasource.druid.filters=stat,config,wall,log4j (全部使⽤用默认值)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;密码加密
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   spring.datasource.password=&amp;lt;加密密码&amp;gt; spring.datasource.druid.filter.config.enabled=true
   spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key=&amp;lt;public-key&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;SQL 防止注入
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   spring.datasource.druid.filter.wall.enabled=true spring.datasource.druid.filter.wall.db-type=h2 spring.datasource.druid.filter.wall.config.delete-allow=false spring.datasource.druid.filter.wall.config.drop-table-allow=false
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;对Druid 扩展点的补充，在Druid的扩展点中有大部分的是extend FilterEventAdapter实现的，在FilterEventAdapter中每一个方法的前后都定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_connectBefore()&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_connectBefore()&lt;/code&gt;两个方法在每次实际建连接的前和后都会实现这两个方法，在自己扩展时可以自己扩展这些方法。查看源码是一种责任链的方式实现的 &lt;strong&gt;注意，如果使用Druid作为连接池，一定要在pom文件中将Hikari排除，排除方式是:&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
  &amp;lt;exclusions&amp;gt;
    &amp;lt;exclusion&amp;gt;
      &amp;lt;artifactId&amp;gt;HikariCP&amp;lt;/artifactId&amp;gt;
      &amp;lt;groupId&amp;gt;com.zaxxer&amp;lt;/groupId&amp;gt;
    &amp;lt;/exclusion&amp;gt;
  &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时引入&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;对于druid的扩展&quot;&gt;对于Druid的扩展&lt;/h3&gt;
&lt;h4 id=&quot;慢sql配置找到执行比较慢的sql语句&quot;&gt;慢SQL配置：找到执行比较慢的SQL语句&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;系统属性配置(默认监控执行超过3秒的语句)：
    &lt;ul&gt;
      &lt;li&gt;druid.stat.logSlowSql=true&lt;/li&gt;
      &lt;li&gt;druid.stat.slowSqlMillis=3000&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spring Boot
    &lt;ul&gt;
      &lt;li&gt;spring.datasource.druid.filter.stat.enabled=true&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.filter.stat.log-slow-sql=true&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.filter.stat.slow-sql-millis=3000&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;演示慢SQL&lt;/strong&gt;
pom文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;exclusions&amp;gt;
  &amp;lt;exclusion&amp;gt;
    &amp;lt;artifactId&amp;gt;HikariCP&amp;lt;/artifactId&amp;gt;
    &amp;lt;groupId&amp;gt;com.zaxxer&amp;lt;/groupId&amp;gt;
  &amp;lt;/exclusion&amp;gt;
&amp;lt;/exclusions&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;
&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;schema.sql文件中插入FOO表，和一个记录&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64));
INSERT INTO FOO (ID, BAR) VALUES (1, 'AAA');
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在application.properties中配置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.druid.filter.stat.log-slow-sql=true&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.datasource.druid.filter.stat.slow-sql-millis=3000&lt;/code&gt;两个内容就会在terminal中知道哪里出了问题。&lt;/p&gt;

&lt;h4 id=&quot;druid一些注意事项&quot;&gt;Druid一些注意事项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;没特殊情况，不不要在⽣生产环境打开监控的 Servlet&lt;/li&gt;
  &lt;li&gt;没有连接泄露露可能的情况下，不要开启 removeAbandoned 对性能有影响&lt;/li&gt;
  &lt;li&gt;testXxx 的使⽤用需要注意
    &lt;ul&gt;
      &lt;li&gt;spring.datasource.druid.test-on-borrow=true在取连接的时候校验连接&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.test-on-return=true在放回连接的时候校验连接&lt;/li&gt;
      &lt;li&gt;spring.datasource.druid.test-while-idle=true在连接有一段时间不用时再去检查
建议使用test-while-idle毕竟每次检查开销会很大。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;务必配置合理理的超时时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;数据库连接池使用考量点：可靠性，性能，功能，可扩展性！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何通过spring-jdbc访问数据库&quot;&gt;如何通过Spring JDBC访问数据库&lt;/h2&gt;

&lt;h3 id=&quot;spring-jdbc操作类&quot;&gt;Spring Jdbc操作类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;core，JdbcTemplate 等相关核⼼心接⼝和类&lt;/li&gt;
  &lt;li&gt;datasource，数据源相关的辅助类&lt;/li&gt;
  &lt;li&gt;object，将基本的 JDBC 操作封装成对象&lt;/li&gt;
  &lt;li&gt;support，错误码等其他辅助⼯工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用的bean注解&quot;&gt;常用的Bean注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@Component 通用注解，用来定义通用的Bean&lt;/li&gt;
  &lt;li&gt;@Repository 如果是Dao数据操作的仓库&lt;/li&gt;
  &lt;li&gt;@Service 业务的服务&lt;/li&gt;
  &lt;li&gt;@Controller SpringMVC使用这个注解
    &lt;ul&gt;
      &lt;li&gt;@RestController Restful Service提供的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;简单的jdbc操作jdbctemplate&quot;&gt;简单的JDBC操作&lt;strong&gt;JdbcTemplate&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;query&lt;/li&gt;
  &lt;li&gt;queryForObject&lt;/li&gt;
  &lt;li&gt;queryForList&lt;/li&gt;
  &lt;li&gt;update&lt;/li&gt;
  &lt;li&gt;execute&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;例子讲解&quot;&gt;例子讲解&lt;/h3&gt;
&lt;p&gt;在geektime/spring/data/simplejdbcdemo/FooDao.java中可以看到实际的使用方式&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void insertData() {
  Arrays.asList(&quot;b&quot;, &quot;c&quot;).forEach(bar -&amp;gt; {
      jdbcTemplate.update(&quot;INSERT INTO FOO (BAR) VALUES (?)&quot;, bar);
  });

  HashMap&amp;lt;String, String&amp;gt; row = new HashMap&amp;lt;&amp;gt;();
  row.put(&quot;BAR&quot;, &quot;d&quot;);
  Number id = simpleJdbcInsert.executeAndReturnKey(row);
  log.info(&quot;ID of d: {}&quot;, id.longValue());
}

public void listData() {
  log.info(&quot;Count: {}&quot;,
          jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM FOO&quot;, Long.class));

  List&amp;lt;String&amp;gt; list = jdbcTemplate.queryForList(&quot;SELECT BAR FROM FOO&quot;, String.class);
  list.forEach(s -&amp;gt; log.info(&quot;Bar: {}&quot;, s));//取出对象 因为是单值用String就好

  List&amp;lt;Foo&amp;gt; fooList = jdbcTemplate.query(&quot;SELECT * FROM FOO&quot;, new RowMapper&amp;lt;Foo&amp;gt;() {
    //希望取出的是对象列表使用mapRow
      @Override
      public Foo mapRow(ResultSet rs, int rowNum) throws SQLException {
          return Foo.builder()
                  .id(rs.getLong(1))
                  .bar(rs.getString(2))
                  .build();
      }
  });
  fooList.forEach(f -&amp;gt; log.info(&quot;Foo: {}&quot;, f));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;ResultSet是专门针对数据库内容的数据类型，是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据的更新等。
以上代码中调用的getXXX方法可以实现数据的获取&lt;/li&gt;
  &lt;li&gt;如果想要取到对象列表使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RowMapper&amp;lt;Foo&amp;gt;()&lt;/code&gt;来实现&lt;/li&gt;
  &lt;li&gt;simpleJdbcTemplate是提供的一种辅助类，在运行代码中制定了
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
@Autowired
public SimpleJdbcInsert simpleJdbcInsert(JdbcTemplate jdbcTemplate) {
 return new SimpleJdbcInsert(jdbcTemplate)
         .withTableName(&quot;FOO&quot;).usingGeneratedKeyColumns(&quot;ID&quot;);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;表示指定了simpleJdbcInsert是和自定义的FOO表关联，这个表有一个生成的主键列名是ID，在DAO应用时是&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Number id = simpleJdbcInsert.executeAndReturnKey(row);
log.info(&quot;ID of d: {}&quot;, id.longValue());
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;取回插入时的主键。&lt;/p&gt;

&lt;h3 id=&quot;sql批处理20201027不是很懂&quot;&gt;SQL批处理（2020/10/27不是很懂）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JdbcTemplate&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;batchUpdate
    &lt;ul&gt;
      &lt;li&gt;BatchPreparedStatementSetter
&lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;batchUpdate
    &lt;ul&gt;
      &lt;li&gt;SqlParameterSourceUtils.createBatch&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;批处理样例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void batchInsert() {
  jdbcTemplate.batchUpdate(&quot;INSERT INTO FOO (BAR) VALUES (?)&quot;,
    new BatchPreparedStatementSetter() {
      @Override
      public void setValues(PreparedStatement ps, int i) throws SQLException {
          ps.setString(1, &quot;b-&quot; + i);
      }

      @Override
      public int getBatchSize() {
          return 2;
      }
  });

  List&amp;lt;Foo&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  list.add(Foo.builder().id(100L).bar(&quot;b-100&quot;).build());
  list.add(Foo.builder().id(101L).bar(&quot;b-101&quot;).build());
  namedParameterJdbcTemplate
    .batchUpdate(&quot;INSERT INTO FOO (ID, BAR) VALUES (:id, :bar)&quot;,
      SqlParameterSourceUtils.createBatch(list));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BatchPreparedStatementSetter&lt;/code&gt;应用类，每一次都给ps设置了不同值，注意在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;namedParameterJdbcTemplate&lt;/code&gt;中sql语句不是？而是名称&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:id等&lt;/code&gt;，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SqlParameterSourceUtils.createBatch&lt;/code&gt;对list中的值做映射&lt;/p&gt;

&lt;h2 id=&quot;spring-的事务抽象&quot;&gt;Spring 的事务抽象&lt;/h2&gt;
&lt;p&gt;一致的事务模型，首先要了解的就是事务抽象的核心接口。
&lt;img src=&quot;/img/java-spring/chapter1-transaction.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/java-spring/chapter1-transaction1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;request_new-和-nested&quot;&gt;REQUEST_NEW 和 NESTED&lt;/h3&gt;
&lt;p&gt;REQUEST_NEW: 始终启动一个新的事务，两个事务没有关联。
NESTED：在原事务内启动一个内嵌事务，两个事务有关联，外部事务回滚，内嵌事务也会回滚。
使用方式和测试两个是否会回滚的代码如下&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
@Transactional(rollbackFor = RollbackException.class, propagation = Propagation.REQUIRES_NEW)//可以写为NESTED
public void insertThenRollback() throws RollbackException {
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('BBB')&quot;);
    throw new RollbackException();
}

@Override
@Transactional(rollbackFor = RuntimeException.class)
public void invokeInsertThenRollback() {
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('AAA')&quot;);
    try {
        fooService.insertThenRollback();
    } catch (RollbackException e) {
        log.error(&quot;RollbackException&quot;, e);
    }
//        throw new RuntimeException();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;编程式事务-programatic-transaction&quot;&gt;编程式事务 Programatic Transaction&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;TransactionTemplate
    &lt;ul&gt;
      &lt;li&gt;TransactionCallback 事务有返回&lt;/li&gt;
      &lt;li&gt;TransactionCallbackWithoutResult 事务无返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用方式：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@SpringBootApplication
@Slf4j
public class ProgrammaticTransactionDemoApplication implements CommandLineRunner {
	@Autowired
	private TransactionTemplate transactionTemplate;
	@Autowired
	private JdbcTemplate jdbcTemplate;

	public static void main(String[] args) {
		SpringApplication.run(ProgrammaticTransactionDemoApplication.class, args);
	}

  @Override
    public void run(String... args) throws Exception {
      log.info(&quot;COUNT BEFORE TRANSACTION: {}&quot;, getCount());
      transactionTemplate.execute(new TransactionCallbackWithoutResult() { //没有返回值
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
          jdbcTemplate.execute(&quot;INSERT INTO FOO (ID, BAR) VALUES (1, 'aaa')&quot;);
          log.info(&quot;COUNT IN TRANSACTION: {}&quot;, getCount());
          transactionStatus.setRollbackOnly();
        }
      });
      log.info(&quot;COUNT AFTER TRANSACTION: {}&quot;, getCount());
    }

    private long getCount() {
      return (long) jdbcTemplate.queryForList(&quot;SELECT COUNT(*) AS CNT FROM FOO&quot;)
          .get(0).get(&quot;CNT&quot;);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在每次执行语句前获得count数，之后再执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setRollbackOnly&lt;/code&gt;表示只能回滚，这就是transactionTemplate的简单执行方式。
简单看transactionTemplate，继承 DefaultTransactionDefinition,其中execute方法会接受TransactionCallbackWithoutResult或者TransactionCallback&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PlatformTransactionManager
    &lt;ul&gt;
      &lt;li&gt;可以传⼊入TransactionDefinition进⾏行行定义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;申明式事务-declarative-transaction&quot;&gt;申明式事务 Declarative Transaction&lt;/h3&gt;

&lt;p&gt;基于注解的配置方式:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;开启事务注解的⽅方式
    &lt;ul&gt;
      &lt;li&gt;@EnableTransactionManagement  开启事务注解支持&lt;/li&gt;
      &lt;li&gt;
        &lt;tx:annotation-driven /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;一些配置
    &lt;ul&gt;
      &lt;li&gt;proxyTargetClass  当前的AOP是基于接口还是类&lt;/li&gt;
      &lt;li&gt;mode 对AOP mode选择&lt;/li&gt;
      &lt;li&gt;order 对事务AOP拦截顺序，默认是最低的优先级，自己的AOP拦截可以在事务启动后执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@Transactional 开启事务注解支持之后对其进行配置
    &lt;ul&gt;
      &lt;li&gt;transactionManager 一般是DatasourceTransactionManager&lt;/li&gt;
      &lt;li&gt;propagation 传播性&lt;/li&gt;
      &lt;li&gt;isolation 隔离型&lt;/li&gt;
      &lt;li&gt;timeout&lt;/li&gt;
      &lt;li&gt;readOnly&lt;/li&gt;
      &lt;li&gt;怎么判断回滚&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;案例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
@Transactional
public void insertRecord() {//使用事务性
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('AAA')&quot;);
}

@Override
@Transactional(rollbackFor = RollbackException.class)
public void insertThenRollback() throws RollbackException {//回滚
    jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES ('BBB')&quot;);
    throw new RollbackException();
}

@Override
public void invokeInsertThenRollback() throws RollbackException {// 调用了会回滚到方法，但是结果没有显示回滚
    insertThenRollback();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上案例的结果就是，在第三个方法中，类内部调用了代理的AOP所以不遵循事务性，虽然invokeInsertThenRollback调用了一个带有事务的方法，但是invokeInsertThenRollback本身没有事务在调用insertThenRollback没有事务的支持。&lt;/p&gt;
&lt;h4 id=&quot;事务的本质&quot;&gt;事务的本质&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Spring申明式事务本质上是通过AOP做了增强类功能&lt;/li&gt;
  &lt;li&gt;Spring的AOP本质上就是为类做了代理
    &lt;ul&gt;
      &lt;li&gt;看似在调用自己写的类，实际上是调用背后的增强类
以上问题的解决方法是访问增强之后的代理类方法，而非访问自身方法。
&lt;strong&gt;解决方案&lt;/strong&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Autowird FooService fooservice;//注入需要的service
...
@Override
public void invokeInsertThenRollback() throws RollbackException {// 调用了会回滚到方法
fooserivce.insertThenRollback();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;以上就可以使一个不带事务的执行方法执行事务性了&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;spring-jdbc异常的抽象&quot;&gt;Spring JDBC异常的抽象&lt;/h2&gt;
&lt;p&gt;Spring会将各种异常转换为DataAccessException,通过 SQLErrorCodeSQLExceptionTranslator 解析错误码&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ErrorCode 定义
    &lt;ul&gt;
      &lt;li&gt;org/springframework/jdbc/support/sql-error-codes.xml 看到主要的定义错误&lt;/li&gt;
      &lt;li&gt;Classpath 下的 sql-error-codes.xml自定义错误写在哪里&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自定义错误码（在resource文件夹下）：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;property name=&quot;customTranslations&quot;&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.jdbc.support.CustomSQLErrorCodesTranslation&quot;&amp;gt;
        &amp;lt;property name=&quot;errorCodes&quot; value=&quot;23001,23505&quot; /&amp;gt;
        &amp;lt;property name=&quot;exceptionClass&quot;
                  value=&quot;geektime.spring.data.errorcodedemo.CustomDuplicatedKeyException&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;自定义了错误实现的代码，以及发生错误的时候调用那个地方的错误处理模块&lt;/p&gt;

&lt;h3 id=&quot;第一章小结&quot;&gt;第一章小结&lt;/h3&gt;
&lt;h4 id=&quot;常用的注解&quot;&gt;常用的注解&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Java Config相关注解
    &lt;ul&gt;
      &lt;li&gt;@Configuration 表示是配置类&lt;/li&gt;
      &lt;li&gt;@ImportResource 表示xml配置文件&lt;/li&gt;
      &lt;li&gt;@ComponentScan 告知Spring容器去扫描哪些package下的bean这样的配置&lt;/li&gt;
      &lt;li&gt;@Bean 返回可以作为SpringApplicationContext中的Bean&lt;/li&gt;
      &lt;li&gt;@Configurationroperties 绑定配置，在Hikari中有使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;定义相关的注解
    &lt;ul&gt;
      &lt;li&gt;@Component/@Repository/@Service,所有的JavaBean 都可以通过@Component来定义，@Repository表示在数据访问层的Bean，@Service服务层的Bean&lt;/li&gt;
      &lt;li&gt;@Controller/@RestController表示web层的Bean,@
RestController是加上了ResponseBody加到@Controller上就是@RestController&lt;/li&gt;
      &lt;li&gt;@RequestMapping类下的方法是在哪些URL上做映射&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注入相关的注解
    &lt;ul&gt;
      &lt;li&gt;@Autowired上下文中多个类型的Bean查找注入&lt;/li&gt;
      &lt;li&gt;@Qualifier上下文中有多个同类型的Bean，Autowired会产生歧义&lt;/li&gt;
      &lt;li&gt;@Resource 根据名字进行注入&lt;/li&gt;
      &lt;li&gt;@Value在Bean中注入常量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;actuator实现的endpoint问题&quot;&gt;Actuator实现的endpoint问题&lt;/h4&gt;
&lt;p&gt;常用的endpoint
一般只发布了health和info如果想要看更多的endpoint需要配置，生产环境需谨慎。&lt;/p&gt;

&lt;p&gt;application.properties中写入
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;management.endpoints.web.exposure.include=*&lt;/code&gt;表示发布所有endpoint&lt;/p&gt;

&lt;h4 id=&quot;多数据源分库分表读写分离是什么关系&quot;&gt;多数据源，分库分表，读写分离是什么关系&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;系统需要访问完全不一样的数据库，&lt;/li&gt;
  &lt;li&gt;系统需要访问一个同一个库的主库（读写）和备库（读）&lt;/li&gt;
  &lt;li&gt;系统需要访问一个做了分库分表的数据库 &lt;strong&gt;使用数据库中间件帮助简化开发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;chapter2-or-mapping实践&quot;&gt;Chapter2 O/R Mapping实践&lt;/h1&gt;
&lt;h2 id=&quot;认识spring-data-jpa&quot;&gt;认识Spring Data JPA&lt;/h2&gt;
&lt;p&gt;对象和与关系之间的不匹配
&lt;img src=&quot;/img/java-spring/chapter2-unmatch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hibernate-和-jpa-java-persistence-api&quot;&gt;Hibernate 和 JPA (java persistence API)&lt;/h3&gt;
&lt;p&gt;JPA 为对象关系映射提供了一种基于POJO的持久化模型，在保留留底层存储特性的同时，提供相对⼀一致的、基于 Spring 的编程模型 主要模块。
Hibernate为JPA提供了一种操作方式。&lt;/p&gt;
&lt;h3 id=&quot;spring-data&quot;&gt;Spring Data&lt;/h3&gt;
&lt;p&gt;在主要的一层抽象中&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Data JPA&lt;/li&gt;
  &lt;li&gt;Spring Data MongoDb
…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;定义-jpa-实体对象&quot;&gt;定义 JPA 实体对象&lt;/h2&gt;
&lt;h3 id=&quot;常用-jpa-注解&quot;&gt;常⽤用 JPA 注解&lt;/h3&gt;
&lt;p&gt;实体&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Entity（表示为实体）、@MappedSuperclass（多个实体类，有父类）&lt;/li&gt;
  &lt;li&gt;@Table(name)（实体表关联）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主键&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Id
    &lt;ul&gt;
      &lt;li&gt;@GeneratedValue(strategy, generator) 自增策略
&lt;strong&gt;JPA提供的四种标准用法为TABLE，SEQUENCE，IDENTITY，AUTO。&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;TABLE：使用一个特定的数据库表格来保存主键。&lt;/li&gt;
          &lt;li&gt;SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。&lt;/li&gt;
          &lt;li&gt;IDENTITY：主键由数据库自动生成（主要是自动增长型）&lt;/li&gt;
          &lt;li&gt;AUTO：主键由程序控制。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;@SequenceGenerator(name, sequenceName) 序列化自增是怎样自增&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;映射&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Column(name, nullable, length, insertable, updatable)定义属性和表可以通过name改名字，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertable&lt;/code&gt;只能在插入时一次性插入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updatable&lt;/code&gt;能够更新&lt;/li&gt;
  &lt;li&gt;@JoinTable(name)、@JoinColumn(name)关联时候实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@OneToOne、@OneToMany、 @ManyToOne、@ManyToMany&lt;/li&gt;
  &lt;li&gt;@OrderBy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/aishangtaxuefeihong/p/6580630.html&quot; target=&quot;_blank&quot;&gt;Hibernate的一些用法&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;project-lombok&quot;&gt;Project Lombok&lt;/h3&gt;

&lt;p&gt;Project Lombok 能够⾃自动嵌⼊入 IDE 和构建⼯工具，提升开发效率
常⽤用功能&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Getter / @Setter 写get set方法&lt;/li&gt;
  &lt;li&gt;@ToString 写toString&lt;/li&gt;
  &lt;li&gt;@NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor 构造方法相关&lt;/li&gt;
  &lt;li&gt;@Data 混合注解 get set 和toString&lt;/li&gt;
  &lt;li&gt;@Builder 生成builder方法&lt;/li&gt;
  &lt;li&gt;@Slf4j / @CommonsLog / @Log4j2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线上咖啡馆实战项目&quot;&gt;线上咖啡馆实战项目&lt;/h2&gt;
&lt;p&gt;数据库相关&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将菜单放入缓存中redis&lt;/li&gt;
  &lt;li&gt;waiter和barista（咖啡师）做交互rabitMQ
&lt;img src=&quot;/img/java-spring/chapter2-logic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实体关系
&lt;img src=&quot;/img/java-spring/chapter2-entity.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;订单状态，已支付但是还没有开始制作可以取消掉订单，没支付也可以取消掉订单。&lt;/p&gt;

&lt;h3 id=&quot;pom文件&quot;&gt;pom文件&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.joda&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;joda-money&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.jadira.usertype&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;usertype.core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;6.0.1.GA&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;实体类定义&quot;&gt;实体类定义&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;菜单&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_MENU&quot;)
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Coffee implements Serializable {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    @Column
    @Type(type = &quot;org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyAmount&quot;,
            parameters = {@org.hibernate.annotations.Parameter(name = &quot;currencyCode&quot;, value = &quot;CNY&quot;)})
    private Money price;
    @Column(updatable = false)
    @CreationTimestamp
    private Date createTime;
    @UpdateTimestamp
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主键是id，但是注意price上加上了Type表示用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentMoneyAmount&lt;/code&gt;做映射，里面有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currencyCode&lt;/code&gt;指定是人民币；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@CreationTimestamp&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@UpdateTimestamp&lt;/code&gt;在createTime上表明是不能修改的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@org.hibernate.annotations.Parameter&lt;/code&gt;是一个Parameter对象是对内容的一种包装，其中要包括String类型的name和value，这是对传入的@Type映射的参数名的显示
&lt;strong&gt;在java中有专门的joda money包来对金钱类做处理，在处理金额方面时要小心&lt;/strong&gt;一般的money类会被映射为decimal类型。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentMoneyAmount&lt;/code&gt;中包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentMoneyMinorAmount&lt;/code&gt;在数据存储时不会变为decimal而是bigint同时，数据由100.43变为10043&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;订单表&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_ORDER&quot;)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CoffeeOrder implements Serializable {
    @Id
    @GeneratedValue
    private Long id;
    private String customer;
    @ManyToMany
    @JoinTable(name = &quot;T_ORDER_COFFEE&quot;)
    private List&amp;lt;Coffee&amp;gt; items;
    @Column(nullable = false)
    private Integer state;
    @Column(updatable = false)
    @CreationTimestamp
    private Date createTime;
    @UpdateTimestamp
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个表中使用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ManyToMany&lt;/code&gt;表示是多对多，咖啡和订单的关系是通过T_ORDER_COFFEE映射表实现的&lt;/p&gt;

&lt;p&gt;创建父类标签MappedSuperClass因为会有重复定义的模块例如时间和id等，使用MappedSuperClass和各个实体搭配的使用。&lt;/p&gt;

&lt;p&gt;BaseEntity作为父类&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@MappedSuperclass
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BaseEntity implements Serializable {
    @Id
    @GeneratedValue
    private Long id;
    @Column(updatable = false)
    @CreationTimestamp
    private Date createTime;
    @UpdateTimestamp
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子类的coffee表&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_MENU&quot;)
@Builder
@Data
@ToString(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class Coffee extends BaseEntity implements Serializable {
    private String name;
    @Type(type = &quot;org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyAmount&quot;,// 做映射
            parameters = {@org.hibernate.annotations.Parameter(name = &quot;currencyCode&quot;, value = &quot;CNY&quot;)})
    private Money price;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;需要注意，在子类的属性定义中如果使用toString时只会有当前的属性需要额外加上@ToString(callSuper=true)&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;在entity中使用枚举&quot;&gt;在entity中使用枚举&lt;/h4&gt;
&lt;p&gt;在订单表中使用枚举&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Entity
@Table(name = &quot;T_ORDER&quot;)
@Data
@ToString(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CoffeeOrder extends BaseEntity implements Serializable {
    private String customer;
    @ManyToMany
    @JoinTable(name = &quot;T_ORDER_COFFEE&quot;)
    @OrderBy(&quot;id&quot;)
    private List&amp;lt;Coffee&amp;gt; items;//设置list是一个顾客会点多个订单
    @Enumerated
    @Column(nullable = false)
    private OrderState state;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;枚举的使用是在OrderState这个地方，另外定义了一个枚举java文件显示了订单的不同状态，但是在数据库中是以数字形式存在的&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enumerated&lt;/code&gt;在hibernate都是把Enum类型的字段映射成基本类型的字段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.jpa.hibernate.ddl-auto=create-drop //每次运行时创建表结构 结束删除
spring.jpa.properties.hibernate.show_sql=true //打印每一条的SQL
spring.jpa.properties.hibernate.format_sql=true // 格式化输出
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Hibernate表结构创建，原先是用schema.sql帮助创建，现在使用Hibernate，这样的好处是不论什么类型的数据库都可以创建&lt;/p&gt;

&lt;h2 id=&quot;通过spring-date-jpa操作数据库&quot;&gt;通过Spring Date JPA操作数据库&lt;/h2&gt;
&lt;p&gt;通过Repository定义一个interface不需要实现，在Java Config上加上@EnableJpaRepostory注解&lt;/p&gt;
&lt;h3 id=&quot;repositoryt-id-接指定实体对象和id&quot;&gt;Repository&amp;lt;T, ID&amp;gt; 接⼝指定实体对象和id&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CrudRepository&amp;lt;T, ID&amp;gt;  基本接口，后面两个都是继承子结构&lt;/li&gt;
  &lt;li&gt;PagingAndSortingRepository&amp;lt;T, ID&amp;gt;&lt;/li&gt;
  &lt;li&gt;JpaRepository&amp;lt;T, ID&amp;gt;扩展了PagingAndSortingRepository加上了findAll等方法，同时extends了QueryByExampleExecutor作为一个Example&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;定义查询&quot;&gt;定义查询&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;find…By… / read…By… / query…By… / get…By…&lt;/li&gt;
  &lt;li&gt;count…By…&lt;/li&gt;
  &lt;li&gt;…OrderBy…[Asc / Desc]&lt;/li&gt;
  &lt;li&gt;And / Or / IgnoreCase&lt;/li&gt;
  &lt;li&gt;Top / First / Distinct&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;分页查询&quot;&gt;分页查询&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;PagingAndSortingRepository&amp;lt;T, ID&amp;gt;&lt;/li&gt;
  &lt;li&gt;Pageable / Sort&lt;/li&gt;
  &lt;li&gt;Slice&lt;T&gt; / Page&lt;T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crud&quot;&gt;CRUD&lt;/h3&gt;
&lt;h4 id=&quot;保存实体&quot;&gt;保存实体&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Coffee latte = Coffee.builder().name(&quot;latte&quot;)
				.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0))
				.build();
coffeeRepository.save(latte);
log.info(&quot;Coffee: {}&quot;, latte);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;coffee表中利用lombok的builder创建的builder对象，指定名字为latte，指定Money类型是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Money.of&lt;/code&gt;，指定了是人民币的30.0，通过builder的build()方法就能创建实例。通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coffeeRepository.save(latte)&lt;/code&gt;就能保存。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CoffeeOrder order = CoffeeOrder.builder()
				.customer(&quot;Li Lei&quot;)
				.items(Collections.singletonList(espresso))
				.state(OrderState.INIT)
				.build();
orderRepository.save(order);
log.info(&quot;Order: {}&quot;, order);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;items在表定义中就是出入list。&lt;/p&gt;
&lt;h4 id=&quot;查询实体&quot;&gt;查询实体&lt;/h4&gt;
&lt;p&gt;创建一个BaseRepository，通用repostory：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@NoRepositoryBean//说明这个baseRepository 不需要加入Bean
public interface BaseRepository&amp;lt;T, Long&amp;gt; extends PagingAndSortingRepository&amp;lt;T, Long&amp;gt; {
    List&amp;lt;T&amp;gt; findTop3ByOrderByUpdateTimeDescIdAsc();//有第一个By 一定要加
    //按照updateTime是降序排序，按照id升序
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;@NoRepositoryBean//说明这个baseRepository 不需要加入Bean&lt;/strong&gt;
为什么&lt;strong&gt;findTop3ByOrderByUpdateTimeDescIdAsc&lt;/strong&gt;中要加上findTop3By，虽然没有传入方法但是一定要传入By进去！！！
子Repository继承格式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public interface CoffeeOrderRepository extends BaseRepository&amp;lt;CoffeeOrder, Long&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;repostory是怎样从接口-变成bean的&quot;&gt;Repostory是怎样从接口 变成Bean的&lt;/h3&gt;
&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;通过mybatis操作数据库&quot;&gt;通过Mybatis操作数据库&lt;/h2&gt;
&lt;p&gt;强调sql映射关系，什么时候使用Mybatis？
当sql语句比较复杂使用Mybatis，因为Mybatis是直接写入SQL语句的。
Mybatis官方支持&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;config
    &lt;ul&gt;
      &lt;li&gt;mybatis.mapper-locations = classpath&lt;em&gt;:mapper/**/&lt;/em&gt;.xml 在所有classpath目录下所有的xml文件都是mybatis映射文件&lt;/li&gt;
      &lt;li&gt;mybatis.type-aliases-package = 类型别名的包名&lt;/li&gt;
      &lt;li&gt;mybatis.type-handlers-package = TypeHandler扫描包名 类型转换时的辅助类，是类型转换的前缀&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mybatis.type-handlers-package=geektime.spring.data.mybatisdemo.handler&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;mybatis.configuration.map-underscore-to-camel-case = true 下划线转驼峰&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mapper 的定义与扫描
    &lt;ul&gt;
      &lt;li&gt;@MapperScan 配置扫描位置&lt;/li&gt;
      &lt;li&gt;@Mapper 定义接⼝&lt;/li&gt;
      &lt;li&gt;映射的定义—— XML 与注解&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mybatis基本用法&quot;&gt;Mybatis基本用法&lt;/h3&gt;
&lt;p&gt;MoneyTypeHandler对Money类型和Long之间做转换，&lt;strong&gt;注意要继承BaseTypeHandler接口&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Override
public void setNonNullParameter(PreparedStatement ps, int i, Money parameter, JdbcType jdbcType) throws SQLException {
    ps.setLong(i, parameter.getAmountMinorLong());// 防止数据库注入  PreparedStatement 数据库中存储的是bigint类型 在此处转换为minorlong
}

@Override
public Money getNullableResult(ResultSet rs, String columnName) throws SQLException {//从数据库中取数据 利用ResultSet类型取
    return parseMoney(rs.getLong(columnName));
}

@Override
public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return parseMoney(rs.getLong(columnIndex));
}

@Override
public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return parseMoney(cs.getLong(columnIndex));
}
// 获得金额 转换为Money类型
private Money parseMoney(Long value) {
    return Money.of(CurrencyUnit.of(&quot;CNY&quot;), value / 100.0);
}//of 指定人民币类型
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主程序中的代码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MapperScan(&quot;geektime.spring.data.mybatisdemo.mapper&quot;)// 扫描mapper映射&lt;/code&gt;对应的是一个Mapper&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Mapper // @MapperScan 定义到此处
public interface CoffeeMapper {
    @Insert(&quot;insert into t_coffee (name, price, create_time, update_time)&quot;
            + &quot;values (#{name}, #{price}, now(), now())&quot;)
    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)
      // Save 1 Coffee: Coffee(id=1, name=espresso, price=CNY 20.00, createTime=null, updateTime=null)
    int save(Coffee coffee);// 返回影响的条数 而不是其他

    @Select(&quot;select * from t_coffee where id = #{id}&quot;)
    @Results({
            @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;),
            @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),
            // map-underscore-to-camel-case = true 可以实现一样的效果
            // @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;),
    })
    Coffee findById(@Param(&quot;id&quot;) Long id);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中定义了save 和findById方法，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;@Option 设置自增主键&lt;/li&gt;
  &lt;li&gt;@Insert @Update @Delete方法返回的都是受更新的影响条数&lt;/li&gt;
  &lt;li&gt;@Param 对@Select 语句中的传入名#{id}赋值&lt;/li&gt;
  &lt;li&gt;@Results 结果集映射 id指定的column是id，id=true说明是主键；property是下划线到驼峰的映射，因为在定义的modal中就是驼峰的但是实际的数据库中使用的是下划线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主程序：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@MapperScan(&quot;geektime.spring.data.mybatisdemo.mapper&quot;)// 扫描mapper映射
public class MybatisDemoApplication implements ApplicationRunner {
	@Autowired
	private CoffeeMapper coffeeMapper;
	public static void main(String[] args) {
		SpringApplication.run(MybatisDemoApplication.class, args);
	}
	@Override
	public void run(ApplicationArguments args) throws Exception {
		Coffee c = Coffee.builder().name(&quot;espresso&quot;)
				.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)).build();
		int count = coffeeMapper.save(c);
		log.info(&quot;Save {} Coffee: {}&quot;, count, c);

		c = Coffee.builder().name(&quot;latte&quot;)
				.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.0)).build();
		count = coffeeMapper.save(c);
		log.info(&quot;Save {} Coffee: {}&quot;, count, c);
//		c = Coffee.builder().name(&quot;sd&quot;).price(Money.of(CurrencyUnit.of))

		c = coffeeMapper.findById(c.getId());
		log.info(&quot;Find Coffee: {}&quot;, c);
	}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上程序定义了在数据库中insert两个，再通过id取出数据，insert的时候没有写时间但是可以在获得数据的时候看到时间因为这两个是数据库自动写入的。&lt;/p&gt;

&lt;h3 id=&quot;让mybatis更好用的工具&quot;&gt;让Mybatis更好用的工具&lt;/h3&gt;
&lt;h4 id=&quot;mybatis-generator&quot;&gt;Mybatis Generator&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://mybatis.org/generator/quickstart.html&quot; target=&quot;_blank&quot;&gt;详细介绍&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;怎样运行mybatis-generator&quot;&gt;怎样运行Mybatis Generator？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;命令行：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java -jar mybatis-generator-core-x.x.x.jar -configfile generatorConfig.xml&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Maven Plugin(mybatis-generator-maven-plugin)：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mvn mybatis-generator:generate&lt;/code&gt;或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${basedir}/src/main/resources/generatorConfig.xml&lt;/code&gt;
    &lt;h5 id=&quot;配置-mybatis-generator&quot;&gt;配置 MyBatis Generator&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;jdbcConnection&lt;/li&gt;
  &lt;li&gt;javaModelGenerator&lt;/li&gt;
  &lt;li&gt;sqlMapGenerator&lt;/li&gt;
  &lt;li&gt;javaClientGenerator (ANNOTATEDMAPPER / XMLMAPPER / MIXEDMAPPER)&lt;/li&gt;
  &lt;li&gt;table&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;生成时可以使用的插件类似于lombok&quot;&gt;生成时可以使用的插件（类似于Lombok）&lt;/h5&gt;
&lt;p&gt;内置插件都在 org.mybatis.generator.plugins 包中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FluentBuilderMethodsPlugin&lt;/li&gt;
  &lt;li&gt;ToStringPlugin&lt;/li&gt;
  &lt;li&gt;SerializablePlugin&lt;/li&gt;
  &lt;li&gt;RowBoundsPlugin&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;使用生成的对象&quot;&gt;使用生成的对象&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;简单操作，直接使⽤⽣成的 xxxMapper 的⽅方法&lt;/li&gt;
  &lt;li&gt;复杂查询，使⽤⽣成的 xxxExample 对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;使用样例&quot;&gt;使用样例&lt;/h5&gt;
&lt;p&gt;pom&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.3.7&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;详见21，主要是通过xml文件帮助写入的。&lt;/p&gt;

&lt;h3 id=&quot;mybatis生成工具pagehelper&quot;&gt;mybatis生成工具PageHelper&lt;/h3&gt;
&lt;p&gt;支持多种数据库分页
详细使用见官网&lt;a href=&quot;https://pagehelper.github.io/&quot; target=&quot;_blank&quot;&gt;PageHelper&lt;/a&gt;
很详细的页面信息的取得！&lt;/p&gt;

&lt;h3 id=&quot;springbuck项目进度&quot;&gt;SpringBuck项目进度&lt;/h3&gt;
&lt;p&gt;通过JPA来实现数据加载&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先了解Example的使用
Example表示在数据使用时对查找的精确匹配程度，是一种模糊查询器。
使用格式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public Optional&amp;lt;Coffee&amp;gt; findOneCoffee(String name) {
    ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher(&quot;name&quot;, exact().ignoreCase());
    Optional&amp;lt;Coffee&amp;gt; coffee = coffeeRepository.findOne(
            Example.of(Coffee.builder().name(name).build(), matcher));
    log.info(&quot;Coffee Found: {}&quot;, coffee);
    return coffee;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到模糊查询的格式是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Example.of(probe, match)&lt;/code&gt;其中probe是实体类，包含用于查询的参数，另一个matcher是比对规则，用于设置比对语句。看到里面的ExampleMatcher使用对象首先实例化&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExampleMatcher matcher = ExampleMatcher.matchig()&lt;/code&gt;具体化怎样查询&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.withMatcher(&quot;name&quot;, exact().ignoreCase()&lt;/code&gt;在name这个property，是精确查询，忽略大小写。&lt;/p&gt;

&lt;p&gt;调用coffeeRepos的findOne方法需要一个Example对象和一个matcher。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在主程序中要保证coffee订单状态是只能从INIT到PAID不能反向。&lt;/strong&gt;
案例中返回的是Optioal主要是为了解决空指针异常，Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;/p&gt;

&lt;h1 id=&quot;chapter3-nosql实践&quot;&gt;Chapter3 NoSql实践&lt;/h1&gt;

&lt;h2 id=&quot;docker开发容器不包括操作系统的细节所以比虚拟机轻量&quot;&gt;docker开发，容器不包括操作系统的细节所以比虚拟机轻量。&lt;/h2&gt;

&lt;p&gt;Docker 使用详见docker使用教程中MongoDB的启动方法&lt;/p&gt;

&lt;h2 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h2&gt;

&lt;h3 id=&quot;mongodbtemplate&quot;&gt;MongoDBTemplate&lt;/h3&gt;

&lt;p&gt;类似于JDBCTemplate Spring Data 提供了MongoDB一套抽象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Spring Data MongoDB
    &lt;ul&gt;
      &lt;li&gt;MongoTemplate&lt;/li&gt;
      &lt;li&gt;Repository 支持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注解
    &lt;ul&gt;
      &lt;li&gt;@Document 对应标定哪个文档&lt;/li&gt;
      &lt;li&gt;@Id&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MongoTemplate
    &lt;ul&gt;
      &lt;li&gt;save / remove&lt;/li&gt;
      &lt;li&gt;Criteria / Query / Update&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在terminal中&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查看有什么数据库&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show dbs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建一个MongoDB的库&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use springbucks&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建有读写权限的⽤户&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;db.createUser(
    {
      user: &quot;springbucks&quot;,
      pwd: &quot;springbucks&quot;,
      roles: [
         { role: &quot;readWrite&quot;, db: &quot;springbucks&quot; }
      ]
} )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看用户&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show users&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;在modal中的定义&quot;&gt;在modal中的定义&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Document//标记为文档
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Coffee {
    @Id //这里的Id是import org.springframework.data.annotation.Id;和JPA区分
    private String id;
    private String name;
    private Money price;
    private Date createTime;
    private Date updateTime;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;applicationproperties配置&quot;&gt;application.properties配置&lt;/h3&gt;

&lt;p&gt;定义怎样连接MongoDB&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spring.data.mongodb.uri=mongodb://springbucks:springbucks@localhost:27017/springbucks&lt;/code&gt;
这个uri的含义是：用到哪个库，用户名密码都是springbucks，访问的是27017的端口使用的是springbucks的库。&lt;/p&gt;

&lt;h3 id=&quot;配置数据类型转换&quot;&gt;配置数据类型转换&lt;/h3&gt;
&lt;p&gt;之前在Mybatis中定义了TypeHandler在MongoDB中同样需要定义Document数据怎样存储Money数据的一种转换，这里使用了MoneyConverter，查看源码，只需要自己定义一个MongoCustomConversions就能在MongoTemplate中使用。
这里定义了一个MoneyReadConverter作用是将document转换为Money对象，在主程序中自定义了一个Bean将这个自定义Converter以列表形式加入。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public MongoCustomConversions mongoCustomConversions() {
  return new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详细的MoneyReadConverter是&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import org.bson.Document;
import org.joda.money.CurrencyUnit;
import org.joda.money.Money;
import org.springframework.core.convert.converter.Converter;

public class MoneyReadConverter implements Converter&amp;lt;Document, Money&amp;gt; {
    @Override
    public Money convert(Document source) {
        Document money = (Document) source.get(&quot;money&quot;);
        double amount = Double.parseDouble(money.getString(&quot;amount&quot;));
        String currency = ((Document) money.get(&quot;currency&quot;)).getString(&quot;code&quot;);
        return Money.of(CurrencyUnit.of(currency), amount);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Document中获得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Money price&lt;/code&gt;，获得amount，之后获得currency来拼接一个Money对象。这里为什么没有从money到document转换，是因为在序列化时会自动将money对象转化为类似json的bson格式。&lt;/p&gt;

&lt;p&gt;主程序中定义查询条件：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;List&amp;lt;Coffee&amp;gt; list = mongoTemplate.find(
    Query.query(Criteria.where(&quot;name&quot;).is(&quot;espresso&quot;)), Coffee.class);
log.info(&quot;Find {} Coffee&quot;, list.size());
list.forEach(c -&amp;gt; log.info(&quot;Coffee {}&quot;, c));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongoTemplate&lt;/code&gt;提供了很多增删改查的方法，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Query.query&lt;/code&gt;用来创建查询，其后可以使用limit和skip等关键字表示限制多少记录和跳过多少记录,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Criteria&lt;/code&gt;定义查询语句，其中可以使用byExample等方法，模糊查询。&lt;/p&gt;

&lt;p&gt;主程序中定义更新操作：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;pdateResult result = mongoTemplate.updateFirst(query(where(&quot;name&quot;).is(&quot;espresso&quot;)),
    new Update().set(&quot;price&quot;, Money.ofMajor(CurrencyUnit.of(&quot;CNY&quot;), 30))
        .currentDate(&quot;updateTime&quot;),
    Coffee.class);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要一个Update对象并设置对象的新值，&lt;strong&gt;注意一定要设置更新时间&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;mongodb-repostory&quot;&gt;MongoDB Repostory&lt;/h3&gt;
&lt;p&gt;pom文件一样，但是主程序上加上了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableMongoRepositories&lt;/code&gt;
之前定义的更新等操作都可以通过Repostory来实现&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;latte.setPrice(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 35.0));
		latte.setUpdateTime(new Date());
		coffeeRepository.save(latte);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对比之前的Update省力&lt;/p&gt;

&lt;h2 id=&quot;redis&quot;&gt;Redis&lt;/h2&gt;
&lt;p&gt;Spring对Redis的支持，通过Spring Data Redis，支持的客户端是Jedis,RedisTemplate和 Repository支持。作为非持久化的存储，可丢失可从数据库中再拿出来。&lt;/p&gt;

&lt;h3 id=&quot;jedis客户端使用事项&quot;&gt;Jedis客户端使用事项&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Jedis 不不是线程安全的&lt;/li&gt;
  &lt;li&gt;通过 JedisPool 获得 Jedis 实例&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接使⽤用 Jedis 中的方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;将所有以redis打头的属性赋值给JedisPoolConfig&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
@ConfigurationProperties(&quot;redis&quot;)
public JedisPoolConfig jedisPoolConfig() {
  return new JedisPoolConfig();
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;JedisPool的构造方法构造一个JedisPool，destroyMethod表示在关闭这个Bean时去调用close方法，数据不用的时候就将其放到池中，关闭连接但是保留操作。通过@Value输入目标Jedis需要连接的一个host&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean(destroyMethod = &quot;close&quot;)
public JedisPool jedisPool(@Value(&quot;${redis.host}&quot;) String host) {
  return new JedisPool(jedisPoolConfig(), host);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在pom文件中传入需要的redis客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在application.property中配置redis&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;redis.host=localhost
redis.maxTotal=5
redis.maxIdle=5
redis.testOnBorrow=true

#redis.max-total=3
#redis.max-idle=3
#redis.test-on-borrow=true
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意这里的max-total 和 maxTotal含义是相同的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在主程序中
使用java中的try-with-resource&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;try (Jedis jedis = jedisPool.getResource()) {
  coffeeService.findAllCoffee().forEach(c -&amp;gt; {
    jedis.hset(&quot;springbucks-menu&quot;,
        c.getName(),
        Long.toString(c.getPrice().getAmountMinorLong()));
  });

  Map&amp;lt;String, String&amp;gt; menu = jedis.hgetAll(&quot;springbucks-menu&quot;);
  log.info(&quot;Menu: {}&quot;, menu);

  String price = jedis.hget(&quot;springbucks-menu&quot;, &quot;espresso&quot;);
  log.info(&quot;espresso - {}&quot;,
      Money.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(price)));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在jedisPool中取到一个jedis实例，不用自己做jedis close 在try结束之后java会帮助关闭。通过jpa的coffeeService获得所有coffee的名字和minorAmount放入到springbucks-menu的一个hash中，hash的key是name，value是金额；通过jedis的hgetAll取出springbucks-menu。用hget取得一个金额找到key为espresso的value再将这个value 转换为money&lt;/p&gt;

&lt;h3 id=&quot;redis-部署模式&quot;&gt;redis 部署模式&lt;/h3&gt;

&lt;h4 id=&quot;哨兵sentine&quot;&gt;哨兵Sentine&lt;/h4&gt;

&lt;p&gt;监控，通知和故障迁移，使用JedisSentinePool&lt;/p&gt;

&lt;h4 id=&quot;集群cluster&quot;&gt;集群Cluster&lt;/h4&gt;

&lt;p&gt;redis Cluster 自动做了数据的分片，所以在部分节点失效的时候还是有可用性的，在单节点也就是没有集群的redis上可以对key进行批量操作，但是在Cluster上就无法做，因为key会分散在不同的集群中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JedisCluster&lt;/strong&gt;
Jedis只能从master读取数据，如果想要读写分离可以定制&lt;/p&gt;

&lt;p&gt;实际案例：
JedisCluster继承BinaryJedisCluster，传入jedis的节点列表通过构造方法创建&lt;/p&gt;

&lt;p&gt;看redis的cluster&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;spring的缓存抽象&quot;&gt;Spring的缓存抽象&lt;/h2&gt;
&lt;p&gt;为不同的缓存提供一层抽象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;为java方法增加缓存，缓存结果执行&lt;/li&gt;
  &lt;li&gt;支持不同的缓存后端ConcurrentMap、EhCache、Caffeine、JCache(JSR-107)&lt;/li&gt;
  &lt;li&gt;接口 org.springframework.cache.Cache，org.springframework.cache.CacheManager&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不同类型缓存使用场景&quot;&gt;不同类型缓存使用场景&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;长久不变的信息（一天都不会变的）接收一定延迟性：界面内部缓存，设置过期时间，自动过期之后再去后端获得。&lt;/li&gt;
  &lt;li&gt;在集群内部要求一致性：分布式缓存 例如redis&lt;/li&gt;
  &lt;li&gt;数据读写比不好（写一次，读一次）： 没必要缓存只有在写一次读10次这样的使用缓存比较好&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于缓存抽象的注解&quot;&gt;基于缓存抽象的注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;@EnableCaching开启注解
    &lt;ul&gt;
      &lt;li&gt;@Cacheable 如果方法已经在缓存中就直接去取，如果不在里面就去执行，在执行之后将结果放入缓存&lt;/li&gt;
      &lt;li&gt;@CacheEvict 缓存清理&lt;/li&gt;
      &lt;li&gt;@CachePut 不管方法的执行情况，直接去做缓存的设置&lt;/li&gt;
      &lt;li&gt;@Caching 对以上的内容进行打包，在里面放入多个操作&lt;/li&gt;
      &lt;li&gt;@CacheConfig 对缓存进行设置，缓存名etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;缓存抽象在界面中做缓存的例子&quot;&gt;缓存抽象在界面中做缓存的例子&lt;/h3&gt;
&lt;p&gt;相对于redis缓存这里的界面缓存提供了另一种缓存方式&lt;/p&gt;

&lt;p&gt;在service中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Slf4j
@Service
@CacheConfig(cacheNames = &quot;coffee&quot;)//设置缓存名
public class CoffeeService {
  @Autowired
  private CoffeeRepository coffeeRepository;

  @Cacheable
  public List&amp;lt;Coffee&amp;gt; findAllCoffee() {
      return coffeeRepository.findAll();
  }

  @CacheEvict
  public void reloadCoffee() {
  }
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码就是在征程使用findAllCoffee方法的时候使用缓存的形式。在主程序加载的时候加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableCaching(proxyTargetClass = true)&lt;/code&gt;拦截类的执行。这里说明缓存的加载机制是基于AOP的。&lt;/p&gt;

&lt;h3 id=&quot;缓存抽象以redis作为缓存的例子&quot;&gt;缓存抽象以redis作为缓存的例子&lt;/h3&gt;

&lt;p&gt;需要引入pom&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写入application.property&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.cache.type=redis
spring.cache.cache-names=coffee
spring.cache.redis.time-to-live=5000 # 缓存的ttl时间是5秒
spring.cache.redis.cache-null-values=false

spring.redis.host=localhost
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在具体的coffeeService上加上了cacheable注解，&lt;strong&gt;在具体的创建中在start.spring.io里面需要勾选cache的缓存抽象和Nonsql里面的redis来创建&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;spring-data-redis-实现细节&quot;&gt;Spring Data Redis 实现细节&lt;/h3&gt;

&lt;h4 id=&quot;配置连接工厂&quot;&gt;配置连接工厂&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RedisStandaloneConfiguration 单节点&lt;/li&gt;
  &lt;li&gt;RedisSentinelConfiguration 哨兵&lt;/li&gt;
  &lt;li&gt;RedisClusterConfiguration 集群&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要的配置信息是在RedisProperties对应的前缀 prefix 是Spring.redis，与jedis和lettse相关信息都在此处&lt;/p&gt;

&lt;h4 id=&quot;redistemplate&quot;&gt;RedisTemplate&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;设置过期时间&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RedisTemplate&amp;lt;K, V&amp;gt;
    &lt;ul&gt;
      &lt;li&gt;opsForXxx()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;StringRedisTemplate&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;样例&quot;&gt;样例&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;pom文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置application.properties&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;spring.redis.host=localhost
spring.redis.lettuce.pool.maxActive=5
spring.redis.lettuce.pool.maxIdle=5
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本地docker启动的redis，配置lettuce连接池。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在coffeeService里做了缓存的设置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redisTemplate.opsForHash&lt;/code&gt;到redis里面取到一个hash，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasKey&lt;/code&gt;查看里面有没有这个key也就是传入的name，如果有就获得这个缓存直接返回，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; return Optional.of(hashOperations.get(CACHE, name));&lt;/code&gt;，如果没有就通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; hashOperations.put(CACHE, name, coffee.get());&lt;/code&gt;将这个新的coffee查找出的对象放入缓存，之后再设置过期时间&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Autowired
private RedisTemplate&amp;lt;String, Coffee&amp;gt; redisTemplate;
...
public Optional&amp;lt;Coffee&amp;gt; findOneCoffee(String name) {
    HashOperations&amp;lt;String, String, Coffee&amp;gt; hashOperations = redisTemplate.opsForHash();
    if (redisTemplate.hasKey(CACHE) &amp;amp;&amp;amp; hashOperations.hasKey(CACHE, name)) {
        log.info(&quot;Get coffee {} from Redis.&quot;, name);
        return Optional.of(hashOperations.get(CACHE, name));
    }
    ExampleMatcher matcher = ExampleMatcher.matching()
            .withMatcher(&quot;name&quot;, exact().ignoreCase());
    Optional&amp;lt;Coffee&amp;gt; coffee = coffeeRepository.findOne(
            Example.of(Coffee.builder().name(name).build(), matcher));
    log.info(&quot;Coffee Found: {}&quot;, coffee);
    if (coffee.isPresent()) {
        log.info(&quot;Put coffee {} to Redis.&quot;, name);
        hashOperations.put(CACHE, name, coffee.get());
        redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);
    }
    return coffee;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在SpringBuckesApplication中设置的是实现方法
RedisTemplate 在SpringBoot中提供了一种Object类型的Template，需要自定义一个需要类型的Template&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public RedisTemplate&amp;lt;String, Coffee&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
  RedisTemplate&amp;lt;String, Coffee&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
  template.setConnectionFactory(redisConnectionFactory);
  return template;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的实现类只能是存入的需要序列化的内容，对于String类型有专门对stringRedisTemplate执行，但是对于其他的散列等类型需要加上Redis的序列化器来实现。在Redis里面就是字符串，需要美化&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@PostConstruct
public void init(){
  initRedisTemplate();
}
private void initRedisTemplate(){
  RedisSerializer stringSerializer = redisTemplate.getStringSerializer();
  redisTemplate.setKeySerializer(stringSerializer);
  redisTemplate.setHashKeySerializer(stringSerializer);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码是将键和散列数据类型的field修改为使用StringRedisSerializer序列化，在Redis服务器上得到的键值对和散列对象就是以字符串形式存储了。&lt;/p&gt;

&lt;h4 id=&quot;redis-repository&quot;&gt;Redis Repository&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;实体注解
    &lt;ul&gt;
      &lt;li&gt;@RedisHash&lt;/li&gt;
      &lt;li&gt;@Id&lt;/li&gt;
      &lt;li&gt;@Indexed 因为有key value属性需要加上二级索引&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;区分多个Repository
    &lt;ul&gt;
      &lt;li&gt;根据数据上的注解&lt;/li&gt;
      &lt;li&gt;根据继承接口的类型&lt;/li&gt;
      &lt;li&gt;扫描不同的包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对应实现中如果有不同类型，比如Money类型读入到Redis的Byte中，需要继承SpringBoot中的Converter接口，要自己写读写方法，在redis-repository-demo中对应配置了两个converter&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MoneyToBytesConverter 表示将Money转化为byte时往redis中写的时候用的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import org.joda.money.Money;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;

import java.nio.charset.StandardCharsets;

@WritingConverter
public class MoneyToBytesConverter implements Converter&amp;lt;Money, byte[]&amp;gt; {
    @Override
    public byte[] convert(Money source) {
        String value = Long.toString(source.getAmountMinorLong());
        return value.getBytes(StandardCharsets.UTF_8);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;BytesToMoneyConverter 注意注解是@ReadingConverter表示从Redis读的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import org.joda.money.CurrencyUnit;
import org.joda.money.Money;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;

import java.nio.charset.StandardCharsets;

@ReadingConverter
public class BytesToMoneyConverter implements Converter&amp;lt;byte[], Money&amp;gt; {
    @Override
    public Money convert(byte[] source) {
        String value = new String(source, StandardCharsets.UTF_8);
        return Money.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(value));
    }
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;主程序中实现的redis converter 的注册&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Bean
public RedisCustomConversions redisCustomConversions() {
  return new RedisCustomConversions(
      Arrays.asList(new MoneyToBytesConverter(), new BytesToMoneyConverter()));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些疑问&quot;&gt;一些疑问&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;为什么有了Redis Template 又要用 Redis Repository?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按ID存了一个数据到Redis里，但又希望能按别的维度来查询时，一种方式就是自己维护二级索引，而RedisRepository可以帮你做这个二级索引，让你根据自己需要来查询。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;redis哨兵和集群模式&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Redis sentinel&lt;/em&gt;&lt;/strong&gt; 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;监控（Monitoring）：Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。&lt;/p&gt;

&lt;p&gt;提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。&lt;/p&gt;

&lt;p&gt;自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;1、保证高可用&lt;/p&gt;

&lt;p&gt;2、监控各个节点&lt;/p&gt;

&lt;p&gt;3、自动故障迁移&lt;/p&gt;

&lt;p&gt;缺点：主从模式，切换需要时间丢数据&lt;/p&gt;

&lt;p&gt;没有解决 master 写的压力&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Redis cluster&lt;/em&gt;&lt;/strong&gt; 从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。&lt;/p&gt;

&lt;p&gt;2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。&lt;/p&gt;

&lt;p&gt;3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。&lt;/p&gt;

&lt;p&gt;4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本&lt;/p&gt;

&lt;p&gt;5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;1、资源隔离性较差，容易出现相互影响的情况。&lt;/p&gt;

&lt;p&gt;2、数据通过异步复制,不保证数据的强一致性&lt;/p&gt;

&lt;h4 id=&quot;一些注意细节&quot;&gt;一些注意细节&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;redis 一定要设计过期时间&lt;/li&gt;
  &lt;li&gt;redis的max-redirect最好是设置为3，设置最大的重定向次数的，RedisCluster里，你把请求发到了某个节点上，它发现这个KEY不在自己这里，就会告诉你重定向到另一个节点上去找。&lt;/li&gt;
  &lt;li&gt;总结一下 &lt;strong&gt;缓存抽象 redisRepository redisTemplate&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;缓存抽象（@Cacheable 等注解），Spring 通过 aop 实现了缓存功能，底层不一定是 redis，也可能是 jvm 缓存，memcached等。&lt;/li&gt;
      &lt;li&gt;redisRepository，类比 mysql 的 repository 操作，如 CrudRepository，帮我们实现了操作缓存的功能&lt;/li&gt;
      &lt;li&gt;redisTemplate，类比 jdbcTemplate，提供更底层的原始命令，由开发自行实现一些功能，更灵活&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 23 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/23/Spring01/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/23/Spring01/</guid>
        
        <category>Java</category>
        
        <category>Springboot</category>
        
        <category>All kind of database</category>
        
        <category>JPA</category>
        
        <category>NoSql</category>
        
        <category>RabitMQ</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> React Hooks </title>
        <description>&lt;h2 id=&quot;react-的class-based--和-functional-based-的component&quot;&gt;React 的class-based  和 functional-based 的component&lt;/h2&gt;
&lt;p&gt;在实现时，functional-based可以实现class-based功能，一般情况下lifecycle可以用hook代替&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;命名规则 useXYZ()&lt;/li&gt;
  &lt;li&gt;只在react 16.8以上版本能用
    &lt;h2 id=&quot;开始使用&quot;&gt;开始使用&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用样例通过输入ingredient的载入ingredient的描述和数量并且能点击下面的ingredientlist-删除-ingredient&quot;&gt;使用样例，通过输入ingredient的载入ingredient的描述和数量，并且能点击下面的IngredientList 删除 ingredient&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;导入useState&lt;/strong&gt;,这个相当于class-base中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state = {}&lt;/code&gt;不同之处在于useState可以实现传入各种类型的数据，其中有两个参数，一个是当前state的 snapshot 另一个就是如何更新这个state&lt;/li&gt;
  &lt;li&gt;使用ES6的extract方法实现的state赋值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const [inputState,setInputState]=useState({ title: '', amount: '' });
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;也可以替换成以下的形式
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const [enteredTitle, setEnteredTitle] = useState(&quot;&quot;);
const [enteredAmount, setEnteredAmount] = useState(&quot;&quot;);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;怎样use hooks
    &lt;ul&gt;
      &lt;li&gt;必须是在function component或者自定义hook中使用&lt;/li&gt;
      &lt;li&gt;必须在root level使用hook，不能再一个function component中嵌套使用 hook，也不能在if语句中使用hook&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fetch Data from firebase
通过创建新的real time firebase 使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch()&lt;/code&gt;是一种browser能识别的代码表示从http中获取数据。
&lt;strong&gt;小知识点&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;json =&amp;gt; js code &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jsonCode.json()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;js code =&amp;gt; json &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON.stringify(jsCode)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  fetch(&quot;https://react-hook-example-xxxee.firebaseio.com/ingredient.json&quot;,//样例URL
      {
        method: &quot;POST&quot;,
        body: JSON.stringify(ingredient),
        headers: { 'Content-Type': 'application.json' }
      }).then(response =&amp;gt; {
        return response.json()
      }).then(responseData =&amp;gt; {// responseData是response 中的属性名 包含 firebase中赋予的id
        setIngredients(prevIngredients =&amp;gt; [...prevIngredients,
        {
          id: responseData.name,// responseData来源于firebase
          ...ingredient
        }
        ])
      })
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里使用两个then因为return response.json()返回的是一个promise所以对其内部做处理需要再加一个then。第一个then获得的数据如下图
&lt;img src=&quot;/img/react-hook-fetch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;useEffect hook&lt;/strong&gt;
这个hook表示在页面每一次render完成之后再加载的动作，用于消除&lt;strong&gt;side effect&lt;/strong&gt;，没有加入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;依赖，相当于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentDidUpdate&lt;/code&gt;
传入一个匿名函数以及函数中变量用到的依赖，只有这个依赖改变，才会rerun这个页面。所以加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;表示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentDidMount&lt;/code&gt;所以&lt;strong&gt;&lt;em&gt;一定要加[],哪怕没有依赖也要加&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;注意，如果是因为在props中的传入的function改变，需要加入depend中需要转化格式&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const {propsValue} = props;
...
useEffect = (()=&amp;gt;{...},[propsValue]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;案例分析如何给页面加上一个可搜索的方法&quot;&gt;案例分析，如何给页面加上一个可搜索的方法？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先需要对useEffect 中设置fetch保证每次输入都能匹配数据库中的某个固定字段&lt;/li&gt;
  &lt;li&gt;在数据库（后端）配置这个字段，也就是firebase中在rules中将这个地方加上传入数据库的字段，以下内容表示在ingredient传入时也就是fetch的url最后加上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ingredient.json&lt;/code&gt;中post的title字段为搜索中需要修改的地方。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
&quot;rules&quot;: {
  &quot;.read&quot;: &quot;now &amp;lt; 1605024000000&quot;,  // 2020-11-11
  &quot;.write&quot;: &quot;now &amp;lt; 1605024000000&quot;,  // 2020-11-11
    &quot;ingredients&quot;:{
      &quot;.indexOn&quot;:[&quot;title&quot;]
    }
}
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在useEffect中写入需要到数据库中匹配的字段，每次输入的值是通过html中onChange执行的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以下的代码中注意query字段，表示判断输入值是否为空，如果不为空就需要到数据库中取数据。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;useEffect = (() =&amp;gt; {
    const query = enteredFilter.length === 0 ? '' 
    : `?orderBy=&quot;title&quot;&amp;amp;equalTo=&quot;${enteredFilter}&quot;`;//注意不要丢到=号

    fetch(&quot;https://react-hook-example-xxxee.firebaseio.com/ingredient.json&quot; + query)
      .then(response =&amp;gt; {
        return response.json();
      })
      .then(responseData =&amp;gt; {
        const loadResponseData = [];
        for (const key in responseData) {
          loadResponseData.push({
            id: key,
            title: responseData[key].title,
            amount: responseData[key].amount
          });
        }
        onLoadingIngredients(loadResponseData);
      })

  }, [enteredFilter,onLoadingIngredients]);//每次enteredFilter改变就会执行
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;onLoadingIngredients这个依赖&lt;/strong&gt;是调用component时赋给的一个props，已经通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const {propsValue} = props;&lt;/code&gt;取出，表示如果这个component被重新调用就再次调用useEffect,parant component re-render&lt;/p&gt;

&lt;h3 id=&quot;usecallback-hook&quot;&gt;&lt;strong&gt;useCallback hook&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;作用于会导致两个component一直渲染的页面，因为子页面利用父页面传过来的方法作为useEffect的依赖，只要useEffect依赖改变，子页面也就会重新渲染，但是父页面中传入到子页面的方法在被子页面调用之后，在父页面进行了重新渲染，从而带动子页面的渲染形成闭环，useCallback就是保持父页面中的内容没有因为子页面重新渲染而改变，作为一个cache。&lt;/p&gt;

&lt;p&gt;useCallback 用法和useEffect相同，也需要加上依赖参数，如果是useState作为依赖参数则可以忽略不加。&lt;/p&gt;

&lt;h3 id=&quot;useref-hook&quot;&gt;&lt;strong&gt;useRef hook&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;useRef是为了获得最新的state中的数据，在useEffect中setTimeout时希望判断两次输入时间间隔不小于多少秒，而且需要一边输入一边对比，就需要用到useRef。setTimeout内部获得的useState表示在运行到setTimeout时获得的state，但对于一直更新的state需要通过useRef获得。
使用方式如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;先引入useRef  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import {useRef} from 'react'&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;定义一个useRef &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const inputRef = useRef()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在html处定义ref &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;input ref={inputRef}/&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在setTimeout处使用ref
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  setTimeout(() =&amp;gt; {
if (enteredFilter === inputRef.current.value) {
  ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;主要用于解决用户输入时为了不要一直获取用户输入而频繁的render到后端的问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;useeffect的cleanup&quot;&gt;&lt;strong&gt;useEffect的cleanUp&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在上面的例子中，如果用户输入时间过长但是一直匹配到正确结果的情况下，需要clean useEffect的使用，（setTimeout 是在useEffect中的）所以每次depend改变需要re-render时，才执行return，也就是clean
具体使用方式如下: return 一定是一个func，当depend为空也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;时，return发生时间变为component为unmount时。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;useEffect(() =&amp;gt; {
    const timer = setTimeout(() =&amp;gt; {
      if (enteredFilter === inputRef.current.value) {
        ...
      }
    },5000);
    return ()=&amp;gt;{cleanTimeout(timer)};
},[]);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;return中执行的就是clean useEffect的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;小知识点&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在代码中的三段表达式：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; A ? B: C&lt;/code&gt;如果C是null则可以写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A &amp;amp;&amp;amp; B&lt;/code&gt;形式&lt;/li&gt;
  &lt;li&gt;在代码中两个setState一起执行不会导致死循环情况，因为state会预先存在batch中，原先的会保留并且在同一个render中执行，两个state同时执行，并且有交叉关系再执行时是没有冲突的。对于两个setState同时执行的情况&lt;a href=&quot;https://github.com/facebook/react/issues/10231#issuecomment-316644950&quot; target=&quot;_blank&quot;&gt;github issue&lt;/a&gt;
具体解释如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;more-on-state-batching--state-update&quot;&gt;more on state batching &amp;amp;&amp;amp; state update&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;setName('Max');
setAge(30);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;in the same synchronous (!) execution cycle (e.g. in the same function) will NOT trigger two component re-render cycles.&lt;/p&gt;

&lt;p&gt;Instead, the component will only re-render once and both state updates will be applied simultaneously.&lt;/p&gt;

&lt;p&gt;Not directly related, but also sometimes misunderstood, is when the new state value is available.&lt;/p&gt;

&lt;p&gt;Consider this code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;console.log(name); // prints name state, e.g. 'Manu'
setName('Max');
console.log(name); // ??? what gets printed? 'Max'?
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You could think that accessing the name state after setName(‘Max’); should yield the new value (e.g. ‘Max’) but this is NOT the case. Keep in mind, that the new state value is &lt;strong&gt;only available in the next component render cycle&lt;/strong&gt; (which gets scheduled by calling setName()).&lt;/p&gt;

&lt;p&gt;Both concepts (batching and when new state is available) behave in the same way for both functional components with hooks as well as class-based components with this.setState()!&lt;/p&gt;

&lt;h3 id=&quot;usereducer&quot;&gt;&lt;strong&gt;useReducer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;类似于reducer的一种方式，因为定义了大量的useState，所以可以将多个reducer整合。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先在component外层定义useReducer，因为每次外层的定义是不会随着component一起render的。useReducer和基础的redux的reducer定义类似。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const ingredientReducer = (currentIngredients, action)=&amp;gt;{
  switch(action.type){
    case &quot;SET&quot;:
      return action.ingredient
    case &quot;ADD&quot;:
      return [...currentIngredients, action.ingredient]
    case &quot;DELETE&quot;:
      return currentIngredients.filter(ing =&amp;gt;ing.id !== action.id)
    default:
      throw new Error(&quot;should not go hear!&quot;)
  }
}

const ExampleComponent = ()=&amp;gt;{...}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;每个action后面跟的就是在调用dispatch时需要传入的参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在component内部导入刚刚定义的reducer
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const ExampleComponent = ()=&amp;gt;{
const [ingredients, dispatch] = useReducer(ingredientReducer,[])
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传入的两个参数第一个是前面定义的array第二个是start state，注意从useReducer中提取的第二个参数，是用来代替setState方法的，名字可以自行定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代替setState，以下是几个state案例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// setIngredients(prevIngredients =&amp;gt; [...prevIngredients,
  // {
  //   id: responseData.name,
  //   ...ingredient
  // }
  // ])
  dispatch({
    type: &quot;ADD&quot;, ingredient: {
      id: responseData.name,
      ...ingredient
    }
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// setIngredients(prevIngredients =&amp;gt; prevIngredients.filter(
//   (ingredient) =&amp;gt; ingredient.id !== ingredientId))
dispatch({type:&quot;DELETE&quot;,id:ingredientId})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const filterIngredientsHandler = useCallback((filterIngredients) =&amp;gt; {
    // setIngredients(filterIngredients)
    dispatch({ type: &quot;SET&quot;, ingredients: filterIngredients });
  }, [])
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;综上，useReducer可以使用的情况是在每个state有不同的使用状态时，或者一个方法组要改多个state时，放在一起定义。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;usecontext&quot;&gt;&lt;strong&gt;useContext&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;用法是将需要层层传递的某个state利用这种形式获得，类似于redux但是是react自带的方法，主要用于function base component中详见react笔记那篇文章。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React, { useState } from 'react';
export const AuthContext = React.createContext({
isAuth: false,
login: () =&amp;gt; {}
})

const AuthContextProvider = (props) =&amp;gt; {
    const [isAuth, setIsAuth] = useState(false);
    const loginHandler = () =&amp;gt; {
        setIsAuth(true)
    }
    return (
        &amp;lt;AuthContext.Provider value=&amp;gt;
            {props.children}
        &amp;lt;/AuthContext.Provider&amp;gt;
    )
}
export default AuthContextProvider;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在index.js中利用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;AuthContextProvider&amp;gt;&lt;/code&gt;包裹住&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;表示所有需要用到AuthContext地方被表示为Provider,在需要用到的是否login的地方写入以下代码（此处是在App主界面），注意定义中先export的并不是default的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthContextProvider&lt;/code&gt;而是包含默认值的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthContext&lt;/code&gt;所以在导入的时候是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{AuthContext}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { AuthContext } from './context/auth-context';   

const App = props =&amp;gt; {
const authContext = useContext(AuthContext);
let content = &amp;lt;Auth /&amp;gt;
if (authContext.isAuth) {
    content = &amp;lt;Ingredients/&amp;gt;
}
return (
    // &amp;lt;AuthContext.Consumer&amp;gt;
    // &amp;lt;Auth /&amp;gt;
    // &amp;lt;/AuthContext.Consumer&amp;gt;
    {content}
    )
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在需要auth的界面中显示&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import {AuthContext} from '../context/auth-context';

const Auth = props =&amp;gt; {
const authContext = useContext(AuthContext);
const loginHandler = () =&amp;gt; {
    authContext.login();//改变login中的state从而在App主界面转换为&amp;lt;Ingredients/&amp;gt;
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;usememo&quot;&gt;&lt;strong&gt;useMemo&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在react笔记中介绍过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;的用法，这里是利用useMemo进行扩展。原来是作用在component定义中，useMemo是直接作用在component调用的时候。传入的是一个方法，作用是保存一些需要花费时间渲染的component，只有在其中有值改变的时候才回去渲染。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const ingredientList = useMemo(() =&amp;gt; {
  return (
    &amp;lt;IngredientList ingredients={ingredients} onRemoveItem={removeIngredientHandler} /&amp;gt;
  )
}, [ingredients])//依赖
...
在render中
{ingredientList}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是用到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;则是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const IngredientList =React.memo(props =&amp;gt; {
  return (...)})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;自制hook&quot;&gt;自制Hook&lt;/h2&gt;
&lt;p&gt;最重要一点需要以use作为开头&lt;/p&gt;

&lt;p&gt;自制的Hook首先是一个匿名方法，对渲染的优先顺序可以使用useCallback来限制&lt;/p&gt;

&lt;h2 id=&quot;将hook作用到实际的开发中&quot;&gt;将hook作用到实际的开发中&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先利用React.lazy()代替原先的自定义懒加载，毕竟原先的代码中包含了class base的component，具体代码见react-axios的那篇文章。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和React.lazy包裹搭配使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Suspend&amp;gt;&lt;/code&gt;，是对route中在没有实现加载时在页面上显示的内容，具体是:
```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;Suspense fallback={&amp;lt;p&amp;gt;Loading…&amp;lt;/p&amp;gt;}&amp;gt;
        {routes}
&amp;lt;/Suspense&amp;gt;
```
包裹住自定义的route，并且将router修改为render跳转而不是component跳转&amp;gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果是要执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentWillMount&lt;/code&gt;表示在component加载之前执行，所以把代码前移，放在return之前。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;componentWillUnmount&lt;/code&gt;作为放在最后作为页面加载完毕清除缓存的控件可以利用useEffect的return实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/30/ReactHooks/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/ReactHooks/</guid>
        
        <category>react hooks</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> webpack </title>
        <description>&lt;p&gt;&lt;strong&gt;申明 create-react-app已经足够日常使用，webpack配置较为麻烦，实力劝退，而且版本更新换代较快，不建议使用。一口气学完之后感觉像是满口塞了泡菜般的有话说不出&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-it-work&quot;&gt;How it work&lt;/h2&gt;
&lt;p&gt;entry(app.js)Multiple entry points are posible —&amp;gt;&lt;/p&gt;

&lt;p&gt;—&amp;gt; Loaders(babel-loader,css-loader) File type dependent transformations&lt;/p&gt;

&lt;p&gt;—&amp;gt; Plugins(uglify)Global transformations&lt;/p&gt;

&lt;p&gt;—&amp;gt; output(bundle.js) Correctly ordered concatenated output&lt;/p&gt;

&lt;h2 id=&quot;basic-workflow-requirements-create-react-app帮我们做的事情&quot;&gt;Basic Workflow Requirements create-react-app帮我们做的事情&lt;/h2&gt;

&lt;p&gt;compile js code&lt;/p&gt;

&lt;p&gt;handle jsx&lt;/p&gt;

&lt;p&gt;css auto prefix&lt;/p&gt;

&lt;p&gt;support image support&lt;/p&gt;

&lt;p&gt;optimize code&lt;/p&gt;

&lt;h2 id=&quot;创建新的文件夹并在其下运行&quot;&gt;创建新的文件夹并在其下运行&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm init&lt;/code&gt;一路回车&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev webpack webpack-dev-server&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在总目录下建立src目录&lt;/li&gt;
  &lt;li&gt;npm install –save 需要的东西&lt;/li&gt;
  &lt;li&gt;在package.json文件中的script下配置
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;start&quot;:&quot;webpack-dev-server&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack-cli&lt;/code&gt;使用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev webpack-cli&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在package.json文件同级创建文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;告知webpack读取这个文件。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://webpack.js.org/concepts/&quot; target=&quot;_blank&quot;&gt;webpack文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;写入webpackconfigjs文件&quot;&gt;写入webpack.config.js文件&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const path= require('path');

module.exports={
    mode: 'devlopment',//设置之后不会自动压缩代码
    entry:'./src/index.js',
    output:{
        // path 的名字表示当前页面的名字
        path:path.resolve(__dirname,'react-webpack'),
        filename: 'bundle.js',
        publicPath: ''
    },
    devtool: 'cheap-module-source-map'
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;加入-babel&quot;&gt;加入 babel&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-2 babel-loader @babel/plugin-proposal-class-properties&lt;/code&gt;需要初始化以上&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在devtool下面加上文件读取的rules
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; module:{
   rules:[
     {
       // test告知以js为结尾都会遵循以下的rule
       test:/\.js$/,
       // loader告知以什么形式加载
       loader:'babel-loader',
       // 不读取哪些内容
       exclude:/node_modules/
     }
   ]
 }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在package.json文件同级加上文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;babel自动读取这个文件，写入json文件
    &lt;ul&gt;
      &lt;li&gt;presets是babel给的browser的屏幕宽度等参数&lt;/li&gt;
      &lt;li&gt;plugins是写入什么形式babel会帮助
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
 &quot;presets&quot;: [
   [
       &quot;@babel/preset-env&quot;,
       {
           &quot;targets&quot;: {
               &quot;browsers&quot;: [
                   &quot;&amp;gt;1%&quot;,
                   &quot;last 2 version&quot;
               ]
           }
       }
   ],
   &quot;@babel/preset-react&quot;
 ],
 &quot;plugins&quot;: [
   &quot;@babel/plugin-proposal-class-properties&quot;
 ]
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;加载读取css文件的控件&quot;&gt;加载读取css文件的控件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev style-loader css-loader file-loader&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;写入能够读取css的rules，在以上定义的modules内&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
  test:/\.css$/,
  exclude:/node_modules/,
  use: [
    {loader: 'style-loader'},
    {loader: 'css-loader', options:{
        importLoaders: 1,
        modules: {
            localIdentName: '[name]__[local]__[hash:base64:5]'
        }
    }}
  ] 
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev postcss-loader&lt;/code&gt; 这个控件可以将react中的css以oldHtml的语法加入到页面中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev autoprefixer&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postcss-loader&lt;/code&gt;控件中options需要载入的控件，这里加载时需要在页面中先定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autoprefixer&lt;/code&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const autoprefixer = require('autoprefixer');&lt;/code&gt;类似于定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;use: [
  { loader: 'style-loader' },
  {
    loader: 'css-loader',
    options: {
      importLoaders: 1,
      modules: {
        localIdentName: '[name]__[local]__[hash:base64:5]'
      }
    }
  },
  {
    loader:'postcss-loader',options:{
      ident:'postcss',
      plugins: ()=&amp;gt;[autoprefixer()]
    }
  }
]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autoprefixer&lt;/code&gt;控件是告知页面是以什么样的形式打开，需要在package.json文件中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;license&quot;&lt;/code&gt;同级中写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;browserslist&quot;: &quot;&amp;gt;1%,last 2 version&quot;&lt;/code&gt;，这里的&lt;strong&gt;browserlist&lt;/strong&gt;对应了&lt;strong&gt;babelrc&lt;/strong&gt;中的&lt;strong&gt;browsers&lt;/strong&gt;属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;页面加载image&quot;&gt;页面加载image&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev url-loader&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入rules&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
  test:/\.(png|jpe?g|gif)$/,
  //loader ?之后的内容表示 照片存储的位置[name]是照片名,[ext]表示扩展名 extension
  loader:'url-loader?limit=8000&amp;amp;name=images/[name].[ext]'
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save-dev html-webpack-plugin&lt;/code&gt;将style写入bundle.js，同时在config文件中定义
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const HtmlWbpackPlugin = require('html-webpack-plugin');
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;方便后面调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在config文件中，module之后定义一个plugins，告诉webpack要以index.html中的语法作为基本语法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;plugins:[
        new HtmlWbpackPlugin({
            template: __dirname + './src/index.html',
            filename: 'index.html',
            inject:'body'
        })
    ]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/30/Webpack/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/Webpack/</guid>
        
        <category>wepack</category>
        
        <category>self-learning</category>
        
        <category>完整工作流</category>
        
        
      </item>
    
      <item>
        <title> Machine Learning math </title>
        <description>&lt;h2 id=&quot;降维-dimensionalily-reduce&quot;&gt;降维 Dimensionalily Reduce&lt;/h2&gt;
&lt;p&gt;首先引入过拟合概念 overfitting ，解决方法有三种，这里具体讲的是PCA降维。&lt;/p&gt;

&lt;h3 id=&quot;pca-降维概念&quot;&gt;PCA 降维概念&lt;/h3&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0ML/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0ML/</guid>
        
        <category>math</category>
        
        <category>self-learning</category>
        
        <category>machine learning</category>
        
        
      </item>
    
  </channel>
</rss>
