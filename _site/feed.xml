<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joy Blog</title>
    <description>季月侣的Blog || About Joy </description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 25 Sep 2020 08:53:26 +0800</pubDate>
    <lastBuildDate>Fri, 25 Sep 2020 08:53:26 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title> Java并发 </title>
        <description>&lt;h2 id=&quot;java开发中绕不开的环节并发编程&quot;&gt;Java开发中绕不开的环节，并发编程&lt;/h2&gt;
&lt;p&gt;新手java开发，已经有一些基于spring开发的经验，但是在实际应用中对Java整个的运行机制还是不了解。&lt;/p&gt;
&lt;h3 id=&quot;thread-和-runnable&quot;&gt;Thread 和 Runnable&lt;/h3&gt;
&lt;p&gt;线程创建方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法1 先有任务对象，再有线程对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Test1{
  public static void main(String[] args){
    Thread t = new Thread(){
      @Override
      public void run(){
        log.debug(&quot;running&quot;);
      }
    };
    t.setName(&quot;t1&quot;);// 给线程设置名字
    t.start();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用lambda简化方法1&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;new Thread(()-&amp;gt;{
  log.debug(&quot;running&quot;);
}, &quot;t1&quot;).start();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方法2 先创建线程对象，在里面执行任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Test2{
  public static void main(String[] args){
   Runnable r = new Runnable(){
     @Override
     public void run(){
       log.debug(&quot;running&quot;);
     }
   };
   Thread t = new Thread(r,&quot;t2&quot;);// t2是给线程设置名字
   t.start();
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用lambda简化Runnable&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Runnable r = () -&amp;gt;{
       log.debug(&quot;running&quot;);
   };
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于第一和第二种，Runnable也是实现对run方法的Override。
方法1是线程任务合并，方法2是线程任务分开。
推荐使用方法2，Runnable更容易与线程池等高级API实现结合。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法3 FutureTask
能够接受callable类型参数，任务执行完将内容传给其他线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Test3{
  public static void main(String[] args){
    FutureTask&amp;lt;Integer&amp;gt; task = new FutureTask&amp;lt;&amp;gt;(new Callable&amp;lt;Integer&amp;gt;(){
      @Override
      public Integer call() throws Exception{
        log.debug(&quot;running&quot;);
        Thread.sleep(1000);
        return 100;
      }
    });
    Thread t = new Thread(task,&quot;t3&quot;);// t3是线程名
    t.start();

    task.get();//使用 等待task返回结果
}

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程交替执行情况&quot;&gt;线程交替执行情况&lt;/h3&gt;
&lt;p&gt;只有在多核cpu才能利用多种Thread&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查看进程方法 linux
    &lt;ul&gt;
      &lt;li&gt;ps -fe 查看所有进程  后面再加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;| grep java&lt;/code&gt;查看java进程&lt;/li&gt;
      &lt;li&gt;ps -fT -p &lt;PID&gt;&lt;/PID&gt;&lt;/li&gt;
      &lt;li&gt;kill &lt;PID&gt;杀死进程&lt;/PID&gt;&lt;/li&gt;
      &lt;li&gt;top 查看进行占用百分比 top -H -p &lt;PID&gt; 查看所有进程中的线程信息&lt;/PID&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java
    &lt;ul&gt;
      &lt;li&gt;jps 查看所有Java进程&lt;/li&gt;
      &lt;li&gt;jstack &lt;PID&gt; 查看线程的 snapshot&lt;/PID&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;jconsole java进程 可以远程监控 针对虚拟机专用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程运行原理&quot;&gt;线程运行原理&lt;/h3&gt;
&lt;p&gt;JVM  java virtual machine stack 给虚拟机分配空间&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;栈帧信息 frame&lt;/p&gt;

    &lt;p&gt;多线程实现， 线程之间栈帧独立&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程上下文切换 Thread Context Switch&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;产生情况&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从使用Cpu时间片用完&lt;/li&gt;
  &lt;li&gt;垃圾回收&lt;/li&gt;
  &lt;li&gt;更高级线程&lt;/li&gt;
  &lt;li&gt;线程自己调用 sleep yield wait join park synchronized lock&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在switch的时候需要保证线程状态，程序计数器Program Counter Register 记住下一条指令地址，频繁 Context Switch 影响 性能&lt;/p&gt;

&lt;h3 id=&quot;线程常见方法&quot;&gt;线程常见方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;start() 启动新线程 start让线程进入就绪转态，里面代码不会立即执行，每个线程对象start方法只能调用一次&lt;/li&gt;
  &lt;li&gt;run() 在构造Thread对象时传入 Runnable参数，在线程启动后会调用Runnable中run方法，可以创建Thread子类对象，来覆盖默认行为。&lt;/li&gt;
  &lt;li&gt;join() 等待线程运行结束&lt;/li&gt;
  &lt;li&gt;join(long n) 等待线程运行结束,最多等待n秒&lt;/li&gt;
  &lt;li&gt;getId() 获取线程长整型的id&lt;/li&gt;
  &lt;li&gt;getName() 获取线程名&lt;/li&gt;
  &lt;li&gt;getPriority() setPriority() 设置线程优先级&lt;/li&gt;
  &lt;li&gt;getState() 线程状态 6种&lt;/li&gt;
  &lt;li&gt;isInterrupted() 判断线程是不是被打断&lt;/li&gt;
  &lt;li&gt;isAlive() 判断线程是否存活&lt;/li&gt;
  &lt;li&gt;interrupt() 打断线程&lt;/li&gt;
  &lt;li&gt;currentThread() static 获取当前线程&lt;/li&gt;
  &lt;li&gt;sleep(long n) static 当前线程休眠&lt;/li&gt;
  &lt;li&gt;yield（） static 提示线程调度器让出当前线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;详细讲解方法&quot;&gt;详细讲解方法&lt;/h4&gt;

&lt;h5 id=&quot;run-和-start&quot;&gt;run 和 start&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;start启动线程&lt;/strong&gt;，再由线程调用自己定义的run方法。只能调用1次的start方法。&lt;/p&gt;

&lt;h5 id=&quot;yield-和-sleep&quot;&gt;yield 和 sleep&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;sleep&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Running到Time Waiting，在哪个线程里被调用，就在哪个线程里休眠。&lt;/li&gt;
  &lt;li&gt;其他线程可使用interrupt()打断正在睡眠的线程，sleep抛异常。&lt;/li&gt;
  &lt;li&gt;睡眠结束未必会立即执行&lt;/li&gt;
  &lt;li&gt;建议使用TimeUnit 的 sleep 代替 Thread.sleep() 提高可读性
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;TimeUnit.SECONDS.sleep(1);//单位换算
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;yield&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Running 到 Runnable，之后执行其他&lt;strong&gt;同优先级&lt;/strong&gt;线程。&lt;/li&gt;
  &lt;li&gt;具体实现依赖调度器。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
        
        <category>java</category>
        
        <category>self-learning</category>
        
        <category>thread learning</category>
        
        
      </item>
    
      <item>
        <title> Redux详解 </title>
        <description>&lt;h3 id=&quot;what-is-state&quot;&gt;what is state?&lt;/h3&gt;
&lt;p&gt;influence what I look in the screen&lt;/p&gt;

&lt;h3 id=&quot;需要了解的action-reducer&quot;&gt;需要了解的Action Reducer&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;reducers: pure function,receive action and update state.&lt;/li&gt;
  &lt;li&gt;action: predefine information package
其实Redux不光可以在React中使用，在只有node的情况下，也可以通过设置初始化的state。
Redux的意义是实现各个component之间参数传递，传统的props如果要传递参数需要写入很多重复代码，Redux相当于一个云数据库，存储了许多state。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;redux中主要组成部分&quot;&gt;Redux中主要组成部分&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Reducer 初始化state 绑定action
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const initialState = {
  counter: 0
}
const rootReducer = (state = initialState, action) =&amp;gt; {
  if (action.type === 'INC_COUNTER') {
      return {
          ...state,
          counter: state.counter + 1
      };
  }
  if (action.type === 'ADD_COUNTER') {

      return {
          ...state,
          counter: state.counter + action.value
      };
  }
  return state;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Store 定义需要保存的对象
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const store = createStore();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Subscription 确认所有的绑定的action执行之后的结果
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 不需要manually called  console.log(store.getState)
store.subscribe(() =&amp;gt;{
  console.log('[Subscribtion]', store.getState());// 
})// 每次dispatch的实现都能通过getState获得
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Dispatching action 对每个action实现的具体内容，type是一定要定义的，利用type来绑定reducer中对state执行怎样的操作
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;store.dispatch({ type: 'INC_COUNTER' })
store.dispatch({ type: 'ADD_COUNTER', value: 10 }) // 这里就是传递了value作为参数。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt; reducer通过dispatch定义的action的type对state进行操作，而store是能获得改变之后state的对象，可以通过调用store来获得改变之后的state，subscribe是可以观察到state改变状态的store里的方法。&lt;/p&gt;

&lt;h3 id=&quot;创建react-redux步骤&quot;&gt;创建react-redux步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在index.js中初始化redux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { createStore } from 'redux';&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在主界面中定义redux-base.js
实现代码
首先要加载属于react的redux
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save react-redux&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装时遇到问题 对应最新版本的react-redux安装不支持，需要在package.json中将其版本号换成&lt;strong&gt;5.0.6&lt;/strong&gt;并且对应的react版本应该小于&lt;strong&gt;16.3&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { Provider } from 'react-redux';
const store = createStore(reducer)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在index.js中将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Provider store={store}&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;&lt;/code&gt; 作为Component外层包裹到App中，并且传入定义好的store&lt;/p&gt;

&lt;p&gt;引入connect概念和mapStateToProps()
connect 是高阶组件，但是其引入方式是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import {connect} from 'react-redux';

...

export default connect(mapStateToProps,mapDispatchToProps)(XXX);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mapstatetoprops-和-mapdispatchtoprops&quot;&gt;mapStateToProps 和 mapDispatchToProps&lt;/h3&gt;
&lt;p&gt;整体上redux的参数传入机制是依靠这两个来实现&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;mapStateToProps&lt;/strong&gt; 类似于在class component 中定义初始化state&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;state = {
  counter: 0
} //正常格式

// 处于class component之外的格式
const mapStateToProps = state =&amp;gt; {
    return {
        ctr: state.counter
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;mapDispatchToProps&lt;/strong&gt; 定义获得的state通过什么type的dispatch&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;在class-component中实现的形式&quot;&gt;在class component中实现的形式&lt;/h5&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;counterChangedHandler = (action, value) =&amp;gt; {
        switch (action) {
             case 'inc':
                this.setState((prevState) =&amp;gt; { return { counter: prevState.counter + 1 })
      ...
   
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两个的使用顺序是固定的，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect(mapStateToProps,mapDispatchToProps)()&lt;/code&gt;如果没有mapStateToProps则要变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect(null,mapDispatchToProps)()&lt;/code&gt;同理，没有mapDispatchToProps就默认connect中只传入一个参数。&lt;/p&gt;

&lt;h4 id=&quot;在class-component外实现的形式&quot;&gt;在class component外实现的形式&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const mapDispatchToProps = dispatch =&amp;gt; {
    return {
        onIncreamentCounter: () =&amp;gt; dispatch({type:&quot;INCREMENT&quot;}),
        onDecrementCounter:() =&amp;gt;dispatch({type:&quot;DECREMENT&quot;}),
        onAddCounter: () =&amp;gt; dispatch({type:&quot;ADD&quot;, value:5}),
        onSubtractCounter: () =&amp;gt; dispatch({type:&quot;SUBTRACT&quot;, value:5})
        
    };
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;在redux文件中定义的格式&quot;&gt;在redux文件中定义的格式&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const initialState = {
    counter: 0
}

const reducer = (state = initialState, action) =&amp;gt; {
    switch (action.type) {
        case ('INCREMENT'):
            return {
                ...state,
                counter: state.counter + 1
            };
            break;
        case ('DECREMENT'):
            return {
                ...state,
                counter: state.counter - 1
            };
            break;

        case ('ADD'):
            return {
                ...state,
                counter: state.counter + action.value
            };
            break;

        case ('SUBTRACT'):
            return {
                ...state,
                counter: state.counter - action.value
            };
            break;
    }

    return state;
};
export default reducer;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;redux-传参&quot;&gt;redux 传参&lt;/h3&gt;
&lt;p&gt;playload作为参数传递于需要的component和reducer之间，对于需要在dispatch中传入参数的函数，可以通过在定义type属性之后添加进行定义。&lt;/p&gt;

&lt;p&gt;如果想要在不同的class component中动态传参其实需要props的配合以及在dispatch中也放入对应参数来传递state。&lt;/p&gt;

&lt;h3 id=&quot;整合多个reducer&quot;&gt;整合多个reducer&lt;/h3&gt;
&lt;p&gt;首先定义多个reducer为一个模块，在此基础上，在index.js文件中，对其中的引入redux模块代码进行添加
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { createStore, combineReducers } from 'redux';&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在index中写入&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import counterReducer from './store/reducers/counter';
import resultReducer from './store/reducers/result';

const rootReducer = combineReducers({
    ctr:counterReducer,
    res:resultReducer
})
const store = createStore(rootReducer)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示告知react 整合这两个模块，并且将新的rootReducer传入到store中，对应到具体的component中，不同的reducer对应的state也改变了，所以需要再重新加上不同的模块，这里定义state的地方在mapStateToProps中，在原先的state的基础上重新加上.新定义的reducer名。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const mapStateToProps = state =&amp;gt; {
    return {
        ctr: state.ctr.counter,
        storeResult: state.res.results
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;什么情况下使用redux来存储state&quot;&gt;什么情况下使用redux来存储state&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;type : local UI 如 hide/show backdrop 不需要&lt;/li&gt;
  &lt;li&gt;type: persistant state 如 users info 不需要，是存储于server端的&lt;/li&gt;
  &lt;li&gt;client state: 用户是否登录，需要&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;advance-redux&quot;&gt;Advance Redux&lt;/h2&gt;
&lt;p&gt;高级redux&lt;/p&gt;
&lt;h3 id=&quot;add-midware&quot;&gt;Add midware&lt;/h3&gt;
&lt;p&gt;什么是midware 在reducer和action中间的一段代码或者说是function&lt;/p&gt;

&lt;h4 id=&quot;导入midware&quot;&gt;导入midWare&lt;/h4&gt;
&lt;p&gt;在index.js中导入&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { createStore, combineReducers, applyMiddleware } from 'redux';
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;并且写入midware的定义方法(定义在index.js中)&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 自己创建midware 监视每次dispatch之后state的值
const logger = store=&amp;gt;{
    return next =&amp;gt;{
        return action =&amp;gt;{
            console.log('[MidWare] Dispatching', action);
            const result =  next(action);
            console.log('[Midware] next state', store.getState())
            return result;
        }
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现midWare注册，在index.js中因为已经导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applyMiddleware&lt;/code&gt;所以在createStore时多传入参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applyMiddleware&lt;/code&gt;。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const store = createStore(rootReducer, applyMiddleware(logger))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applyMiddleware&lt;/code&gt;传入刚刚定义的midWare，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logger&lt;/code&gt;，&lt;strong&gt;其实可以传入多个midWare&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用redux-dev-tools&quot;&gt;使用redux dev tools&lt;/h4&gt;
&lt;p&gt;google安装插件，打开这个github页面&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot; target=&quot;_blank&quot;&gt; redux dev tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;定位到&lt;img src=&quot;/img/advance-redux.jpg&quot; alt=&quot;&quot; /&gt;这个位置，修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rootRedux&lt;/code&gt;
改变为&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
const store = createStore(rootReducer, /* preloadedState, */ composeEnhancers(applyMiddleware(logger )))
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;并且在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import redux&lt;/code&gt;的时候加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt;， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compose&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combineReducers&lt;/code&gt;是一个类似用法，将多个enhance聚合。在redux tool中可以看到对应redux数据流。&lt;/p&gt;

&lt;h3 id=&quot;为什么redux需要使用async-code&quot;&gt;为什么redux需要使用async code&lt;/h3&gt;
&lt;p&gt;在action中传入的方法如果需要设置时间属性，比如setTimeout会返回一个Promise，但是redux中不支持使用Promise所以需要在其中调用async&lt;/p&gt;

&lt;h4 id=&quot;开始实现asynchron-code&quot;&gt;开始实现asynchron code&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先修改action.js中的内容，原先的action中使为了防止输入出错，所以const export 的大写字母，但现在可以将其和所有的dispatch整合&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const subtract = (value) =&amp;gt;{
    return {
        type:SUBTRACT,
        value:value
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大写的变量变成方法，在mapDispatchToProps的时候return的dispatch就由只能传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch =&amp;gt; ({type:...})&lt;/code&gt;变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch =&amp;gt;(action.js中定义的各个方法名)&lt;/code&gt;，其实是基本的参数变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;载入&lt;strong&gt;redux thunk&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save redux-thunk&lt;/code&gt;
在createStore的时候再加上一个midWare&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const store = createStore(rootReducer, composeEnhancers(applyMiddleware(logger, thunk)));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在action中使用setTimeout()包裹住一个dispatch，之后通过主界面调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;storeResult&lt;/code&gt;中的方法实现async的dispatch&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const saveResult = ( res ) =&amp;gt; {
    return {
        type: actionTypes.STORE_RESULT,
        result: res
    };
}

export const storeResult = ( res ) =&amp;gt; {
    return dispatch =&amp;gt; {
        setTimeout( () =&amp;gt; {
            dispatch(saveResult(res));
        }, 2000 );
    }
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;使用midware之后怎样修改代码中的逻辑&quot;&gt;使用midWare之后怎样修改代码中的逻辑&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;action&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;reducer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;can run Async code&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;pure Sync code &lt;strong&gt;Only&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;should not prepare the state update too much&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;core redux concept : reducers update the state&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;所以需要修改逻辑的代码大都放置在reducer中&lt;/p&gt;

&lt;h4 id=&quot;use-action-creators-和-getstate&quot;&gt;use action creators 和 getState&lt;/h4&gt;
&lt;p&gt;在进行dispatch的async中，可以使用getState&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const storeResult = ( res ) =&amp;gt; {
    return (dispatch, getState) =&amp;gt; {
        setTimeout( () =&amp;gt; {
            const oldCounter = getState().ctr.counter;
            dispatch(saveResult(res));
        }, 2000 );
    }
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个可以在进行dispatch之前将原先的state获取，注意加入的getState参数是为了可以获取state，而且要加上对应定义state的reducer在App.js中的注册名。&lt;/p&gt;

&lt;h3 id=&quot;使用自定义的utility简化reducer中代码&quot;&gt;使用自定义的utility简化reducer中代码&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const updateObject = (oldObject, updatedValues) =&amp;gt; {
    return {
        ...oldObject,
        ...updatedValues
    }
}
// 调用时是
updateObject(state,{counter: state.counter - 1})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;action reducer&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/21/React-redux/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/21/React-redux/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>spinner</category>
        
        
      </item>
    
      <item>
        <title> React 页面设置Spinner 以及 form 表单操作 </title>
        <description>&lt;h3 id=&quot;实现spinner-也就是页面加载中&quot;&gt;实现Spinner 也就是页面加载中&lt;/h3&gt;
</description>
        <pubDate>Sun, 20 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/20/React-spiner/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/20/React-spiner/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>spinner</category>
        
        
      </item>
    
      <item>
        <title> React burger 页面axios以及Router </title>
        <description>&lt;h1 id=&quot;首先了解-axios-和-firebase-是什么&quot;&gt;首先了解 axios 和 firebase 是什么&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;axios 是一种 ajax 传参方式，导入的形式是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install --save axios&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;firebase 是google开发的数据库，代码中需要和数据库交互的部分放入firebase中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;axios使用的方式可以是&quot;&gt;axios使用的方式可以是&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import axios from 'axios'&lt;/code&gt;之后&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; componentDidMount() {
        axios.get('https://jsonplaceholder.typicode.com/posts')
            .then(response =&amp;gt; {
                const posts = response.data.slice(0, 4);
                const updatePosts = posts.map(post =&amp;gt; {
                    return {
                        ...post,
                        author: 'Max'
                    }
                })
                // console.log(&quot;response&quot;, response)
                this.setState({ posts: updatePosts })
            })
            .catch(error =&amp;gt; {
                console.log(error)
                // this.setState({ error: true })
            })
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上代码表示，在 component 完成整个页面渲染之后，通过 get 请求获得页面数据&lt;/p&gt;

&lt;p&gt;.then 代表页面进行不是线性的，在等待 axios 执行完成之后再执行 then 中的内容，response 返回的请求体，其中返回的是 get 到的内容。.catch 表示的是获取的错误信息，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{data: Array(100), status: 200, statusText: &quot;OK&quot;, headers: {…}, 
config: {url: &quot;/posts&quot;, method: &quot;get&quot;, headers: {…}, baseURL: &quot;http://jsonplaceholder.typicode.com&quot;, transformRequest: Array(1), …}
data:body: &quot;quia et suscipit↵suscipit recusandae consequuntur expedita et cum↵reprehenderit molestiae ut ut quas totam↵nostrum rerum est autem sunt rem eveniet architecto&quot;
id: 1
title: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;
userId: 1
headers: {cache-control: &quot;max-age=43200&quot;, content-type: &quot;application/json; charset=utf-8&quot;, expires: &quot;-1&quot;, pragma: &quot;no-cache&quot;}
request: XMLHttpRequest {readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …}
status: 200
statusText: &quot;OK&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也可以通过设置create属性的方式对所有的请求设置baseURL这样就可以不用对所有请求都加上同一种url，之后的请求写法就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;axios.get('/post')&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;详细的baseurl使用方式如下&quot;&gt;详细的baseURL使用方式如下&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const instance = axios.create({
    baseURL:'http://jsonplaceholder.typicode.com'
})
instance.defaults.headers.common['Authorization'] = 'AUTH TOKEN from Instance'//给每个header上都会加上一个请求头的默认值
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中的headers.common 给这个请求所有的headers都会加上一个 默认的Authorization&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;headers:
Accept: &quot;application/json, text/plain, */*&quot;
Authorization: &quot;AUTH TOKEN from Instance&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不只是在headers的commons中，在发送post请求时可以指定接收数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;['Content-Type'] = 'application/json';&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;axios拦截器的使用&quot;&gt;axios拦截器的使用&lt;/h4&gt;

&lt;p&gt;拦截器是axios的一种使用方式，表示对获得的response和发出的request做拦截，使用方式是&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;axios.interceptors.request.use(request =&amp;gt; {
    console.log(request);
    //Edit request
    return request;//一定要return 否则不能在component中使用
}, error =&amp;gt; {
    console.log(error);
    return Promise.reject(error)
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上代码表示在request中对获得请求头进行处理，不使用return request会导致后面的请求无法收到request所以一定要return。&lt;/p&gt;

&lt;p&gt;对于error的处理是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return Promise.reject(error)&lt;/code&gt;实现，其中Promise是ES6中基本数据类型，会有reject和resolve两个状态，是用来实现异步操作调用的方法。&lt;/p&gt;

&lt;p&gt;为了不使interceptor在内存中堆积，要使用eject 对缓存中的interceptors进行清除。 commponentWillMount 和 componentWillUnmount是开始和结束页面渲染标志。因为用了this.来存储了interceptors所以后面删除。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;componentWillMount () {
            this.reqInterceptor = axios.interceptors.request.use(req =&amp;gt; {
                this.setState({error: null});
                return req;
            });
            this.resInterceptor = axios.interceptors.response.use(res =&amp;gt; res, error =&amp;gt; {
                this.setState({error: error});
            });
        }

componentWillUnmount() {
            axios.interceptors.request.eject(this.reqInterceptor);
            axios.interceptors.response.eject(this.resInterceptor);
        }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用route来实现不同url页面之间相互的传递参数&quot;&gt;使用route来实现不同URL页面之间相互的传递参数。&lt;/h3&gt;

&lt;p&gt;route是react-router-dom中的实现方法，通过在App.js中引入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { BrowserRouter, Route } from 'react-router-dom';&lt;/code&gt;实现。&lt;/p&gt;

&lt;p&gt;在主程序的return中用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;BrowserRouter&amp;gt;&amp;lt;/BrowserRouter&amp;gt;&lt;/code&gt;包裹所有的App.js中需要包裹的代码，在导航的component中需要导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { Route } from 'react-router-dom'&lt;/code&gt;注意如果要真确使用一定要在App.js中同样导入Route。&lt;/p&gt;
&lt;h4 id=&quot;route使用方式&quot;&gt;Route使用方式&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route path=&quot;/&quot; exact render={()=&amp;gt;&amp;lt;h1&amp;gt;home&amp;lt;/h1&amp;gt;}/&amp;gt; 
&amp;lt;Route path=&quot;/&quot;  render={()=&amp;gt;&amp;lt;h1&amp;gt;home1 &amp;lt;/h1&amp;gt;}/&amp;gt; 
&amp;lt;Route path=&quot;/&quot; exact component={Posts}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route&amp;gt;&lt;/code&gt;中属性代表如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;exact: 表示path中的名称不是模糊的，如果没有exact那么所有path中包含”/” 的页面就都会有render之后的页面渲染效果。&lt;/li&gt;
  &lt;li&gt;path: 表示页面到哪里去&lt;/li&gt;
  &lt;li&gt;component: 表示页面render到一个component&lt;/li&gt;
  &lt;li&gt;render: 返回一个方法，可以是jsx语句&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何防止每次跳转页面不重新加载js&quot;&gt;如何防止每次跳转页面不重新加载js&lt;/h4&gt;

&lt;p&gt;在导航的component中需要导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import { Route，Link } from 'react-router-dom'&lt;/code&gt;
使用Link代替&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;html语言，使用
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Link to='/'&amp;gt;&lt;/code&gt;代替了原本的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;href='/'&lt;/code&gt;
使用方式加强版&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Link to=&amp;gt;New Post&amp;lt;/Link&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;将pathname设置为new-post 表示绝对路径，如果想要显示相对路径  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.props.match.url + '/new-post'&lt;/code&gt;表示相对路径&lt;/li&gt;
  &lt;li&gt;hash表示可以跳转到页面的摸个部分&lt;/li&gt;
  &lt;li&gt;search表示可以对这个页面的某个地方实现查找，都是后话了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;这里的知识点就是 如果将参数传入为search形式，在后面怎样读取出来&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先理解for of 概念 也就是一种for each 循环形式
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for (let i of arr){...}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在后面调用的地方使用的是
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const query=new URLSearchParams(this.props.location.search)&lt;/code&gt; 表示通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URLSearchParams&lt;/code&gt;将默认存储在location中的search提取。&lt;/li&gt;
  &lt;li&gt;URLSearchParams暴露一个entries方法可以获得当时传入search中的内容,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;quick-sumbit&lt;/code&gt;是key&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;是value，最后会返回两个值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;quick-sumbit&quot;,&quot;true&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原始获得search中内容代码如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;componentDidMount(){
        const query=new URLSearchParams(this.props.location.search);
        console.log(query)// 显示是一个obj
        for(let param of query.entries()){
            console.log(param);// 暴露出来的 entries方法
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;总结使用方法：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;route首先定义了跳转也买的path，再用指定的Component表示跳转的模块；&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;link表示点击某按键实现页面的跳转，这个按键中的pathname要包括匹配route中的path&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;如何实现每次加载页面能够获得最近的一个router页面的信息&quot;&gt;如何实现每次加载页面能够获得最近的一个router页面的信息&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;在之前使用了Link，表示component之间不重新渲染页面、不重新加载state后的传参魔法，Link到的component中props中有match等详细参数，表示上一个component的信息，但是对于不在route中的component来说，想要获得离其最近的router中的参数需要调用高阶函数(higher order component)，也就是在`export default XX`中对XX进行包裹的函数，其实相当于Aux，通过props.children传递参数，使用方式
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { withRouter } from 'react-router-dom';
...
export default withRouter(post);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样的Link如何进行style将这个Link显示成为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NavLink&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;NavLink
  to=&quot;/&quot;
  exact
  activeClassName=&quot;activeProps&quot;
  activeStyle={
    {
      ...
  }
}
&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就实现了一个页面的默认导航按钮的位置确认&lt;/p&gt;

&lt;h4 id=&quot;动态传入component页面间的参数-pass-routing-params&quot;&gt;动态传入component页面间的参数 Pass routing params&lt;/h4&gt;

&lt;p&gt;实现方式:在Route path 的 位置写上&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route path=&quot;/:id&quot; exact component={FullPost}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示转换为动态id传参，这里的id参数来源是动态显示的，不是固定值，需要绑定不同的值在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Link to={id}&amp;gt;&lt;/code&gt;中的id跟随需求改变。&lt;/p&gt;

&lt;p&gt;在跳转到的component界面显示的内容，之后可能会产生有歧义的现象，因为不同的界面可能会出现&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route path=&quot;/new-post&quot;  component={NewPost}/&amp;gt;
&amp;lt;Route path=&quot;/:id&quot; exact component={FullPost}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样的情况下，可能会认为new-post也是一个id也会产生传参问题，解决方式是在外层包裹上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Switch&amp;gt;&amp;lt;/Switch&lt;/code&gt;，表示只渲染第一个Route。所以对于Route来说 &lt;strong&gt;位置很重要&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用nested-route-表示两个componentrender的时候摆在一个页面上&quot;&gt;使用nested Route 表示两个componentrender的时候摆在一个页面上&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;这里的例子是在主页面上点击某按钮就能显示另一个component中的东西，在主页面要点击的地方加入Route写好对应的path同时注意主页面中不再使用那个Route而且为了防止出现exact不能动态加载的情况不使用exact。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;react小知识，对于两个不同数据类型int string如果只是想比较value可以使用!=而不是!==&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;conditional-redirect&quot;&gt;conditional redirect&lt;/h4&gt;

&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Redirect from=&quot;/new-post&quot; to=&quot;/posts/&quot;&amp;gt;&lt;/code&gt;实现参数传递，表示页面跳转，比如输入结束之后调用axios的post同时跳转到之前的页面可以使用条件式的跳转机制，或者是直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.props.history.replace('/posts')&lt;/code&gt;实现跳转。&lt;/p&gt;

&lt;h4 id=&quot;使用guards&quot;&gt;使用guards&lt;/h4&gt;
&lt;p&gt;在没有authentication情况下使用guard，没有什么组件，使用state和dirty的inline判断来guard&lt;/p&gt;

&lt;h4 id=&quot;使用lazily-load-route&quot;&gt;使用lazily load route&lt;/h4&gt;

&lt;p&gt;在bundle文件中会默认加载所有页面上会渲染到的文件，为了不再一开始就全部加载，导致时间过长，可以使用lazy加载方式，也就是Async异步策略。
写入高阶组件，需要传入的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;importComponet&lt;/code&gt;是一个函数&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React,{Component} from 'react';
const asyncComponent = (importComponet) =&amp;gt;{
    return class extends Component{
        state = {
            component:null
        }
        componentDidMount(){
            importComponet()
            .then(cmp
            =&amp;gt;{
                this.setState({
                  component:cmp.default  
                });
            });
        }
        render() {
            const C = this.state.component;
            return C ?&amp;lt;C {...this.props} /&amp;gt; :null;
        }
    }
}
export default asyncComponent;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用的格式是在一开始加载的页面中，先导入上面定义的asyncComponent方法，之后再通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import()&lt;/code&gt;关键字导入需要异步加载的模块。asyncComponent中传入的是匿名函数，也就是前面定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;importComponet&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import asyncComponent from '../../../hoc/asyncComponent';
const AsyncNewPost = asyncComponent(()=&amp;gt; {
    return import('./NewPost/NewPost');
})
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import()&lt;/code&gt;中传入的是需要异步加载的模块的相对位置，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import xx from '..//'&lt;/code&gt;的这种位置。&lt;/p&gt;

&lt;p&gt;同时因为加载的AsyncNewPost也是一个component，所以在最后的Route中也是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route path=&quot;/new-post&quot;  component={AsyncNewPost}/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;替换了原先的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Route path=&quot;/new-post&quot; component={NewPost} /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;react166以上的lazy加载方式&quot;&gt;react16.6以上的lazy加载方式&lt;/h4&gt;

&lt;p&gt;使用suspend
具体实现方式，在主界面引入Suspense&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import React, {Component, Suspense} from 'react'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在定义class之前定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.lazy()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;const Posts = React.lazy(()=&amp;gt; import('Posts位置'))
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在主界面render()位置&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Route render={()=&amp;gt;(
    &amp;lt;Suspense fallback={&amp;lt;div&amp;gt;Loading&amp;lt;/div&amp;gt;}&amp;gt;
        &amp;lt;Posts/&amp;gt;
    &amp;lt;/Suspense&amp;gt;)}/&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;do-not-go-gentle-into-that-good-night-不要温驯的走进那个良夜&quot;&gt;Do not go gentle into that good night. 不要温驯的走进那个良夜&lt;/h3&gt;

&lt;p&gt;Do not go gentle into that good night,&lt;/p&gt;

&lt;p&gt;Old age should burn and rave at close of day;&lt;/p&gt;

&lt;p&gt;Rage, rage against the dying of the light.
&lt;img src=&quot;/img/react-axios.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/18/React-axios/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/18/React-axios/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>no class basing</category>
        
        <category>axios</category>
        
        <category>router</category>
        
        <category>Do not go gentle into that good night.</category>
        
        
      </item>
    
      <item>
        <title> React 笔记 </title>
        <description>&lt;h3 id=&quot;react-语法-小知识点&quot;&gt;React 语法 小知识点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export default xxx&lt;/code&gt; 在后面导入的时候是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import xxx from ''&lt;/code&gt;， 但是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export const xxx&lt;/code&gt; 时 后面导入要求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import {xxx} from ''&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ES7中代码编写的特点，不再使用this关键字了
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;constructor (){this.property = 'xxx'}&lt;/code&gt;转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;property = 'xxx&lt;/code&gt;;
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method () {...}&lt;/code&gt;转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method = () =&amp;gt;{...}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt; spread  数组&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const newArray = [...oldArray,1,2]&lt;/code&gt;；Object&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const newObj = {... oldObj, newProp:5}&lt;/code&gt; 如果oldObj也有newProp，新的Obj会覆盖newProp。
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt; rest 针对方法的填充 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function sortArg(...args){return args.sort()}&lt;/code&gt;。注意，使用…表示创建了新的对象。同时对于array concat表示创建新数组，但是push不能创建新数组，所以在redux中能够使用concat的地方就不用push。&lt;/li&gt;
  &lt;li&gt;destructuring 不创建新对象的抽取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[a,b] = ['a', 'b']&lt;/code&gt;此时单独拿a或者b都不算创建新的对象，适用于array和obj。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reference&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;primitive&lt;/code&gt;格式，object和array都是reference所以copy之后会联动修改，但是常量不会，因为常量是primitive格式的。解决联动修改的方法是给copy那一方加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; cosnt person = {name:'max'};
 const secondPersion = {...person,name:'min'};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;filter 适用于 array 的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;react-建立项目以及语法&quot;&gt;React 建立项目以及语法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;sudo npm install create-react-app -g&lt;/li&gt;
  &lt;li&gt;create-react-app react-complete-guide –scripts-version 1.1.5 不是为了加载react的版本，是为了项目结构一致&lt;/li&gt;
  &lt;li&gt;进入dir react-complete-guide npm start&lt;/li&gt;
  &lt;li&gt;理解项目结构
    &lt;ul&gt;
      &lt;li&gt;public web 服务器中显示的界面，index.html 如果是多页面也不会有多个html，这个页面可以导入css依赖&lt;/li&gt;
      &lt;li&gt;src 文件是js和css文件名一一对应，注意在index.js中最好只有一个Component&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;jsx概念：react语法糖，就是js中包裹了HTML，实际上还是js。&lt;/li&gt;
  &lt;li&gt;不能在Component中写class即HTML中class属性被className代替；一个render 的return 只能有一个 root element 并列是不允许的。&lt;/li&gt;
  &lt;li&gt;以小写开头的component是HTML中的，自定义一般大写。&lt;/li&gt;
  &lt;li&gt;dynamic content { }&lt;/li&gt;
  &lt;li&gt;props ，props.children 是在opening component中展示的&amp;lt;P&amp;gt; xxx &amp;lt;/P&amp;gt; 在调用的时候就是props.children&lt;/li&gt;
  &lt;li&gt;在return中定义的方法是不会加上()，因为这样每次页面一加载就会调用这个方法，常见做法是只传入名字。&lt;/li&gt;
  &lt;li&gt;state 在更新state时不是override而是会保留没有修改的state&lt;/li&gt;
  &lt;li&gt;react hook介绍：首先是不再用class定义component而是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const component名 = props =&amp;gt;{}&lt;/code&gt;，其中可以写入方法。而且在component中不再使用render。hook不再使用Component关键字，而是使用以use开头的关键字如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;。
    &lt;ul&gt;
      &lt;li&gt;useState 用法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const [state名, 更新state的方法名] = useState(初始化的state可以是任何形式的数据)&lt;/code&gt;；同时需要注意，&lt;strong&gt;在useState中更新state的方法不会merge原有的state！！！&lt;/strong&gt;，所以在hook中可以有多个useState。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;method在componet之间传递，使用props，如果方法需要参数，可以使用以下两种方法，但是比较推荐第一种的bind，提高效率。
    &lt;ul&gt;
      &lt;li&gt;在调用方法的那一端使用bind(this,参数)&lt;/li&gt;
      &lt;li&gt;或者是使用匿名函数包裹并传入参数()=&amp;gt;this.func(参数)； 如果有event要传入需要在&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;add two way binding, 动态传入用的是onChange 执行的时候自动传入event 获得修改的是event.target.value,但是在一开始并没有输入，所以使用了 value={props.value}当做初始值。&lt;/li&gt;
  &lt;li&gt;要在jsx中加上css文件需要导入&lt;/li&gt;
  &lt;li&gt;在return中不能使用if而是用{ ? :  },如果不想在HTML中使用{}扩上大段的HTML可以在render和return之间加上一个let变量，这样就可以使用if语句。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在jsx中使用&lt;strong&gt;map&lt;/strong&gt;来渲染list类型的数据:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   persons :[
       {name:'l1',age:12},
       {name:'l2',age:13}
   ]
   render(
       return {
           &amp;lt;div&amp;gt;
               {this.persons.map((person,index) =&amp;gt;{ // map需要一个key 这个index就是作用在map中的key，要保证key是不同的，所以这里其实不能用index因为list改变可能会使用相同index，在给用户数据的时候需要一个不同的key，这个可以是list再定义一个id
                   // 这里的person就是  {name:'l1',age:12} 
                   return &amp;lt;Person name={person.name} age={person.age} key={index}&amp;gt;
               })} 
           &amp;lt;/div&amp;gt;
       }
   )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;事件监听event,在传入method中如果要加入event作为参数，并且在调用的方法中是使用onClick等将(event) =&amp;gt;{调用的函数(event)} 作为props传入另外的页面。&lt;/li&gt;
  &lt;li&gt;使用join和数组对className做动态处理66-67&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在button上加上hover，需要引入 npm install –save radium 在export default 用Radium(Component)包裹当前component之后在定义的inline css中。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;       const style={
           color: 'red',
           ':hover':{
               backgroundColor:'lightblue'
           }
       }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;当然在动态调用这个style的时候一般是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style.color='red'&lt;/code&gt;，但是针对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:hover&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style[':hover']={覆盖原来属性}&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@media query 根据页面大小调整边距占比。一般是用在CSS中，但是Radium可以帮助调整，在最外层的App.js上套用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import Radium,{StyleRoot} from 'radium&lt;/code&gt;导入 StyleRoot 来引入 ，再wrap 所有Html到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;StyleRoot&amp;gt;&amp;lt;/StyleRoot&amp;gt;&lt;/code&gt;中，在单独需要作用的界面上,需要单独写好 @media同时在export时用Radium包裹。
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const style = {
'@media(min-width:500px)':{
    width:'450px'
}
 }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;styled Component是一个专门做css style的工具，npm install –save styled-components加载
    &lt;a href=&quot;https://styled-components.com/&quot; target=&quot;_blank&quot;&gt;styled-components&lt;/a&gt;
 用法：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   import styled from 'styled-components';
   const StyleDiv = styled.div` //这里可以使用任何html中的标签 h1,span等
           width:12px,
           margin:...,
           @media (min-width:500px):{
               width:450px
           }
           //写入任何css中的style，不需要加上selector
           `//这里用到的`号！！！
   const example = (props) =&amp;gt;{
       return (
           &amp;lt;StyleDiv&amp;gt;
           包裹住想要加上css的标签
           &amp;lt;/StyleDiv&amp;gt;    
       )
   }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;同样 要动态的修改css可以在以上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;styled.div 中使用 ${}&lt;/code&gt;传入props 因为styled-componets定义的css是一个component。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;利用css module实现对单独需要的component进行渲染，好处是不用在整个css文件中渲染导致有相同className的元素共用一个css， 使用react-script版本为1.x.x，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm run eject&lt;/code&gt;编写buddle文件
 在 config/webpack.config.dev.js和 config/webpack.config.props.js中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; test: /\.css$/&lt;/code&gt;项目下给use中的options加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules:true,localIdentName:'[name]_[local]_[hash:base64:51]'&lt;/code&gt;表示给每个css文件加上modules而且命名也不同，在正式使用的过程中使用以下方式导入：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;       import classes from 'XXX.css';//导入css文件 
       render(
           return (
               &amp;lt;div&amp;gt;
                   &amp;lt;button className={classes.在css文件中以class为selector的名称}&amp;gt;
               &amp;lt;/div&amp;gt;
           )
       )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在检查界面看到这个css的class名为 “使用此css的component名_在css文件中定义的classSelector名_随机的hash”,动态加载的界面同样使用join和push来加载，在css文件中可以指定两个classSelector就能通过push传入多个class。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;react-debug&quot;&gt;React debug&lt;/h3&gt;
&lt;p&gt;在react 16中写入ErrorBoundary文件夹 写入ErrorBoundary 只在有需要时显示customer error message&lt;/p&gt;

&lt;h3 id=&quot;dive-deep-into-react-component--react-internals&quot;&gt;Dive deep into React component &amp;amp; react internals&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;class component create lifecycle hook（ 和 react hook无关）
  因为class based 和 functional based 的component对state的要求不同，所以 lifecycle 只在class based上保有。
    &lt;ol&gt;
      &lt;li&gt;constructor(props) set up state&lt;/li&gt;
      &lt;li&gt;getDerivedStateFromProps 不常用 sync state&lt;/li&gt;
      &lt;li&gt;render&lt;/li&gt;
      &lt;li&gt;render child component&lt;/li&gt;
      &lt;li&gt;componetDidMount() 不要update state 会trigger re-render&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lifecycle update props and state&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getDerivedStateFromProps 不常用&lt;/li&gt;
      &lt;li&gt;shouldComponentUpdate 确定是否继续&lt;/li&gt;
      &lt;li&gt;render&lt;/li&gt;
      &lt;li&gt;update child props&lt;/li&gt;
      &lt;li&gt;getSnapshotBeforeUpdate 获得最后一刻dom的信息&lt;/li&gt;
      &lt;li&gt;componentDidUpdate cause side effects 不要update state&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;functional component hook&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;useEffect default run for every render cycle 每次修改都会调用&lt;/li&gt;
      &lt;li&gt;useEffect (()=&amp;gt;{},[依赖])，可以多次使用，只在依赖改变的时候才执行，如果依赖为空表示只在第一次render的时候执行，但是一定要加上依赖为[]的空数组才能表达这个意思。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;clean life cycle &amp;amp; useEffect&lt;/p&gt;

        &lt;p&gt;在useEffect 中执行return可以是一个方法，在第一次的main useEffect 执行之前 执行，但是在第一次render之后执行，在其中加上的return就是消除本次useEffect的中执行内容对页面的影响。&lt;/p&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;     useEffect (()=&amp;gt;{
         const timer = setTimeout(()=&amp;gt;{alert('')},1000);
         return ()=&amp;gt;{
             cleanTimeout(timer);
         }
         },[]);

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use shouldComponentUpdate for Optimize&lt;/p&gt;

    &lt;p&gt;利用shouldComponentUpdate来优化 
  shouldComponentUpdate中包含参数nextProps, nextState可以通过判断这两个参数是否需要更新来优化代码，避免re-render多余部分。 Chrome -&amp;gt;more tool-&amp;gt;rendering 查看是否有多余render&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optimize functional component with React.memo()适用于functional component&lt;/p&gt;

    &lt;p&gt;React.memo(component)只有input改变才会render这个component&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;问题来了 什么时候应该optimize&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;parent update -&amp;gt; 本component就要render, 没必要的check。&lt;/li&gt;
      &lt;li&gt;pureComponents instead of shouldComponentUpdate
  pureComponent 是 normal 的 component，传入的参数多，不需要每个都检查是否更新了，将原来继承的{Component}修改为{PureComponent}帮助检查参数是否更新，不必多写shouldComponentUpdate代码。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;how react update real dom&lt;/p&gt;

    &lt;p&gt;一般情况下，无论class-based 还是 functional-based的 都会反映到react的虚拟dom上， 
  shouldComponentUpdate() =&amp;gt;render() is called  但是 render{} doesn’t immediately update the “real dom”&lt;/p&gt;

    &lt;p&gt;react 保留两个 dom&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;1) old virtual dom (比real dom 快)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;2) re-rendered Virtual dom&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;比较以上两个dom 是否改变 改变了就update real 不改就是不update&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;render Adjacent JSX elements&lt;/p&gt;

    &lt;p&gt;只能在return中保有一个root element,如果想要多个adjacent elements&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;1）用array将其包裹，传入key可以实现多个element在return中渲染。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;2）使用Aux component props.children实现多个element渲染&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use React.Fragment&lt;/p&gt;

    &lt;p&gt;和上面Aux 传props.children 是一个用处&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Higher Order Component (HOC)&lt;/p&gt;

    &lt;p&gt;以With…开头 使用example，可以用来handle http error&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      使用时
      WithClass from '../...'
      &amp;lt;WithClass classes={}&amp;gt;
      &amp;lt;/WithClass&amp;gt;
       ====================
      import React from 'react';
      const WithClass = props =&amp;gt;{
          &amp;lt;div className={props.classes}&amp;gt;props.children&amp;lt;/div&amp;gt;
      };
      export default withClass;
        
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;其他形式的HOC，function return 一个function component&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      const withClass = (WrappedComponent, className) =&amp;gt;{//不是 functional component
          return props =&amp;gt;{
              &amp;lt;div className={className}&amp;gt;
                  &amp;lt;WrappedComponent&amp;gt;
              &amp;lt;/div&amp;gt;
          }
      };
      export default withClass;
      ============================
      使用时是normal function
      用withClass(需要包裹的component, className)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;passing unknown props&lt;/p&gt;

    &lt;p&gt;是针对HOC传入时 props丢失的情况， 使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;WrappedComponent {...props}&amp;gt;&lt;/code&gt;获得原先需要传入的props&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎样防止错误的 setState&lt;/p&gt;

    &lt;p&gt;sync情况，多个setState同时改变state导致state不能保证哪个是最新的，解决方式
 this.setState((prevState, props)={return {新state的修改}})&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新PropsType&lt;/p&gt;

    &lt;p&gt;如果产生错误的传入props的格式，比如age应该是number ，导入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm instal --save prop-type&lt;/code&gt; import 之后在使用的时候是在定义需要传入props的component中的export之前加上每个props的定义：&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      Component.propTypes = {
          propname:PropType.func,
          name:PropType.string,
          ...
      };
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use Refs 暂时没明白什么作用&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ref=”“&lt;/strong&gt; key word class-based 的 component
  在打开页面的时候在哪里定位 
  在function-based component中 使用
  useRef&lt;br /&gt;
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cosnt toggleBtnFre = useRef(null);&lt;/code&gt;
  在useEffect 中使用 toggleBtnRef
  jsx中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;button ref={toggleBtnFre}&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;use Context API&lt;/p&gt;

    &lt;p&gt;用于在一个component中需要certain data inmultiple components and do not want to pass that data across multiple layers
  比如 确认用户是否login 但是会有一些功能在没有login的时候也能用&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      const context = React.createContext({
          default value:''//格式是string array
      })
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;pass within without using props ，在需要的地方引入&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      &amp;lt;Context.Provider value=&amp;gt;
      包裹住需要传入的props
      &amp;lt;/Context.Provider&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;使用&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  ```
  &amp;lt;Context.Consumer&amp;gt;//返回的是一个function 以context为 参数
  {(context)=&amp;gt; context 中的value }
  &amp;lt;/Context.Consumer&amp;gt;   ```
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;当然有更加简洁的表达方式，使用useContext 作为function-based 或者定义静态contextType变量再调用实现，详见114。其实类似于redux。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;react-中小知识点&quot;&gt;React 中小知识点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;preventDefault 在event事件被加载之前，为了不再request，需要调用这个方法。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 11 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/11/React%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/11/React%E7%AC%94%E8%AE%B0/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        
      </item>
    
      <item>
        <title> React 制作一个burger </title>
        <description>&lt;h3 id=&quot;planning-a-react-app怎样构建一个-app&quot;&gt;Planning a React App怎样构建一个 app&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;component Tree / structure&lt;/li&gt;
  &lt;li&gt;application state&lt;/li&gt;
  &lt;li&gt;components vs containers
 structure:
 APP
    &lt;ul&gt;
      &lt;li&gt;toolbar
        &lt;ul&gt;
          &lt;li&gt;drower toggle&lt;/li&gt;
          &lt;li&gt;logo&lt;/li&gt;
          &lt;li&gt;navigation items&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;sideDrawer
        &lt;ul&gt;
          &lt;li&gt;logo&lt;/li&gt;
          &lt;li&gt;navigation items&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;backDrop&lt;/li&gt;
      &lt;li&gt;props.children
        &lt;ul&gt;
          &lt;li&gt;burger build control …order button&lt;/li&gt;
          &lt;li&gt;burger&lt;/li&gt;
          &lt;li&gt;modal
 State 
ingredient （meat * 2, cheese *2）
purchase :true /false
price&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在开始项目之前可以先将 css设定好
Optional:&lt;/p&gt;

&lt;p&gt;If you still want to eject and manually adjust the Webpack config (as we do it in the new videos - which you don’t need to do if you follow the approach described in the link above), you should take the below comments into account in case your webpack config (after ejecting) doesn’t look the same as it does in my videos:&lt;/p&gt;

&lt;p&gt;After ejecting, we edit a Webpack config file that’s made available by ejecting. This file might look slightly different for you.&lt;/p&gt;

&lt;p&gt;In the video, I’ll look for an entry that starts like this (in the webpack.config.js file):&lt;/p&gt;

&lt;p&gt;{
  test: /.css$/,
  …
}
and I then edit this entry.&lt;/p&gt;

&lt;p&gt;This entry now looks slightly different. You’ll have to find the following part in your webpack.config.js file:&lt;/p&gt;

&lt;p&gt;{
  test: cssRegex,
  exclude: cssModuleRegex,
  …
}
and then edit that entry.&lt;/p&gt;

&lt;p&gt;Finally, it should look like this:&lt;/p&gt;

&lt;p&gt;{
  test: cssRegex,
  exclude: cssModuleRegex,
  use: getStyleLoaders({
      importLoaders: 1,
      modules: true,
      localIdentName: ‘[name]&lt;strong&gt;[local]&lt;/strong&gt;[hash:base64:5]’
  }),
}
You can ignore me editing the webpack.config.prod.js file - with the latest version of create-react-app, ejecting only gives you ONE webpack config file (which you edit as described above).&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/11/React%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAburger/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/11/React%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAburger/</guid>
        
        <category>react</category>
        
        <category>self-learning</category>
        
        <category>class-based</category>
        
        
      </item>
    
      <item>
        <title> React Native 设备加载 </title>
        <description>&lt;h2 id=&quot;react-native-实现手机端的相机加载&quot;&gt;React Native 实现手机端的相机加载&lt;/h2&gt;

&lt;p&gt;需要了解到 expo 作为一个基础平台提供了很多工具，比如加载数据库，获取手机的权限，打开相机并拍照等功能，所以利用 expo 提供的 API 实现一个能打开相机，保存拍摄的图片，获得当前位置，在地图上展现出当前位置的 App。&lt;/p&gt;

&lt;h2 id=&quot;基础界面&quot;&gt;基础界面&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;分为 4 个界面
    &lt;ul&gt;
      &lt;li&gt;MapScreen &lt;em&gt;地图界面&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;NewPlaceScreen &lt;em&gt;创建新的图片和位置界面&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;PlaceDetailScreen &lt;em&gt;位置详细信息界面&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;PlacesListScreen &lt;em&gt;所有位置的渲染界面&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react-native-实现设备拍摄照片&quot;&gt;React Native 实现设备拍摄照片&lt;/h2&gt;

&lt;p&gt;用户在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImagePicker.launchCameraAsync({...})&lt;/code&gt;中获得的图像的URI即存储路径，同样其导入是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expo install expo-image-picker&lt;/code&gt;可以在官方文档的ImagePicker中找到用法,同样不光需要拍摄，在拍摄前需要获取device的权限，需要用到Permissions API&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import * as ImagePicker from 'expo-image-picker'; 
import * as Permissions from 'expo-permissions';

const verfiypermissions = async () =&amp;gt; {
        // 这个方法在用户确认后会自动保存在设备上， 用户不需要再次使用
        const result = await Permissions.askAsync(Permissions.CAMERA, Permissions.CAMERA_ROLL)// return 一个Promise
        if (result.status !== 'granted') {
            // 如果没有授权 
            Alert.alert('Insufficient Permissions!',
                'You need to grant camera permissions to use this app.',
                [{ text: 'okey' }]
            );
            return false;
        }
        return true;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;react-native-实现保存照片到本地device&quot;&gt;React Native 实现保存照片到本地device&lt;/h2&gt;

&lt;h2 id=&quot;react-native-实现-sqlite-数据库连接&quot;&gt;React Native 实现 SQLite 数据库连接&lt;/h2&gt;

&lt;p&gt;首先对数据库的连接是在创建 shopApp 中做的，这里是将 fetch 的网页连接变成实际的数据库，当然调用的是用原生 Sql 语言编写，expo 的 SQLite API 提供了事务性。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先定义一个 helpers 包和 App.js 同级，这个是为了更好的调用数据库，其中写入 db.js 文件
在终端中导入包 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expo install expo-sqlite&lt;/code&gt;可以在官方文档的SQLite中找到用法&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面代码定义了创建一个 places 数据库，首先是新建一个 Promise,其中的 SQLite.openDatabase(…) 在官方文档中 Open a database, creating it if it doesn’t exist, and return a Database object,利用 Promise 包裹住这个事务是保证有 error 时可以在 await 中 catch 住。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import * as SQLite from 'expo-sqlite';

const db = SQLite.openDatabase('place.db');

export const init = () =&amp;gt; {
    //create basic table
    const promise = new Promise((resolve, reject) =&amp;gt; {
        db.transaction((tx) =&amp;gt; {
            // transaction保证事务性
            tx.executeSql(&quot;CREATE TABLE IF NOT EXISTS places (id INTEGER PRIMARY KEY NOT NULL, title TEXT NOT NULL, imageUri TEXT NOT NULL, address TEXT NOT NULL, lat REAL NOT NULL, lng REAL NOT NULL)&quot;,
                [],
                () =&amp;gt; {
                    // SUCCESS
                    resolve();
                },
                (_, err) =&amp;gt; {//第一个参数是 repeition of query ,第二个才是需要的error信息
                    // error
                    reject(err);
                }
            );
        });
    });
    return promise;
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 store/places-actions.js 中来获得数据库传入的数据
这里的 FileSystem.documentDirectory 又是 expo 提供的 API 需要先导入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expo install expo-file-system&lt;/code&gt;可以在官方文档的FileSystem中找到用法作用是：provides access to a file system stored locally on the device. Within the Expo client, each app has a separate file system and has no access to the file system of other Expo apps.这里是为了将拍下来的照片存入device。&lt;/p&gt;

    &lt;p&gt;其中addPlace是需要在NewPlaceScreen中载入的图片，其中传入的参数，一个是用户输入的title,一个是存入缓存中的imageUri,一路follow其实传递路线是&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export const addPlace = (title, image) =&amp;gt; {
    return async dispatch =&amp;gt; {
        // 需要dispatch的方法
        const fileName = image.split('/').pop();
        const newPath = FileSystem.documentDirectory + fileName;
        console.log(newPath)

        try {
            await FileSystem.moveAsync({// 存储位置 从哪里来 到哪里去
                from: image,
                to: newPath
            });
            const dbResult = await insertPlace(
                title,
                newPath,
                'Dummey Address',
                15.6,
                12.3
            );
            console.log(dbResult);
            dispatch({ type: ADD_PLACE, placeData:
            { id: dbResult.insertId,
            title: title,
            image: newPath } });

        } catch (err) {
            console.log(err);
            throw (err);
        }
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;react-native-实现手机端获得地址&quot;&gt;React Native 实现手机端获得地址&lt;/h2&gt;

&lt;h2 id=&quot;react-native-百度地图实现静态地图渲染&quot;&gt;React Native 百度地图实现静态地图渲染&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://lbsyun.baidu.com/index.php?title=static&quot; target=&quot;_blank&quot;&gt;百度地图开发者获得静态地图界面&lt;/a&gt;
原始的教程中是 Google Map 获得 API 但是需要绑定 credit card 以及连接 VPN，这里利用百度地图也可以实现类似功能，就是界面有点难找：）&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/06/React-Native%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E6%89%8B%E6%9C%BA%E5%8A%A0%E8%BD%BD/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/06/React-Native%E5%AE%9E%E7%8E%B0%E7%9B%B8%E6%9C%BA%E6%89%8B%E6%9C%BA%E5%8A%A0%E8%BD%BD/</guid>
        
        <category>react native</category>
        
        <category>self-learning</category>
        
        <category>permission</category>
        
        
      </item>
    
      <item>
        <title> React Native 建立一个购物App </title>
        <description>&lt;h3 id=&quot;react-native-概述&quot;&gt;React Native 概述&lt;/h3&gt;

&lt;p&gt;是一种适用于手机端的前端编程语言， 适用于IOS和Android，但是在Android的使用中应该是不能很好兼容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;React Native以下称为RN&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编程软件 Visual Studio, 需要预先加载的是npm，可以自动帮助渲染，学习资料来源于Udemy上的React Native教程，老师是德国人&lt;em&gt;Maximilian Schwarzmüller&lt;/em&gt;， 讲述很详实，带着学生一点一点搭建一个购物网站。&lt;a href=&quot;http://udemy.com/course/react-native-the-practical-guide&quot; target=&quot;_blank&quot;&gt;udemy&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;

&lt;p&gt;首先要了解RN作为一个前端编程语言能够实现的功能。在开始学习前要至少掌握JS最基本的语法，&lt;a href=&quot;https://es6.ruanyifeng.com/?search=AsyncStorage&amp;amp;x=0&amp;amp;y=0#&quot; target=&quot;_blank&quot;&gt;ES6(阮一峰)&lt;/a&gt;，这个链接在遇到未知的语法时可以随时查看。
React 知识也需要知道，能够理解props和state作用即可。&lt;/p&gt;

&lt;h3 id=&quot;实现源码&quot;&gt;实现源码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JoyDajunSpaceCraft/react-native-for-a-shop&quot; target=&quot;_blank&quot;&gt;JoyDajunSpaceCraft/react-native-for-a-shop&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;expo init &lt;em&gt;你的RN文件名&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;选择template 选择 第一个blank即可&lt;/li&gt;
  &lt;li&gt;进入以刚刚RN文件命名的 dir 执行 npm start&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;作为基本条件，需要安装npm，npm作为web端打包软件可以帮助加载RN中需要包。&lt;/p&gt;

&lt;p&gt;以下就是执行成功&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- cd rn-device-feature-app
- npm start # you can open iOS, Android, or web from here, or run them directly with the commands below.
- npm run android
- npm run ios
- npm run web
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;网页端自动出现http://localhost:19002/ 界面可以点击里面的 Run on XXX 在电脑端打开模拟界面。如果是手机需要模拟，需要下载expo，而且确保手机和电脑处于一个网络环境下。&lt;/p&gt;

&lt;p&gt;如果想要调试在电脑模拟界面(mac -&amp;gt; ios) &lt;em&gt;cmd + D&lt;/em&gt; 点击 &lt;em&gt;Debug remote JS&lt;/em&gt;，在浏览器中能够实现debug，如果是要界面精美，有data flow的debug，可下载 react native debugger实现精细化debug。当然对我比较适用的是笨办法，打开Termial，console.log。&lt;/p&gt;

&lt;h4 id=&quot;前期准备&quot;&gt;前期准备&lt;/h4&gt;

&lt;p&gt;如果有多页面需求 可以在 &lt;a href=&quot;https://reactnavigation.org/docs/getting-started&quot; target=&quot;_blank&quot;&gt;react-navigation/doc/getstart&lt;/a&gt;中找到加载navigation的包。
 我把需要导入的包都写入App.js开头注释中，在其他页面的开头注释中也会有相应要导入的依赖包。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;导入 redux 请按照以下形式在终端中导入
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; npm install --save redux react-redux redux-thunk
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;利用RN作为前端，redux实现component中相互传递参数，其中用到了useEffect, useState,useCallback等在”react-native”中需要传入的参数。这里用到的代码引入是：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; import React, {...}  from 'react';
 import {...} from 'react-native';
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;将要用到的数据库 database：firebase 用来获得token等和存储数据。firebase是google开发所以登录时需要能够&lt;strong&gt;VPN&lt;/strong&gt;连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;整体结构&quot;&gt;整体结构&lt;/h4&gt;
&lt;p&gt;在已经创建好的基础上显示的结构，我们能够用到的是App.js作为主文件，其他结构需要自己创建。
 需要自己增加的结构如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;components           &lt;em&gt;在较大的页面中需要加载的小部分，一个页面中的一小块&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;constants            &lt;em&gt;放置常用的常量，比如整体的颜色设定&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;model                &lt;em&gt;放入定义的数据的格式，例如一件商品的名称、价格、描述和图片链接&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;navigation           &lt;em&gt;页面导航&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;screens              &lt;em&gt;主要页面&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;store                &lt;em&gt;存放reduer和action&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;这里的模块都是本项目所使用的，并不代表一定需要这样创建&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;手动实践&quot;&gt;手动实践&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;界面的加载&lt;/li&gt;
  &lt;li&gt;类似于css的style渲染，在RN中的页面布局不是用CSS，而是用和其类似的StyleSheet 导入方式是&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { StyleSheet } from 'react-native';
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是输入RN原生组件一部分，同样可以导入的有 { View, Text, TextInput, Button,…}遇到详细的可以细说，首先要掌握的是RN中的StyleSheet使用方式。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import { View, Button, StyleSheet, Image } from 'react-native';

&amp;lt;View style={styles.imagePicker}&amp;gt;
            &amp;lt;View style={styles.imagePreview}&amp;gt;
                &amp;lt;Text&amp;gt;
                    No image pick yet
                &amp;lt;/Text&amp;gt;
                &amp;lt;Image style={styles.image}/&amp;gt;
            &amp;lt;/View&amp;gt;
            &amp;lt;Button
                title=&quot;Take Image&quot;
                color={Colors.primary}
                onPress={takeImageHandler} /&amp;gt;
        &amp;lt;/View&amp;gt;

const styles = StyleSheet.create({
    imagePicker:{

    },
    imagePreview:{
        width:'100%',
        height:200,
        marginBottom:10,
        justifyContent:'center',
        alignItems:'center',
        borderColor:'#ccc',
        borderWidth:1

    },
    image:{
        width:'100%',
        height:'100%'
    }
});

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中的布局方式可以看这篇&lt;a href=&quot;https://www.jianshu.com/p/c390042d6140&quot; target=&quot;_blank&quot;&gt;react-native中flexDirection、justifyContent、alignItems的简单使用&lt;/a&gt;
剩下的内容只需要看style逻辑就好。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要了解ES6中异步的相关知识，主要会用到的是async 和 await，因为涉及到Promiss中的内容但是我还没有好好看：）但是可以先了解一下异步操作，&lt;a href=&quot;https://www.jianshu.com/p/4e91c4be2843&quot; target=&quot;_blank&quot;&gt;ES6之async和await&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;理清RN中action和reducer的关系，在这个项目中每个页面功能分别对应一个action和reducer，action中存放的是界面中可以调用执行缓存的方法，返回的type标定了从页面上传来的数据是作用于什么场合；之后action会将数据return给reducer，reducer是真正意义上对缓存操作，相对于数据库更为灵活，可以根据从action中传入的type不同对数据进行不同的处理。如果想要拿到缓存中的数据，可以利用useSelector实现，同样需要搭配一些设置。这里是简单了解。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 06 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/06/React-Native-startlearing/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/06/React-Native-startlearing/</guid>
        
        <category>react native</category>
        
        <category>self-learning</category>
        
        
      </item>
    
  </channel>
</rss>
