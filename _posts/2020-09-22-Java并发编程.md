---
layout: post
title: ' Java并发 '
subtitle: 'Java practice'
date: 2020--09-21
author: 'Joy'
header-img: 'img/java.jpg'
tags:
  - java
  - self-learning
  - thread learning
---

## Java开发中绕不开的环节，并发编程
新手java开发，已经有一些基于spring开发的经验，但是在实际应用中对Java整个的运行机制还是不了解。主要依赖的课程是b站上<a href="https://www.bilibili.com/video/BV16J411h7Rd" target="_blank">Java 并发</a>
### Thread 和 Runnable
线程创建方法
+ 方法1 先有任务对象，再有线程对象。

```
public class Test1{
  public static void main(String[] args){
    Thread t = new Thread(){
      @Override
      public void run(){
        log.debug("running");
      }
    };
    t.setName("t1");// 给线程设置名字
    t.start();
  }
}
```

用lambda简化方法1
```
new Thread(()->{
  log.debug("running");
}, "t1").start();
```

+ 方法2 先创建线程对象，在里面执行任务。 

```
public class Test2{
  public static void main(String[] args){
   Runnable r = new Runnable(){
     @Override
     public void run(){
       log.debug("running");
     }
   };
   Thread t = new Thread(r,"t2");// t2是给线程设置名字
   t.start();
  }
}
```

用lambda简化Runnable
```
Runnable r = () ->{
       log.debug("running");
   };
```
对于第一和第二种，Runnable也是实现对run方法的Override。
方法1是线程任务合并，方法2是线程任务分开。
推荐使用方法2，Runnable更容易与线程池等高级API实现结合。

+ 方法3 FutureTask
能够接受callable类型参数，任务执行完将内容传给其他线程。

```
public class Test3{
  public static void main(String[] args){
    FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>(){
      @Override
      public Integer call() throws Exception{
        log.debug("running");
        Thread.sleep(1000);
        return 100;
      }
    });
    Thread t = new Thread(task,"t3");// t3是线程名
    t.start();

    task.get();//使用 等待task返回结果
}

```

### 线程交替执行情况
只有在多核cpu才能利用多种Thread

+ 查看进程方法 linux
  + ps -fe 查看所有进程  后面再加`| grep java`查看java进程
  + ps -fT -p <PID> 
  + kill <PID>杀死进程
  + top 查看进行占用百分比 top -H -p <PID> 查看所有进程中的线程信息 
   

+ Java
  + jps 查看所有Java进程
  + jstack <PID> 查看线程的 snapshot

+ jconsole java进程 可以远程监控 针对虚拟机专用

### 线程运行原理
JVM  java virtual machine stack 给虚拟机分配空间
+ 栈帧信息 frame

  多线程实现， 线程之间栈帧独立

+ 线程上下文切换 Thread Context Switch 

产生情况

  1. 从使用Cpu时间片用完
  2. 垃圾回收
  3. 更高级线程
  4. 线程自己调用 sleep yield wait join park synchronized lock

在switch的时候需要保证线程状态，程序计数器Program Counter Register 记住下一条指令地址，频繁 Context Switch 影响 性能

### 线程常见方法

+ start() 启动新线程 start让线程进入就绪转态，里面代码不会立即执行，每个线程对象start方法只能调用一次
+ run() 在构造Thread对象时传入 Runnable参数，在线程启动后会调用Runnable中run方法，可以创建Thread子类对象，来覆盖默认行为。
+ join() 等待线程运行结束
+ join(long n) 等待线程运行结束,最多等待n秒
+ getId() 获取线程长整型的id
+ getName() 获取线程名
+ getPriority() setPriority() 设置线程优先级
+ getState() 线程状态 6种
+ isInterrupted() 判断线程是不是被打断
+ isAlive() 判断线程是否存活
+ interrupt() 打断线程
+ currentThread() static 获取当前线程
+ sleep(long n) static 当前线程休眠
+ yield（） static 提示线程调度器让出当前线程 

#### 详细讲解方法

##### run 和 start

**start启动线程**，再由线程调用自己定义的run方法。只能调用1次的start方法。

##### yield 和 sleep

**sleep**

1. Running到Time Waiting阻塞，在哪个线程里被调用，就在哪个线程里休眠。
2. 其他线程可使用interrupt()打断正在睡眠的线程，sleep抛异常。
3. 睡眠结束未必会立即执行
4. 建议使用TimeUnit 的 sleep 代替 Thread.sleep() 提高可读性
```
TimeUnit.SECONDS.sleep(1);//单位换算
```

**yield**

1. Running 到 Runnable就绪，之后执行其他**同优先级**线程。
2. 具体实现依赖调度器。

+ 就绪和阻塞区别，分配时间片不会考虑阻塞线程，只会分配给就绪线程，同时sleep有等待时间，而yield没有。

##### 线程优先级
在thread类中保留的优先级，数字越大优先级越高。优先级会提示哪个优先使用。cpu忙不会太注意优先级。
```
Thread t = new Thread(task,"t");
t.setPriority(Thread.MIN_PRIORITY);//最小优先级
t.start();
```
##### 案例 防止CPU占用100%资源
多用于服务器开发，防止cpu100%占用资源
```
while (true){
  try{
    Thread.sleep(50);
  }catch(){
    ...
  }
}
```
可以用wait达到同样效果，sleep适用于无锁、同步场景

##### **join 方法**
等待线程运行结束，哪个线程调用join就代表使用结束
```
static int r = 0;
...

Thread t1 = new Thread(() ->{
  sleep(1);
  r=10;
}, "t1");
t1.start();
// t1.join();
log(r);
```
获得的r值不是新创建线程的值，因为主线程和t1线程并行执行，t1线程需要1秒才能算出r=10，而主线程一开就获得了r结果。不能使用sleep使主线程也睡眠，而是使用join在r1.start之后使主线程等待t1结束执行。`t1.join()`.

**同步：调用方需要等待结果返回**
**异步：调用方不需要等结果返回**
如果主线程等不同线程的返回结果可以多个调用join。
多个线程join，并且同时开始执行，运行时间是最长的线程等待时间。

###### join 传入参数，有时效等待
`join(1500);`等待1.5秒，如果没有等够时间，就不继续等待，同样，如果线程执行时间小于等待时效，在线程结束之后也就不再等待。

##### **interrupt**
打断sleep, wait, join 的线程
打断阻塞线程，打断sleep线程，会清空打断状态
```
Thread t1 = new Thread(() ->{
  try{
    Thread.sleep(5000);
  }catch(InterruptedException e){//打断的异常，会有打断标记，是boolean 有过为true，但是sleep、wait、join会将打断标记设置为false
    e.printStackTrace();
  }
},"t1);
t1.start();
t1.interrupt();
```
***小知识：打断的异常，会有打断标记，是boolean 有过为true，但是sleep、wait、join会将打断标记设置为false***
***获取打断标记的方法`线程名.isInterrupted();`***

##### 打断正常运行的代码会怎样?

```
Thread t1 = new Thread(() ->{
  while(true){
    boolean inter = Thread.currentThread().isInterrupted();
    if(inter){//表示被打断了，退出循环
      break;
    }
  }
},"t1");
t1.start();

Thread.sleep(1000);
t1.interrupt();
```

代码中是主线程睡眠，但是打断的是创建的t1线程，t1线程是否继续执行是依靠是这个线程里面的判断。这个例子中利用打断状态获得是否继续执行的条件。

##### interrupt设计模式
1. 两阶段终止模式
eg.强制stop()线程，如果线程锁住共享资源则在stop线程之后就没有机会释放锁。其他线程不能获取锁。
应用场景，定时监控cpu利用率，需要不断监控。


while true  -> 有没有被打断
 
 ->是 就结束循环

 ->否 睡眠 如果无异常就继续监控，如果被打断就设置打断标记。

```
class TwoPhaseTermination {
  private Thread monitor;
  //启动监控线程
  public void start(){
    monitor = new Thread(()->{
      while(true){
        Thread current = Thread.currentThread();
        if (current.isInterrupted()){
          break;
        }
        try{
           Thread.sleep(1000);
        }catch{
          ...
          //重新设置打断标记
          current.interrupt();
        }
      }
    });
    monitor.start();
  }
  //停止监控线程
  public void stop(){
    monitor.interrupt();// 因为会清空打断标记
  }
}
```
***注意点***
isInterrupted()不清除打断标记
静态方法interrupted()清除打断标记

##### **打断park**
`LockSupport.park()`停止线程，之后的代码不会执行，interrupt可以打断这个正在park的线程。这个会保留打断标记，在park之后再次执行park，线程不会停下来。（打断标记为真，park会失效，可以和interrupted()方法搭配使用。）

##### 不推荐使用的方法
以下是容易破坏同步代码块的方法，已经过时。
 stop() 停止线程运行
 suspedn() 挂起线程
 resume() 恢复线程运行


#### 主线程和守护线程
默认情况下java进程是等待所有线程结束运行才会结束，有一种特殊的线程叫**守护线程**只要它的非守护线程结束，即使守护线程的代码没有执行完也会强制结束。
守护线程应用：1)垃圾回收机制，2)Tomcat中的Acceptor和Poller都是守护线程

#### 线程状态
5种 初始 -> 可运行 -> 运行 -> 终止 
运行和可运行可以来回转换，阻塞状态就是使线程放弃CPU使用权，调度器不会考虑阻塞状态线程。 
阻塞API结束 阻塞变为可运行。

6种 ThreadState 从Java层面表示
new初始
runnable包括运行、可运行和阻塞
terminated终止状态，线程结束，不会转化为其他状态。
blocked：阻塞 sync 
waiting：阻塞 join 
timed waiting：阻塞 sleep有时限的等待
**阻塞就是调度器不会再分时间片**

获得状态信息`getState()`



阻塞线程在Java中的形式
##### **wait**











